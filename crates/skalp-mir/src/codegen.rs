//! SystemVerilog code generation from MIR
//!
//! This module converts MIR to SystemVerilog code

use crate::mir::*;

/// SystemVerilog code generator
pub struct SystemVerilogGenerator {
    /// Indentation level
    indent_level: usize,
    /// Generated code buffer
    output: String,
    /// Current module being generated
    current_module: Option<Module>,
}

impl SystemVerilogGenerator {
    /// Create a new generator
    pub fn new() -> Self {
        Self {
            indent_level: 0,
            output: String::new(),
            current_module: None,
        }
    }

    /// Generate SystemVerilog from MIR
    pub fn generate(&mut self, mir: &Mir) -> String {
        self.output.clear();

        // Add header comment
        self.emit_line("// Generated by SKALP compiler");
        self.emit_line(&format!("// Module: {}", mir.name));
        self.emit_newline();

        // Generate each module
        for module in &mir.modules {
            self.generate_module(module);
            self.emit_newline();
        }

        self.output.clone()
    }

    /// Generate a module
    fn generate_module(&mut self, module: &Module) {
        // Module declaration
        self.emit(&format!("module {}", module.name));

        // Generate port list
        if !module.ports.is_empty() {
            self.emit(" (");
            self.emit_newline();
            self.indent();

            for (i, port) in module.ports.iter().enumerate() {
                self.generate_port_declaration(port, i == module.ports.len() - 1);
            }

            self.dedent();
            self.emit_line(");");
        } else {
            self.emit_line(";");
        }

        self.emit_newline();
        self.indent();

        // Generate internal signals
        for signal in &module.signals {
            self.generate_signal_declaration(signal);
        }
        if !module.signals.is_empty() {
            self.emit_newline();
        }

        // Generate variables
        for var in &module.variables {
            self.generate_variable_declaration(var);
        }
        if !module.variables.is_empty() {
            self.emit_newline();
        }

        // Generate continuous assignments
        for assign in &module.assignments {
            self.generate_continuous_assignment(assign);
        }
        if !module.assignments.is_empty() {
            self.emit_newline();
        }

        // Generate processes
        for process in &module.processes {
            self.generate_process(process);
            self.emit_newline();
        }

        // Generate module instances
        for instance in &module.instances {
            self.generate_instance(instance);
            self.emit_newline();
        }

        self.dedent();
        self.emit_line("endmodule");
    }

    /// Generate port declaration
    fn generate_port_declaration(&mut self, port: &Port, is_last: bool) {
        let dir_str = match port.direction {
            PortDirection::Input => "input",
            PortDirection::Output => "output",
            PortDirection::InOut => "inout",
        };

        let type_str = self.format_data_type(&port.port_type);

        self.emit(&format!("{} {} {}", dir_str, type_str, port.name));

        if !is_last {
            self.emit(",");
        }
        self.emit_newline();
    }

    /// Generate signal declaration
    fn generate_signal_declaration(&mut self, signal: &Signal) {
        let type_str = self.format_data_type(&signal.signal_type);

        self.emit(&format!("{} {}", type_str, signal.name));

        if let Some(init) = &signal.initial {
            self.emit(&format!(" = {}", self.format_value(init)));
        }

        self.emit_line(";");
    }

    /// Generate variable declaration
    fn generate_variable_declaration(&mut self, var: &Variable) {
        let type_str = self.format_data_type(&var.var_type);

        self.emit(&format!("{} {}", type_str, var.name));

        if let Some(init) = &var.initial {
            self.emit(&format!(" = {}", self.format_value(init)));
        }

        self.emit_line(";");
    }

    /// Generate continuous assignment
    fn generate_continuous_assignment(&mut self, assign: &ContinuousAssign) {
        self.emit("assign ");
        self.emit(&self.format_lvalue(&assign.lhs));
        self.emit(" = ");
        self.emit(&self.format_expression(&assign.rhs));
        self.emit_line(";");
    }

    /// Generate process (always block)
    fn generate_process(&mut self, process: &Process) {
        match &process.sensitivity {
            SensitivityList::Always => {
                self.emit("always_comb ");
            }
            SensitivityList::Edge(edges) => {
                self.emit("always_ff @(");
                for (i, edge) in edges.iter().enumerate() {
                    if i > 0 {
                        self.emit(" or ");
                    }
                    match edge.edge {
                        EdgeType::Rising => self.emit("posedge "),
                        EdgeType::Falling => self.emit("negedge "),
                        EdgeType::Both => self.emit("edge "),
                        EdgeType::Active => {
                            // For reset active: typically posedge for active-high, negedge for active-low
                            // We'll assume active-high for now (could be configurable)
                            self.emit("posedge ");
                        }
                        EdgeType::Inactive => {
                            // For reset inactive: typically negedge for active-high, posedge for active-low
                            self.emit("negedge ");
                        }
                    }
                    self.emit(&self.format_lvalue(&edge.signal));
                }
                self.emit(") ");
            }
            SensitivityList::Level(signals) => {
                self.emit("always @(");
                for (i, signal) in signals.iter().enumerate() {
                    if i > 0 {
                        self.emit(" or ");
                    }
                    self.emit(&self.format_lvalue(signal));
                }
                self.emit(") ");
            }
        }

        self.generate_block(&process.body);
    }

    /// Generate block
    fn generate_block(&mut self, block: &Block) {
        self.emit_line("begin");
        self.indent();

        for stmt in &block.statements {
            self.generate_statement(stmt);
        }

        self.dedent();
        self.emit_line("end");
    }

    /// Generate statement
    fn generate_statement(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Assignment(assign) => {
                self.generate_assignment(assign);
            }
            Statement::If(if_stmt) => {
                self.generate_if_statement(if_stmt);
            }
            Statement::Case(case_stmt) => {
                self.generate_case_statement(case_stmt);
            }
            Statement::Block(block) => {
                self.generate_block(block);
            }
            Statement::Loop(_loop_stmt) => {
                // TODO: Implement loop generation
                self.emit_line("// TODO: Loop statement");
            }
            Statement::ResolvedConditional(resolved) => {
                self.generate_resolved_conditional(resolved);
            }
        }
    }

    /// Generate assignment
    fn generate_assignment(&mut self, assign: &Assignment) {
        self.emit(&self.format_lvalue(&assign.lhs));

        match assign.kind {
            AssignmentKind::Blocking => self.emit(" = "),
            AssignmentKind::NonBlocking => self.emit(" <= "),
        }

        self.emit(&self.format_expression(&assign.rhs));
        self.emit_line(";");
    }

    /// Generate if statement
    fn generate_if_statement(&mut self, if_stmt: &IfStatement) {
        self.emit("if (");
        self.emit(&self.format_expression(&if_stmt.condition));
        self.emit(") ");

        self.generate_block(&if_stmt.then_block);

        if let Some(else_block) = &if_stmt.else_block {
            self.emit("else ");
            self.generate_block(else_block);
        }
    }

    /// Generate synthesis-resolved conditional assignment
    fn generate_resolved_conditional(&mut self, resolved: &ResolvedConditional) {
        // Generate as a single continuous assignment with nested ternary operators
        self.emit(&self.format_lvalue(&resolved.target));
        match resolved.kind {
            AssignmentKind::NonBlocking => self.emit(" <= "),
            AssignmentKind::Blocking => self.emit(" = "),
        }

        // Build nested ternary from priority mux
        let expr = self.build_ternary_expression(&resolved.resolved);
        self.emit(&self.format_expression(&expr));
        self.emit_line(";");
    }

    /// Build nested ternary expression from priority mux
    fn build_ternary_expression(&self, mux: &PriorityMux) -> Expression {
        let mut result = mux.default.clone();

        // Build ternary chain from right to left (lowest to highest priority)
        for case in mux.cases.iter().rev() {
            result = Expression::Conditional {
                cond: Box::new(case.condition.clone()),
                then_expr: Box::new(case.value.clone()),
                else_expr: Box::new(result),
            };
        }

        result
    }

    /// Generate case statement
    fn generate_case_statement(&mut self, case_stmt: &CaseStatement) {
        self.emit("case (");
        self.emit(&self.format_expression(&case_stmt.expr));
        self.emit_line(")");
        self.indent();

        for item in &case_stmt.items {
            for (i, value) in item.values.iter().enumerate() {
                if i > 0 {
                    self.emit(", ");
                }
                self.emit(&self.format_expression(value));
            }
            self.emit(": ");
            self.generate_block(&item.block);
        }

        if let Some(default) = &case_stmt.default {
            self.emit("default: ");
            self.generate_block(default);
        }

        self.dedent();
        self.emit_line("endcase");
    }

    /// Generate module instance
    fn generate_instance(&mut self, instance: &ModuleInstance) {
        // TODO: Look up module name from ModuleId
        self.emit(&format!("module_{} {}", instance.module.0, instance.name));

        if !instance.connections.is_empty() {
            self.emit_line(" (");
            self.indent();

            let mut is_first = true;
            for (port_name, expr) in instance.connections.iter() {
                if !is_first {
                    self.emit(",");
                    self.emit_newline();
                }
                self.emit(&format!(".{}(", port_name));
                self.emit(&self.format_expression(expr));
                self.emit(")");
                is_first = false;
            }
            self.emit_newline();

            self.dedent();
            self.emit_line(");");
        } else {
            self.emit_line("();");
        }
    }

    /// Format data type
    fn format_data_type(&self, dtype: &DataType) -> String {
        match dtype {
            DataType::Bit(width) => {
                if *width == 1 {
                    "wire".to_string()
                } else {
                    format!("wire [{}:0]", width - 1)
                }
            }
            DataType::Bool => "wire".to_string(), // Boolean represented as single-bit wire
            DataType::Logic(width) => {
                if *width == 1 {
                    "logic".to_string()
                } else {
                    format!("logic [{}:0]", width - 1)
                }
            }
            DataType::Int(width) => format!("int [{}:0]", width - 1),
            DataType::Nat(width) => format!("logic [{}:0]", width - 1),
            DataType::Clock { .. } => "wire".to_string(),
            DataType::Reset { .. } => "wire".to_string(),
            DataType::Event => "event".to_string(),
            DataType::Struct(struct_type) => {
                if struct_type.packed {
                    format!(
                        "packed struct {{{}}}",
                        self.format_struct_fields(&struct_type.fields)
                    )
                } else {
                    format!(
                        "struct {{{}}}",
                        self.format_struct_fields(&struct_type.fields)
                    )
                }
            }
            DataType::Enum(enum_type) => {
                format!(
                    "enum {} {{{}}}",
                    self.format_data_type(&enum_type.base_type),
                    self.format_enum_variants(&enum_type.variants)
                )
            }
            DataType::Union(union_type) => {
                if union_type.packed {
                    format!(
                        "packed union {{{}}}",
                        self.format_struct_fields(&union_type.fields)
                    )
                } else {
                    format!(
                        "union {{{}}}",
                        self.format_struct_fields(&union_type.fields)
                    )
                }
            }
            DataType::Array(element_type, size) => {
                format!("{} [0:{}]", self.format_data_type(element_type), size - 1)
            }
            // Parametric types use parameter name in width spec
            DataType::BitParam { param, default } => {
                if *default == 1 {
                    "wire".to_string()
                } else {
                    format!("wire [{}-1:0]", param)
                }
            }
            DataType::LogicParam { param, default } => {
                if *default == 1 {
                    "logic".to_string()
                } else {
                    format!("logic [{}-1:0]", param)
                }
            }
            DataType::IntParam { param, default } => {
                format!("int [{}-1:0]", param)
            }
            DataType::NatParam { param, default } => {
                format!("logic [{}-1:0]", param)
            }
            // Floating-point types
            DataType::Float16 => "fp16_t".to_string(), // Will be defined in FP library
            DataType::Float32 => "fp32_t".to_string(),
            DataType::Float64 => "fp64_t".to_string(),
            // Vector types - represented as packed structs
            DataType::Vec2(element_type) => {
                format!("vec2_{}_t", self.type_suffix(element_type))
            }
            DataType::Vec3(element_type) => {
                format!("vec3_{}_t", self.type_suffix(element_type))
            }
            DataType::Vec4(element_type) => {
                format!("vec4_{}_t", self.type_suffix(element_type))
            }
        }
    }

    /// Get a short suffix for a type (for naming vector types)
    fn type_suffix(&self, dtype: &DataType) -> String {
        match dtype {
            DataType::Float16 => "fp16".to_string(),
            DataType::Float32 => "fp32".to_string(),
            DataType::Float64 => "fp64".to_string(),
            DataType::Bit(w) => format!("b{}", w),
            DataType::Int(w) => format!("i{}", w),
            DataType::Nat(w) => format!("u{}", w),
            _ => "t".to_string(),
        }
    }

    /// Format struct fields for SystemVerilog
    fn format_struct_fields(&self, fields: &[StructField]) -> String {
        fields
            .iter()
            .map(|field| {
                format!(
                    "{} {};",
                    self.format_data_type(&field.field_type),
                    field.name
                )
            })
            .collect::<Vec<String>>()
            .join(" ")
    }

    /// Format enum variants for SystemVerilog
    fn format_enum_variants(&self, variants: &[EnumVariant]) -> String {
        variants
            .iter()
            .map(|variant| {
                if let Some(value) = &variant.value {
                    format!("{} = {}", variant.name, self.format_value(value))
                } else {
                    variant.name.clone()
                }
            })
            .collect::<Vec<String>>()
            .join(", ")
    }

    /// Format lvalue
    fn format_lvalue(&self, lval: &LValue) -> String {
        match lval {
            LValue::Signal(id) => {
                if let Some(ref module) = self.current_module {
                    module
                        .signals
                        .iter()
                        .find(|s| s.id == *id)
                        .map(|s| s.name.clone())
                        .unwrap_or_else(|| format!("sig_{}", id.0))
                } else {
                    format!("sig_{}", id.0)
                }
            }
            LValue::Variable(id) => {
                if let Some(ref module) = self.current_module {
                    module
                        .variables
                        .iter()
                        .find(|v| v.id == *id)
                        .map(|v| v.name.clone())
                        .unwrap_or_else(|| format!("var_{}", id.0))
                } else {
                    format!("var_{}", id.0)
                }
            }
            LValue::Port(id) => {
                if let Some(ref module) = self.current_module {
                    module
                        .ports
                        .iter()
                        .find(|p| p.id == *id)
                        .map(|p| p.name.clone())
                        .unwrap_or_else(|| format!("port_{}", id.0))
                } else {
                    format!("port_{}", id.0)
                }
            }
            LValue::BitSelect { base, index } => {
                format!(
                    "{}[{}]",
                    self.format_lvalue(base),
                    self.format_expression(index)
                )
            }
            LValue::RangeSelect { base, high, low } => {
                format!(
                    "{}[{}:{}]",
                    self.format_lvalue(base),
                    self.format_expression(high),
                    self.format_expression(low)
                )
            }
            LValue::Concat(lvals) => {
                let parts: Vec<String> = lvals.iter().map(|l| self.format_lvalue(l)).collect();
                format!("{{{}}}", parts.join(", "))
            }
        }
    }

    /// Format expression
    fn format_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(val) => self.format_value(val),
            Expression::Ref(lval) => self.format_lvalue(lval),
            Expression::Binary { op, left, right } => {
                format!(
                    "({} {} {})",
                    self.format_expression(left),
                    self.format_binary_op(op),
                    self.format_expression(right)
                )
            }
            Expression::Unary { op, operand } => {
                format!(
                    "{}{}",
                    self.format_unary_op(op),
                    self.format_expression(operand)
                )
            }
            Expression::Conditional {
                cond,
                then_expr,
                else_expr,
            } => {
                format!(
                    "({} ? {} : {})",
                    self.format_expression(cond),
                    self.format_expression(then_expr),
                    self.format_expression(else_expr)
                )
            }
            Expression::Concat(exprs) => {
                let parts: Vec<String> = exprs.iter().map(|e| self.format_expression(e)).collect();
                format!("{{{}}}", parts.join(", "))
            }
            Expression::Replicate { count, value } => {
                format!(
                    "{{{{{}}}{{{}}}}}",
                    self.format_expression(count),
                    self.format_expression(value)
                )
            }
            Expression::FunctionCall { name, args } => {
                let arg_strs: Vec<String> =
                    args.iter().map(|a| self.format_expression(a)).collect();
                format!("{}({})", name, arg_strs.join(", "))
            }
        }
    }

    /// Format value
    fn format_value(&self, val: &Value) -> String {
        match val {
            Value::Integer(n) => n.to_string(),
            Value::Float(f) => f.to_string(),
            Value::BitVector { width, value } => {
                format!("{}'h{:x}", width, value)
            }
            Value::String(s) => format!("\"{}\"", s),
            Value::HighZ => "'z".to_string(),
            Value::Unknown => "'x".to_string(),
        }
    }

    /// Format binary operator
    fn format_binary_op(&self, op: &BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::FAdd => "+",
            BinaryOp::FSub => "-",
            BinaryOp::FMul => "*",
            BinaryOp::FDiv => "/",
            BinaryOp::And => "&", // Logical AND in context
            BinaryOp::Or => "|",  // Logical OR in context
            BinaryOp::Xor => "^", // Logical XOR in context
            BinaryOp::BitwiseAnd => "&",
            BinaryOp::BitwiseOr => "|",
            BinaryOp::BitwiseXor => "^",
            BinaryOp::LogicalAnd => "&&",
            BinaryOp::LogicalOr => "||",
            BinaryOp::Equal => "==",
            BinaryOp::NotEqual => "!=",
            BinaryOp::Less => "<",
            BinaryOp::LessEqual => "<=",
            BinaryOp::Greater => ">",
            BinaryOp::GreaterEqual => ">=",
            BinaryOp::FEqual => "==",
            BinaryOp::FNotEqual => "!=",
            BinaryOp::FLess => "<",
            BinaryOp::FLessEqual => "<=",
            BinaryOp::FGreater => ">",
            BinaryOp::FGreaterEqual => ">=",
            BinaryOp::LeftShift => "<<",
            BinaryOp::RightShift => ">>",
        }
    }

    /// Format unary operator
    fn format_unary_op(&self, op: &UnaryOp) -> String {
        match op {
            UnaryOp::Not => "!".to_string(),
            UnaryOp::BitwiseNot => "~".to_string(),
            UnaryOp::Negate => "-".to_string(),
            UnaryOp::Reduce(reduce_op) => match reduce_op {
                ReduceOp::And => "&".to_string(),
                ReduceOp::Or => "|".to_string(),
                ReduceOp::Xor => "^".to_string(),
                ReduceOp::Nand => "~&".to_string(),
                ReduceOp::Nor => "~|".to_string(),
                ReduceOp::Xnor => "~^".to_string(),
            },
        }
    }

    // Helper methods for indentation
    fn indent(&mut self) {
        self.indent_level += 1;
    }

    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }

    fn emit(&mut self, text: &str) {
        self.output.push_str(text);
    }

    fn emit_line(&mut self, text: &str) {
        self.emit_indent();
        self.output.push_str(text);
        self.output.push('\n');
    }

    fn emit_newline(&mut self) {
        self.output.push('\n');
    }

    fn emit_indent(&mut self) {
        for _ in 0..self.indent_level {
            self.output.push_str("    ");
        }
    }
}

impl Default for SystemVerilogGenerator {
    fn default() -> Self {
        Self::new()
    }
}
