//! IceStorm ASCII (.asc) Format Generator
//!
//! Generates human-readable ASCII bitstream format compatible with IceStorm tools.
//! The .asc format is documented at: https://clifford.at/icestorm/
//!
//! Format overview:
//! - .device <name>
//! - .comment <text>
//! - .logic_tile X Y followed by 16 rows of 54 bits each
//! - .io_tile X Y followed by 16 rows of 18 bits each
//! - .ramb_tile/.ramt_tile X Y followed by 16 rows of 42 bits each

use crate::device::ice40::{chipdb_parser::ChipDb, Ice40Device, Ice40Variant};
use crate::device::{BelType, Device, TileType};
use crate::error::Result;
use crate::placer::PlacementResult;
use crate::router::RoutingResult;
use std::collections::HashMap;

/// IceStorm ASCII format generator
pub struct IceStormAscii<'a> {
    device: &'a Ice40Device,
    chipdb: Option<ChipDb>,
}

impl<'a> IceStormAscii<'a> {
    /// Create a new ASCII generator
    pub fn new(device: &'a Ice40Device) -> Self {
        // Try to load chipdb for real bit mappings
        let chipdb = ChipDb::load_embedded(device.variant).ok();
        Self { device, chipdb }
    }

    /// Generate ASCII bitstream
    pub fn generate(&self, placement: &PlacementResult, routing: &RoutingResult) -> Result<String> {
        let mut asc = String::new();
        let (width, height) = self.device.grid_size();

        // Device name for IceStorm (e.g., "1k", "8k")
        let device_name = match self.device.variant {
            Ice40Variant::Hx1k | Ice40Variant::Lp1k => "1k",
            Ice40Variant::Hx4k | Ice40Variant::Lp4k => "5k",
            Ice40Variant::Hx8k | Ice40Variant::Lp8k => "8k",
            Ice40Variant::Up5k => "up5k",
        };

        // Header
        asc.push_str(&format!(".device {}\n", device_name));
        asc.push_str(".comment Generated by SKALP Native Place & Route\n");
        asc.push('\n');

        // Collect LUT init values from placement
        let lut_inits = self.collect_lut_inits(placement);

        // Generate tile configurations
        for y in 0..height {
            for x in 0..width {
                if let Some(tile) = self.device.tile_at(x, y) {
                    match tile.tile_type() {
                        TileType::Logic => {
                            self.generate_logic_tile(
                                &mut asc, x, y, placement, routing, &lut_inits,
                            );
                        }
                        TileType::IoTop
                        | TileType::IoBottom
                        | TileType::IoLeft
                        | TileType::IoRight => {
                            self.generate_io_tile(&mut asc, x, y, placement);
                        }
                        TileType::RamTop => {
                            self.generate_ramt_tile(&mut asc, x, y, placement);
                        }
                        TileType::RamBottom => {
                            self.generate_ramb_tile(&mut asc, x, y, placement);
                        }
                        _ => {}
                    }
                }
            }
        }

        Ok(asc)
    }

    /// Collect LUT init values from placement
    fn collect_lut_inits(&self, placement: &PlacementResult) -> HashMap<(u32, u32, usize), u16> {
        let mut lut_inits = HashMap::new();

        for loc in placement.placements.values() {
            if matches!(loc.bel_type, BelType::Lut4) {
                // For now, use a simple init value
                // In a real implementation, we'd get this from the netlist cell's lut_init field
                // The lut_init should come from the technology mapping phase
                lut_inits.insert((loc.tile_x, loc.tile_y, loc.bel_index), 0x0000);
            }
        }

        lut_inits
    }

    /// Generate logic tile configuration
    /// Logic tiles have 54 columns x 16 rows of config bits
    fn generate_logic_tile(
        &self,
        asc: &mut String,
        x: u32,
        y: u32,
        placement: &PlacementResult,
        routing: &RoutingResult,
        lut_inits: &HashMap<(u32, u32, usize), u16>,
    ) {
        // Check if any cells are placed in this tile
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| loc.tile_x == x && loc.tile_y == y)
            .collect();

        // Check if any routing uses this tile
        let has_routing = routing.routes.values().any(|route| {
            route.wires.iter().any(|&wire| {
                self.device
                    .wire(wire)
                    .map(|w| w.tile_x == x && w.tile_y == y)
                    .unwrap_or(false)
            })
        });

        if cells_in_tile.is_empty() && !has_routing {
            return;
        }

        asc.push_str(&format!(".logic_tile {} {}\n", x, y));

        // Create a 16x54 bit array (16 rows, 54 columns)
        let mut bits = [[false; 54]; 16];

        // Set LUT init bits based on chipdb mappings
        if let Some(ref chipdb) = self.chipdb {
            for lc_mapping in &chipdb.lc_mappings {
                let lc_idx = lc_mapping.lc_idx as usize;
                let init = lut_inits.get(&(x, y, lc_idx)).copied().unwrap_or(0);

                // The first 16 bits of lc_mapping.bit_positions are for the LUT init
                // (the remaining 4 are for other LC configuration)
                for (bit_num, &(row, col)) in lc_mapping.bit_positions.iter().take(16).enumerate() {
                    if row < 16 && col < 54 {
                        let bit_value = (init >> bit_num) & 1 == 1;
                        bits[row as usize][col as usize] = bit_value;
                    }
                }
            }
        }

        // Output the 16 rows of 54 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate I/O tile configuration
    /// I/O tiles have 18 columns x 16 rows of config bits
    fn generate_io_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::IoCell)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".io_tile {} {}\n", x, y));

        // Create a 16x18 bit array (16 rows, 18 columns)
        let bits = [[false; 18]; 16];

        // TODO: Set I/O config bits based on placement and chipdb

        // Output the 16 rows of 18 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate RAM bottom tile configuration
    /// RAM tiles have 42 columns x 16 rows of config bits
    fn generate_ramb_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::RamSlice)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".ramb_tile {} {}\n", x, y));

        // Create a 16x42 bit array (16 rows, 42 columns)
        let bits = [[false; 42]; 16];

        // Output the 16 rows of 42 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate RAM top tile configuration
    fn generate_ramt_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::RamSlice)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".ramt_tile {} {}\n", x, y));

        // Create a 16x42 bit array (16 rows, 42 columns)
        let bits = [[false; 42]; 16];

        // Output the 16 rows of 42 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }
}
