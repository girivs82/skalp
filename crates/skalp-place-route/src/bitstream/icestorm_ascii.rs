//! IceStorm ASCII (.asc) Format Generator
//!
//! Generates human-readable ASCII bitstream format compatible with IceStorm tools.
//! The .asc format is documented at: https://clifford.at/icestorm/
//!
//! Format overview:
//! - .device <name>
//! - .comment <text>
//! - .logic_tile X Y followed by 16 rows of 54 bits each
//! - .io_tile X Y followed by 16 rows of 18 bits each
//! - .ramb_tile/.ramt_tile X Y followed by 16 rows of 42 bits each

use crate::device::ice40::{chipdb_parser::ChipDb, Ice40Device, Ice40Variant};
use crate::device::{BelType, Device, TileType};
use crate::error::Result;
use crate::placer::PlacementResult;
use crate::router::RoutingResult;
use skalp_lir::gate_netlist::GateNetlist;
use std::collections::HashMap;

/// IceStorm ASCII format generator
pub struct IceStormAscii<'a> {
    device: &'a Ice40Device,
    chipdb: Option<ChipDb>,
}

impl<'a> IceStormAscii<'a> {
    /// Create a new ASCII generator
    pub fn new(device: &'a Ice40Device) -> Self {
        // Try to load chipdb for real bit mappings
        let chipdb = ChipDb::load_embedded(device.variant).ok();
        Self { device, chipdb }
    }

    /// Generate ASCII bitstream
    pub fn generate(
        &self,
        placement: &PlacementResult,
        routing: &RoutingResult,
        netlist: Option<&GateNetlist>,
    ) -> Result<String> {
        let mut asc = String::new();
        let (width, height) = self.device.grid_size();

        // Device name for IceStorm (e.g., "1k", "8k")
        let device_name = match self.device.variant {
            Ice40Variant::Hx1k | Ice40Variant::Lp1k => "1k",
            Ice40Variant::Hx4k | Ice40Variant::Lp4k => "5k",
            Ice40Variant::Hx8k | Ice40Variant::Lp8k => "8k",
            Ice40Variant::Up5k => "up5k",
        };

        // Header
        asc.push_str(&format!(".device {}\n", device_name));
        asc.push_str(".comment Generated by SKALP Native Place & Route\n");
        asc.push('\n');

        // Collect LUT init values from placement and netlist
        let lut_inits = self.collect_lut_inits(placement, netlist);

        // Generate tile configurations
        for y in 0..height {
            for x in 0..width {
                if let Some(tile) = self.device.tile_at(x, y) {
                    match tile.tile_type() {
                        TileType::Logic => {
                            self.generate_logic_tile(
                                &mut asc, x, y, placement, routing, &lut_inits,
                            );
                        }
                        TileType::IoTop
                        | TileType::IoBottom
                        | TileType::IoLeft
                        | TileType::IoRight => {
                            self.generate_io_tile(&mut asc, x, y, placement, routing);
                        }
                        TileType::RamTop => {
                            self.generate_ramt_tile(&mut asc, x, y, placement);
                        }
                        TileType::RamBottom => {
                            self.generate_ramb_tile(&mut asc, x, y, placement);
                        }
                        _ => {}
                    }
                }
            }
        }

        Ok(asc)
    }

    /// Collect LUT init values from placement and netlist
    fn collect_lut_inits(
        &self,
        placement: &PlacementResult,
        netlist: Option<&GateNetlist>,
    ) -> HashMap<(u32, u32, usize), u16> {
        let mut lut_inits = HashMap::new();

        for (cell_id, loc) in &placement.placements {
            if matches!(loc.bel_type, BelType::Lut4) {
                // Get LUT init value from netlist cell if available
                let init = if let Some(netlist) = netlist {
                    // Find the cell by ID in the netlist
                    netlist
                        .cells
                        .iter()
                        .find(|c| c.id.0 == cell_id.0)
                        .map(|cell| {
                            // If lut_init is set, use it; otherwise derive from cell type
                            cell.lut_init
                                .map(|init| init as u16)
                                .unwrap_or_else(|| Self::derive_lut_init(&cell.cell_type))
                        })
                        .unwrap_or(0x0000)
                } else {
                    0x0000
                };
                lut_inits.insert((loc.tile_x, loc.tile_y, loc.bel_index), init);
            }
        }

        lut_inits
    }

    /// Derive LUT4 init value from cell type name
    /// Uses standard truth tables for common logic functions
    fn derive_lut_init(cell_type: &str) -> u16 {
        // LUT4 truth table: 16 bits where bit N corresponds to input pattern N
        // For 4 inputs (I3,I2,I1,I0), N = (I3<<3) | (I2<<2) | (I1<<1) | I0
        match cell_type {
            // 1-input functions (use I0)
            "SB_LUT4_NOT" | "INV" => 0x5555, // ~I0

            // 2-input functions (use I0, I1)
            "SB_LUT4_AND2" | "AND2" => 0x8888,   // I0 & I1
            "SB_LUT4_OR2" | "OR2" => 0xEEEE,     // I0 | I1
            "SB_LUT4_XOR2" | "XOR2" => 0x6666,   // I0 ^ I1
            "SB_LUT4_NAND2" | "NAND2" => 0x7777, // ~(I0 & I1)
            "SB_LUT4_NOR2" | "NOR2" => 0x1111,   // ~(I0 | I1)
            "SB_LUT4_XNOR2" | "XNOR2" => 0x9999, // ~(I0 ^ I1)

            // 3-input functions
            "SB_LUT4_AND3" | "AND3" => 0x8080, // I0 & I1 & I2
            "SB_LUT4_OR3" | "OR3" => 0xFEFE,   // I0 | I1 | I2
            "SB_LUT4_XOR3" | "XOR3" => 0x6996, // I0 ^ I1 ^ I2

            // 4-input functions
            "SB_LUT4_AND4" | "AND4" => 0x8000, // I0 & I1 & I2 & I3
            "SB_LUT4_OR4" | "OR4" => 0xFFFE,   // I0 | I1 | I2 | I3
            "SB_LUT4_XOR4" | "XOR4" => 0x6996, // I0 ^ I1 ^ I2 ^ I3

            // MUX functions
            "SB_LUT4_MUX2" | "MUX2" => 0xCACA, // I2 ? I1 : I0

            // Buffer/passthrough
            "SB_LUT4_BUF" | "BUF" => 0xAAAA, // I0 (passthrough)

            // Constant outputs
            "TIE_HIGH" | "VCC" => 0xFFFF,
            "TIE_LOW" | "GND" => 0x0000,

            // Default: passthrough I0 (acts as buffer)
            _ => 0xAAAA,
        }
    }

    /// Generate logic tile configuration
    /// Logic tiles have 54 columns x 16 rows of config bits
    fn generate_logic_tile(
        &self,
        asc: &mut String,
        x: u32,
        y: u32,
        placement: &PlacementResult,
        routing: &RoutingResult,
        lut_inits: &HashMap<(u32, u32, usize), u16>,
    ) {
        // Check if any cells are placed in this tile
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| loc.tile_x == x && loc.tile_y == y)
            .collect();

        // Collect PIPs in this tile from routing
        let pips_in_tile: Vec<_> = routing
            .routes
            .values()
            .flat_map(|route| route.pips.iter())
            .filter(|&&pip_id| {
                self.device
                    .pip(pip_id)
                    .map(|p| p.tile_x == x && p.tile_y == y)
                    .unwrap_or(false)
            })
            .copied()
            .collect();

        if cells_in_tile.is_empty() && pips_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".logic_tile {} {}\n", x, y));

        // Create a 16x54 bit array (16 rows, 54 columns)
        let mut bits = [[false; 54]; 16];

        if let Some(ref chipdb) = self.chipdb {
            // Set LUT init bits based on chipdb mappings
            for lc_mapping in &chipdb.lc_mappings {
                let lc_idx = lc_mapping.lc_idx as usize;
                let init = lut_inits.get(&(x, y, lc_idx)).copied().unwrap_or(0);

                // The first 16 bits of lc_mapping.bit_positions are for the LUT init
                // (the remaining 4 are for other LC configuration)
                for (bit_num, &(row, col)) in lc_mapping.bit_positions.iter().take(16).enumerate() {
                    if row < 16 && col < 54 {
                        let bit_value = (init >> bit_num) & 1 == 1;
                        bits[row as usize][col as usize] = bit_value;
                    }
                }
            }

            // Set routing configuration bits for PIPs
            for pip_id in &pips_in_tile {
                // PipId index corresponds directly to chipdb.pips index
                if let Some(pip_info) = chipdb.pips.get(pip_id.0 as usize) {
                    // Only set bits for PIPs in this tile
                    if pip_info.tile_x == x && pip_info.tile_y == y {
                        for config_bit in &pip_info.config_bits {
                            let row = config_bit.row as usize;
                            let col = config_bit.col as usize;
                            if row < 16 && col < 54 {
                                // If inverted, we want bit=0 to enable, otherwise bit=1
                                bits[row][col] = !config_bit.inverted;
                            }
                        }
                    }
                }
            }
        }

        // Output the 16 rows of 54 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate I/O tile configuration
    /// I/O tiles have 18 columns x 16 rows of config bits
    fn generate_io_tile(
        &self,
        asc: &mut String,
        x: u32,
        y: u32,
        placement: &PlacementResult,
        routing: &RoutingResult,
    ) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::IoCell)
            })
            .collect();

        // Collect PIPs in this tile from routing
        let pips_in_tile: Vec<_> = routing
            .routes
            .values()
            .flat_map(|route| route.pips.iter())
            .filter(|&&pip_id| {
                self.device
                    .pip(pip_id)
                    .map(|p| p.tile_x == x && p.tile_y == y)
                    .unwrap_or(false)
            })
            .copied()
            .collect();

        if cells_in_tile.is_empty() && pips_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".io_tile {} {}\n", x, y));

        // Create a 16x18 bit array (16 rows, 18 columns)
        let mut bits = [[false; 18]; 16];

        if let Some(ref chipdb) = self.chipdb {
            // Set routing configuration bits for PIPs
            for pip_id in &pips_in_tile {
                if let Some(pip_info) = chipdb.pips.get(pip_id.0 as usize) {
                    if pip_info.tile_x == x && pip_info.tile_y == y {
                        for config_bit in &pip_info.config_bits {
                            let row = config_bit.row as usize;
                            let col = config_bit.col as usize;
                            if row < 16 && col < 18 {
                                bits[row][col] = !config_bit.inverted;
                            }
                        }
                    }
                }
            }
        }

        // Output the 16 rows of 18 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate RAM bottom tile configuration
    /// RAM tiles have 42 columns x 16 rows of config bits
    fn generate_ramb_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::RamSlice)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".ramb_tile {} {}\n", x, y));

        // Create a 16x42 bit array (16 rows, 42 columns)
        let bits = [[false; 42]; 16];

        // Output the 16 rows of 42 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate RAM top tile configuration
    fn generate_ramt_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::RamSlice)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".ramt_tile {} {}\n", x, y));

        // Create a 16x42 bit array (16 rows, 42 columns)
        let bits = [[false; 42]; 16];

        // Output the 16 rows of 42 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }
}
