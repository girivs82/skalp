//! IceStorm ASCII (.asc) Format Generator
//!
//! Generates human-readable ASCII bitstream format compatible with IceStorm tools.

use crate::device::ice40::Ice40Device;
use crate::device::{BelType, Device, TileType};
use crate::error::Result;
use crate::placer::PlacementResult;
use crate::router::RoutingResult;

/// IceStorm ASCII format generator
pub struct IceStormAscii<'a> {
    device: &'a Ice40Device,
}

impl<'a> IceStormAscii<'a> {
    /// Create a new ASCII generator
    pub fn new(device: &'a Ice40Device) -> Self {
        Self { device }
    }

    /// Generate ASCII bitstream
    pub fn generate(&self, placement: &PlacementResult, routing: &RoutingResult) -> Result<String> {
        let mut asc = String::new();
        let (width, height) = self.device.grid_size();

        // Header
        asc.push_str(".comment Generated by SKALP Native Place & Route\n");
        asc.push_str(&format!(".device {}\n", self.device.name()));
        asc.push_str(&format!(".grid {} {}\n", width, height));
        asc.push('\n');

        // Generate tile configurations
        for y in 0..height {
            for x in 0..width {
                if let Some(tile) = self.device.tile_at(x, y) {
                    match tile.tile_type() {
                        TileType::Logic => {
                            self.generate_logic_tile(&mut asc, x, y, placement, routing);
                        }
                        TileType::IoTop
                        | TileType::IoBottom
                        | TileType::IoLeft
                        | TileType::IoRight => {
                            self.generate_io_tile(&mut asc, x, y, placement);
                        }
                        TileType::RamTop | TileType::RamBottom => {
                            self.generate_ram_tile(&mut asc, x, y, placement);
                        }
                        _ => {}
                    }
                }
            }
        }

        // Footer
        asc.push_str(".end\n");

        Ok(asc)
    }

    /// Generate logic tile configuration
    fn generate_logic_tile(
        &self,
        asc: &mut String,
        x: u32,
        y: u32,
        placement: &PlacementResult,
        routing: &RoutingResult,
    ) {
        // Check if any cells are placed in this tile
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| loc.tile_x == x && loc.tile_y == y)
            .collect();

        // Check if any routing uses this tile
        let has_routing = routing.routes.values().any(|route| {
            route.wires.iter().any(|&wire| {
                self.device
                    .wire(wire)
                    .map(|w| w.tile_x == x && w.tile_y == y)
                    .unwrap_or(false)
            })
        });

        if cells_in_tile.is_empty() && !has_routing {
            return;
        }

        asc.push_str(&format!(".logic_tile {} {}\n", x, y));

        // Output LUT configurations
        for (_cell_id, loc) in &cells_in_tile {
            if matches!(loc.bel_type, BelType::Lut4) {
                // Get LUT init (would come from netlist)
                let init: u16 = 0; // Placeholder
                asc.push_str(&format!("LC_{} ", loc.bel_index));
                // Output 54 bits per LC (LUT + FF + carry + routing)
                for bit in 0..54 {
                    let value = if bit < 16 { (init >> bit) & 1 } else { 0 };
                    asc.push(if value == 1 { '1' } else { '0' });
                }
                asc.push('\n');
            }
        }

        asc.push('\n');
    }

    /// Generate I/O tile configuration
    fn generate_io_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::IoCell)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".io_tile {} {}\n", x, y));

        for (_, loc) in &cells_in_tile {
            // I/O configuration bits
            asc.push_str(&format!("IO_{} ", loc.bel_index));
            // Output I/O config bits (simplified)
            asc.push_str("0000000000000000\n");
        }

        asc.push('\n');
    }

    /// Generate RAM tile configuration
    fn generate_ram_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::RamSlice)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".ramb_tile {} {}\n", x, y));

        // RAM configuration
        asc.push_str("# RAM configuration\n");
        // RAM init data would go here
        for i in 0..256 {
            asc.push_str(&format!(".ram_data {:02x} 0000000000000000\n", i));
        }

        asc.push('\n');
    }
}
