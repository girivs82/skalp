//! IceStorm ASCII (.asc) Format Generator
//!
//! Generates human-readable ASCII bitstream format compatible with IceStorm tools.
//! The .asc format is documented at: https://clifford.at/icestorm/
//!
//! Format overview:
//! - .device <name>
//! - .comment <text>
//! - .logic_tile X Y followed by 16 rows of 54 bits each
//! - .io_tile X Y followed by 16 rows of 18 bits each
//! - .ramb_tile/.ramt_tile X Y followed by 16 rows of 42 bits each

use crate::device::ice40::{chipdb_parser::ChipDb, Ice40Device, Ice40Variant};
use crate::device::{BelType, Device, TileType};
use crate::error::Result;
use crate::placer::PlacementResult;
use crate::router::RoutingResult;
use skalp_lir::gate_netlist::GateNetlist;
use std::collections::HashMap;

/// DFF configuration bits for an LC
/// In iCE40, each LC has 20 configuration bits: 16 for LUT init, 4 for DFF config
#[derive(Debug, Clone, Copy, Default)]
struct DffConfig {
    /// Bit 16: Use negative edge of clock
    neg_clk: bool,
    /// Bit 17: Use carry chain enable
    carry_enable: bool,
    /// Bit 18: Use DFF output (vs combinational)
    dff_enable: bool,
    /// Bit 19: Async set/reset mode
    set_no_reset: bool,
}

/// I/O cell configuration for iCE40
/// Each I/O tile has 2 IOBs (IOB_0 and IOB_1) with 6-bit PINTYPE configuration
#[derive(Debug, Clone, Copy, Default)]
struct IoConfig {
    /// PINTYPE[1:0]: Input mode (0=pin, 1=registered, 2=DDR, 3=latched)
    input_mode: u8,
    /// PINTYPE[3:2]: Output select (0=DQ, 1=registered, 2=DDR, 3=latched)
    output_select: u8,
    /// PINTYPE[5:4]: Output mode (0=none, 1=output, 2=tristate, 3=enable)
    output_mode: u8,
    /// Input enable
    input_enable: bool,
    /// Pull-up resistor enable
    pullup_enable: bool,
}

/// Global network configuration
/// Tracks which global networks (0-7) are in use
#[derive(Debug, Clone, Default)]
struct GlobalNetworkConfig {
    /// Bitmask of active global networks (bit N = glb_netwk_N is active)
    active_networks: u8,
}

impl IoConfig {
    /// Create config for simple input
    fn simple_input() -> Self {
        Self {
            input_mode: 0,      // Direct pin input
            output_select: 0,   // Not used
            output_mode: 0,     // No output
            input_enable: true, // Enable input
            pullup_enable: false,
        }
    }

    /// Create config for simple output
    fn simple_output() -> Self {
        Self {
            input_mode: 0,       // Not used
            output_select: 0,    // Direct output
            output_mode: 1,      // Output enabled
            input_enable: false, // No input
            pullup_enable: false,
        }
    }

    /// Create config for bidirectional I/O
    fn bidirectional() -> Self {
        Self {
            input_mode: 0,      // Direct pin input
            output_select: 0,   // Direct output
            output_mode: 2,     // Tristate output
            input_enable: true, // Enable input
            pullup_enable: false,
        }
    }

    /// Get the 6-bit PINTYPE value
    fn pintype(&self) -> u8 {
        (self.output_mode & 0x3) << 4 | (self.output_select & 0x3) << 2 | (self.input_mode & 0x3)
    }
}

/// IceStorm ASCII format generator
pub struct IceStormAscii<'a> {
    device: &'a Ice40Device,
    chipdb: Option<ChipDb>,
}

impl<'a> IceStormAscii<'a> {
    /// Create a new ASCII generator
    pub fn new(device: &'a Ice40Device) -> Self {
        // Try to load chipdb for real bit mappings
        let chipdb = ChipDb::load_embedded(device.variant).ok();
        Self { device, chipdb }
    }

    /// Generate ASCII bitstream
    pub fn generate(
        &self,
        placement: &PlacementResult,
        routing: &RoutingResult,
        netlist: Option<&GateNetlist>,
    ) -> Result<String> {
        let mut asc = String::new();
        let (width, height) = self.device.grid_size();

        // Device name for IceStorm (e.g., "1k", "8k")
        let device_name = match self.device.variant {
            Ice40Variant::Hx1k | Ice40Variant::Lp1k => "1k",
            Ice40Variant::Hx4k | Ice40Variant::Lp4k => "5k",
            Ice40Variant::Hx8k | Ice40Variant::Lp8k => "8k",
            Ice40Variant::Up5k => "up5k",
        };

        // Header
        asc.push_str(&format!(".device {}\n", device_name));
        asc.push_str(".comment Generated by SKALP Native Place & Route\n");
        asc.push('\n');

        // Collect LUT init values from placement and netlist
        let lut_inits = self.collect_lut_inits(placement, netlist);

        // Collect DFF configurations from placement and netlist
        let dff_configs = self.collect_dff_configs(placement, netlist);

        // Collect I/O configurations from placement and netlist
        let io_configs = self.collect_io_configs(placement, netlist);

        // Collect global network configuration
        let global_config = self.collect_global_config(placement);

        // Generate tile configurations
        for y in 0..height {
            for x in 0..width {
                if let Some(tile) = self.device.tile_at(x, y) {
                    match tile.tile_type() {
                        TileType::Logic => {
                            self.generate_logic_tile(
                                &mut asc,
                                x,
                                y,
                                placement,
                                routing,
                                &lut_inits,
                                &dff_configs,
                                &global_config,
                            );
                        }
                        TileType::IoTop
                        | TileType::IoBottom
                        | TileType::IoLeft
                        | TileType::IoRight => {
                            self.generate_io_tile(&mut asc, x, y, placement, routing, &io_configs);
                        }
                        TileType::RamTop => {
                            self.generate_ramt_tile(&mut asc, x, y, placement);
                        }
                        TileType::RamBottom => {
                            self.generate_ramb_tile(&mut asc, x, y, placement);
                        }
                        _ => {}
                    }
                }
            }
        }

        Ok(asc)
    }

    /// Collect LUT init values from placement and netlist
    fn collect_lut_inits(
        &self,
        placement: &PlacementResult,
        netlist: Option<&GateNetlist>,
    ) -> HashMap<(u32, u32, usize), u16> {
        let mut lut_inits = HashMap::new();

        for (cell_id, loc) in &placement.placements {
            if matches!(loc.bel_type, BelType::Lut4) {
                // Get LUT init value from netlist cell if available
                let init = if let Some(netlist) = netlist {
                    // Find the cell by ID in the netlist
                    netlist
                        .cells
                        .iter()
                        .find(|c| c.id.0 == cell_id.0)
                        .map(|cell| {
                            // If lut_init is set, use it; otherwise derive from cell type
                            cell.lut_init
                                .map(|init| init as u16)
                                .unwrap_or_else(|| Self::derive_lut_init(&cell.cell_type))
                        })
                        .unwrap_or(0x0000)
                } else {
                    0x0000
                };
                // Convert bel_index to LC index: LUTs are at even indices (0, 2, 4, ...)
                // LC_idx = bel_index / 2
                let lc_idx = loc.bel_index / 2;
                lut_inits.insert((loc.tile_x, loc.tile_y, lc_idx), init);
            }
        }

        lut_inits
    }

    /// Derive LUT4 init value from cell type name
    /// Uses standard truth tables for common logic functions
    fn derive_lut_init(cell_type: &str) -> u16 {
        // LUT4 truth table: 16 bits where bit N corresponds to input pattern N
        // For 4 inputs (I3,I2,I1,I0), N = (I3<<3) | (I2<<2) | (I1<<1) | I0
        match cell_type {
            // 1-input functions (use I0)
            "SB_LUT4_NOT" | "INV" => 0x5555, // ~I0

            // 2-input functions (use I0, I1)
            "SB_LUT4_AND2" | "AND2" => 0x8888,   // I0 & I1
            "SB_LUT4_OR2" | "OR2" => 0xEEEE,     // I0 | I1
            "SB_LUT4_XOR2" | "XOR2" => 0x6666,   // I0 ^ I1
            "SB_LUT4_NAND2" | "NAND2" => 0x7777, // ~(I0 & I1)
            "SB_LUT4_NOR2" | "NOR2" => 0x1111,   // ~(I0 | I1)
            "SB_LUT4_XNOR2" | "XNOR2" => 0x9999, // ~(I0 ^ I1)

            // 3-input functions
            "SB_LUT4_AND3" | "AND3" => 0x8080, // I0 & I1 & I2
            "SB_LUT4_OR3" | "OR3" => 0xFEFE,   // I0 | I1 | I2
            "SB_LUT4_XOR3" | "XOR3" => 0x6996, // I0 ^ I1 ^ I2

            // 4-input functions
            "SB_LUT4_AND4" | "AND4" => 0x8000, // I0 & I1 & I2 & I3
            "SB_LUT4_OR4" | "OR4" => 0xFFFE,   // I0 | I1 | I2 | I3
            "SB_LUT4_XOR4" | "XOR4" => 0x6996, // I0 ^ I1 ^ I2 ^ I3

            // MUX functions
            "SB_LUT4_MUX2" | "MUX2" => 0xCACA, // I2 ? I1 : I0

            // Buffer/passthrough
            "SB_LUT4_BUF" | "BUF" => 0xAAAA, // I0 (passthrough)

            // Constant outputs
            "TIE_HIGH" | "VCC" => 0xFFFF,
            "TIE_LOW" | "GND" => 0x0000,

            // Default: passthrough I0 (acts as buffer)
            _ => 0xAAAA,
        }
    }

    /// Collect DFF configurations from placement and netlist
    fn collect_dff_configs(
        &self,
        placement: &PlacementResult,
        netlist: Option<&GateNetlist>,
    ) -> HashMap<(u32, u32, usize), DffConfig> {
        let mut dff_configs = HashMap::new();

        for (cell_id, loc) in &placement.placements {
            // Check if this is a DFF cell type
            let is_dff = matches!(
                loc.bel_type,
                BelType::Dff | BelType::DffE | BelType::DffSr | BelType::DffSrE
            );

            if is_dff {
                // Get cell type from netlist to determine specific DFF configuration
                let config = if let Some(netlist) = netlist {
                    netlist
                        .cells
                        .iter()
                        .find(|c| c.id.0 == cell_id.0)
                        .map(|cell| Self::derive_dff_config(&cell.cell_type))
                        .unwrap_or_else(|| DffConfig {
                            dff_enable: true,
                            ..Default::default()
                        })
                } else {
                    DffConfig {
                        dff_enable: true,
                        ..Default::default()
                    }
                };
                // Convert bel_index to LC index: DFFs are at odd indices (1, 3, 5, ...)
                // LC_idx = bel_index / 2
                let lc_idx = loc.bel_index / 2;
                dff_configs.insert((loc.tile_x, loc.tile_y, lc_idx), config);
            }

            // Also check for carry cells (they set carry_enable bit)
            if matches!(loc.bel_type, BelType::Carry) {
                // Carry cells set the carry_enable bit on their associated LC
                // In iCE40, carry chain spans LC 0-7, and multiple carry cells form a chain
                // We enable carry_enable on all LCs that might be part of the chain
                // The bel_index for carry is typically 16 (after LUT/DFF pairs)
                // We need to track which tile has carry cells and enable carry on all relevant LCs
                let tile_key = (loc.tile_x, loc.tile_y);
                for lc_idx in 0..8 {
                    let entry = dff_configs
                        .entry((tile_key.0, tile_key.1, lc_idx))
                        .or_insert(DffConfig::default());
                    entry.carry_enable = true;
                }
            }
        }

        dff_configs
    }

    /// Derive DFF configuration from cell type name
    /// Maps iCE40 DFF cell types to their configuration bits
    fn derive_dff_config(cell_type: &str) -> DffConfig {
        // DFF configuration bits:
        // - neg_clk: Use falling edge of clock (SB_DFFN* variants)
        // - carry_enable: Use carry chain (SB_CARRY)
        // - dff_enable: Use DFF output instead of LUT output
        // - set_no_reset: Async set/reset mode (SB_DFFSR*, SB_DFFSS* have async set)

        let neg_clk = cell_type.contains("DFFN")
            || cell_type.contains("_N")
            || cell_type.ends_with("N")
            || cell_type.contains("SB_DFFN");

        let set_no_reset = cell_type.contains("DFFSR")
            || cell_type.contains("DFFSS")
            || cell_type.contains("_SR")
            || cell_type.contains("_SS");

        DffConfig {
            neg_clk,
            carry_enable: false, // Set separately for carry cells
            dff_enable: true,    // Always true for DFF cells
            set_no_reset,
        }
    }

    /// Collect I/O configurations from placement and netlist
    fn collect_io_configs(
        &self,
        placement: &PlacementResult,
        netlist: Option<&GateNetlist>,
    ) -> HashMap<(u32, u32, usize), IoConfig> {
        let mut io_configs = HashMap::new();

        for (cell_id, loc) in &placement.placements {
            if matches!(loc.bel_type, BelType::IoCell) {
                // Get cell type from netlist to determine I/O direction
                let config = if let Some(netlist) = netlist {
                    netlist
                        .cells
                        .iter()
                        .find(|c| c.id.0 == cell_id.0)
                        .map(|cell| Self::derive_io_config(&cell.cell_type))
                        .unwrap_or_default()
                } else {
                    IoConfig::default()
                };

                // I/O tiles have 2 IOBs (IOB_0 at bel_idx 0, IOB_1 at bel_idx 1)
                let iob_idx = loc.bel_index % 2;
                io_configs.insert((loc.tile_x, loc.tile_y, iob_idx), config);
            }
        }

        io_configs
    }

    /// Derive I/O configuration from cell type
    fn derive_io_config(cell_type: &str) -> IoConfig {
        // SB_IO has a parameter that specifies the pin type
        // For now, derive from cell type naming convention
        if cell_type.contains("_INPUT") || cell_type.ends_with("_I") {
            IoConfig::simple_input()
        } else if cell_type.contains("_OUTPUT") || cell_type.ends_with("_O") {
            IoConfig::simple_output()
        } else if cell_type.contains("_INOUT") || cell_type.contains("_IO") {
            IoConfig::bidirectional()
        } else if cell_type == "SB_IO" {
            // Default SB_IO without direction hint - treat as bidirectional
            IoConfig::bidirectional()
        } else {
            // Default: simple input
            IoConfig::simple_input()
        }
    }

    /// Collect global network configuration from placement
    /// Determines which global networks (0-7) are in use based on SB_GB placements
    fn collect_global_config(&self, placement: &PlacementResult) -> GlobalNetworkConfig {
        let mut config = GlobalNetworkConfig::default();

        // Check for global buffer cells
        for (_cell_id, loc) in &placement.placements {
            if matches!(loc.bel_type, BelType::GlobalBuf) {
                // Map global buffer placement to global network index
                // In iCE40, the global network index is typically related to the gbufin location
                // For simplicity, enable all global networks when any global buffer is used
                config.active_networks = 0xFF; // Enable all 8 global networks
                break;
            }
        }

        // Also check for DFF cells which need clock distribution
        // DFFs require global networks to be active for clock signals
        let has_dffs = placement.placements.values().any(|loc| {
            matches!(
                loc.bel_type,
                BelType::Dff | BelType::DffE | BelType::DffSr | BelType::DffSrE
            )
        });

        if has_dffs {
            // Enable global network 0 (typically used for primary clock)
            config.active_networks |= 0x01;
        }

        config
    }

    /// Generate logic tile configuration
    /// Logic tiles have 54 columns x 16 rows of config bits
    fn generate_logic_tile(
        &self,
        asc: &mut String,
        x: u32,
        y: u32,
        placement: &PlacementResult,
        routing: &RoutingResult,
        lut_inits: &HashMap<(u32, u32, usize), u16>,
        dff_configs: &HashMap<(u32, u32, usize), DffConfig>,
        global_config: &GlobalNetworkConfig,
    ) {
        // Check if any cells are placed in this tile
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| loc.tile_x == x && loc.tile_y == y)
            .collect();

        // Collect PIPs in this tile from routing
        let pips_in_tile: Vec<_> = routing
            .routes
            .values()
            .flat_map(|route| route.pips.iter())
            .filter(|&&pip_id| {
                self.device
                    .pip(pip_id)
                    .map(|p| p.tile_x == x && p.tile_y == y)
                    .unwrap_or(false)
            })
            .copied()
            .collect();

        if cells_in_tile.is_empty() && pips_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".logic_tile {} {}\n", x, y));

        // Create a 16x54 bit array (16 rows, 54 columns)
        let mut bits = [[false; 54]; 16];

        if let Some(ref chipdb) = self.chipdb {
            // Set LUT init bits based on chipdb mappings
            for lc_mapping in &chipdb.lc_mappings {
                let lc_idx = lc_mapping.lc_idx as usize;
                let init = lut_inits.get(&(x, y, lc_idx)).copied().unwrap_or(0);

                // The first 16 bits of lc_mapping.bit_positions are for the LUT init
                // (the remaining 4 are for other LC configuration)
                for (bit_num, &(row, col)) in lc_mapping.bit_positions.iter().take(16).enumerate() {
                    if row < 16 && col < 54 {
                        let bit_value = (init >> bit_num) & 1 == 1;
                        bits[row as usize][col as usize] = bit_value;
                    }
                }

                // Set DFF configuration bits (bits 16-19)
                // Bit 16: NegClk, Bit 17: CarryEnable, Bit 18: DffEnable, Bit 19: Set_NoReset
                if let Some(dff_config) = dff_configs.get(&(x, y, lc_idx)) {
                    let dff_bits = [
                        dff_config.neg_clk,      // Bit 16
                        dff_config.carry_enable, // Bit 17
                        dff_config.dff_enable,   // Bit 18
                        dff_config.set_no_reset, // Bit 19
                    ];

                    // Apply DFF config bits using positions 16-19 from the mapping
                    for (bit_offset, &bit_value) in dff_bits.iter().enumerate() {
                        let bit_idx = 16 + bit_offset;
                        if bit_idx < lc_mapping.bit_positions.len() {
                            let (row, col) = lc_mapping.bit_positions[bit_idx];
                            if row < 16 && col < 54 {
                                bits[row as usize][col as usize] = bit_value;
                            }
                        }
                    }
                }
            }

            // Set routing configuration bits for PIPs
            for pip_id in &pips_in_tile {
                // PipId index corresponds directly to chipdb.pips index
                if let Some(pip_info) = chipdb.pips.get(pip_id.0 as usize) {
                    // Only set bits for PIPs in this tile
                    if pip_info.tile_x == x && pip_info.tile_y == y {
                        for config_bit in &pip_info.config_bits {
                            let row = config_bit.row as usize;
                            let col = config_bit.col as usize;
                            if row < 16 && col < 54 {
                                // If inverted, we want bit=0 to enable, otherwise bit=1
                                bits[row][col] = !config_bit.inverted;
                            }
                        }
                    }
                }
            }

            // Set column buffer control bits for global networks
            // Logic tile ColBufCtrl bit positions (from chipdb):
            //   glb_netwk_0: B0[1], glb_netwk_1: B1[2], glb_netwk_2: B5[2]
            //   glb_netwk_3: B7[2], glb_netwk_4: B9[2], glb_netwk_5: B11[2]
            //   glb_netwk_6: B13[2], glb_netwk_7: B15[2]
            let colbuf_positions: [(usize, usize, u8); 8] = [
                (0, 1, 0),   // glb_netwk_0 at B0[1]
                (1, 2, 1),   // glb_netwk_1 at B1[2]
                (5, 2, 2),   // glb_netwk_2 at B5[2]
                (7, 2, 3),   // glb_netwk_3 at B7[2]
                (9, 2, 4),   // glb_netwk_4 at B9[2]
                (11, 2, 5),  // glb_netwk_5 at B11[2]
                (13, 2, 6),  // glb_netwk_6 at B13[2]
                (15, 2, 7),  // glb_netwk_7 at B15[2]
            ];

            for (row, col, glb_idx) in colbuf_positions {
                if (global_config.active_networks >> glb_idx) & 1 == 1 {
                    bits[row][col] = true;
                }
            }
        }

        // Output the 16 rows of 54 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate I/O tile configuration
    /// I/O tiles have 18 columns x 16 rows of config bits
    fn generate_io_tile(
        &self,
        asc: &mut String,
        x: u32,
        y: u32,
        placement: &PlacementResult,
        routing: &RoutingResult,
        io_configs: &HashMap<(u32, u32, usize), IoConfig>,
    ) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::IoCell)
            })
            .collect();

        // Collect PIPs in this tile from routing
        let pips_in_tile: Vec<_> = routing
            .routes
            .values()
            .flat_map(|route| route.pips.iter())
            .filter(|&&pip_id| {
                self.device
                    .pip(pip_id)
                    .map(|p| p.tile_x == x && p.tile_y == y)
                    .unwrap_or(false)
            })
            .copied()
            .collect();

        if cells_in_tile.is_empty() && pips_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".io_tile {} {}\n", x, y));

        // Create a 16x18 bit array (16 rows, 18 columns)
        let mut bits = [[false; 18]; 16];

        if let Some(ref chipdb) = self.chipdb {
            // Set I/O cell configuration bits
            // IOB_0 PINTYPE bit positions (from chipdb):
            //   PINTYPE_0: B3[17], PINTYPE_1: B3[16], PINTYPE_2: B0[17]
            //   PINTYPE_3: B0[16], PINTYPE_4: B4[16], PINTYPE_5: B4[17]
            // IOB_1 PINTYPE bit positions:
            //   PINTYPE_0: B13[17], PINTYPE_1: B13[16], PINTYPE_2: B10[17]
            //   PINTYPE_3: B10[16], PINTYPE_4: B14[16], PINTYPE_5: B14[17]
            // IoCtrl bits:
            //   IE_0: B9[3], IE_1: B6[3]
            //   REN_0: B6[2], REN_1: B1[3]

            // IOB_0 configuration
            if let Some(config) = io_configs.get(&(x, y, 0)) {
                let pintype = config.pintype();
                // Set PINTYPE bits for IOB_0
                bits[3][17] = (pintype >> 0) & 1 == 1; // PINTYPE_0
                bits[3][16] = (pintype >> 1) & 1 == 1; // PINTYPE_1
                bits[0][17] = (pintype >> 2) & 1 == 1; // PINTYPE_2
                bits[0][16] = (pintype >> 3) & 1 == 1; // PINTYPE_3
                bits[4][16] = (pintype >> 4) & 1 == 1; // PINTYPE_4
                bits[4][17] = (pintype >> 5) & 1 == 1; // PINTYPE_5

                // Set input enable (IE_0)
                bits[9][3] = config.input_enable;

                // Set pull-up resistor enable (REN_0)
                bits[6][2] = config.pullup_enable;
            }

            // IOB_1 configuration
            if let Some(config) = io_configs.get(&(x, y, 1)) {
                let pintype = config.pintype();
                // Set PINTYPE bits for IOB_1
                bits[13][17] = (pintype >> 0) & 1 == 1; // PINTYPE_0
                bits[13][16] = (pintype >> 1) & 1 == 1; // PINTYPE_1
                bits[10][17] = (pintype >> 2) & 1 == 1; // PINTYPE_2
                bits[10][16] = (pintype >> 3) & 1 == 1; // PINTYPE_3
                bits[14][16] = (pintype >> 4) & 1 == 1; // PINTYPE_4
                bits[14][17] = (pintype >> 5) & 1 == 1; // PINTYPE_5

                // Set input enable (IE_1)
                bits[6][3] = config.input_enable;

                // Set pull-up resistor enable (REN_1)
                bits[1][3] = config.pullup_enable;
            }

            // Set routing configuration bits for PIPs
            for pip_id in &pips_in_tile {
                if let Some(pip_info) = chipdb.pips.get(pip_id.0 as usize) {
                    if pip_info.tile_x == x && pip_info.tile_y == y {
                        for config_bit in &pip_info.config_bits {
                            let row = config_bit.row as usize;
                            let col = config_bit.col as usize;
                            if row < 16 && col < 18 {
                                bits[row][col] = !config_bit.inverted;
                            }
                        }
                    }
                }
            }
        }

        // Output the 16 rows of 18 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate RAM bottom tile configuration
    /// RAM tiles have 42 columns x 16 rows of config bits
    fn generate_ramb_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::RamSlice)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".ramb_tile {} {}\n", x, y));

        // Create a 16x42 bit array (16 rows, 42 columns)
        let bits = [[false; 42]; 16];

        // Output the 16 rows of 42 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }

    /// Generate RAM top tile configuration
    fn generate_ramt_tile(&self, asc: &mut String, x: u32, y: u32, placement: &PlacementResult) {
        let cells_in_tile: Vec<_> = placement
            .placements
            .iter()
            .filter(|(_, loc)| {
                loc.tile_x == x && loc.tile_y == y && matches!(loc.bel_type, BelType::RamSlice)
            })
            .collect();

        if cells_in_tile.is_empty() {
            return;
        }

        asc.push_str(&format!(".ramt_tile {} {}\n", x, y));

        // Create a 16x42 bit array (16 rows, 42 columns)
        let bits = [[false; 42]; 16];

        // Output the 16 rows of 42 bits each
        for row in &bits {
            for &bit in row {
                asc.push(if bit { '1' } else { '0' });
            }
            asc.push('\n');
        }

        asc.push('\n');
    }
}
