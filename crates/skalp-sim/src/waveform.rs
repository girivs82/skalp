use std::collections::HashMap;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

use skalp_frontend::hir::{TraceConfig, TraceRadix};

#[derive(Debug, Clone)]
pub struct Signal {
    pub name: String,
    pub width: usize,
    pub values: Vec<(u64, Vec<u8>)>, // (cycle, value)
    /// Trace configuration from #[trace] attribute (if any)
    pub trace_config: Option<TraceConfig>,
}

#[derive(Debug)]
pub struct Waveform {
    pub signals: HashMap<String, Signal>,
    pub max_cycle: u64,
}

impl Default for Waveform {
    fn default() -> Self {
        Self::new()
    }
}

impl Waveform {
    pub fn new() -> Self {
        Waveform {
            signals: HashMap::new(),
            max_cycle: 0,
        }
    }

    pub fn add_signal(&mut self, name: String, width: usize) {
        self.signals.insert(
            name.clone(),
            Signal {
                name,
                width,
                values: Vec::new(),
                trace_config: None,
            },
        );
    }

    /// Add a signal with trace configuration
    pub fn add_traced_signal(&mut self, name: String, width: usize, trace_config: TraceConfig) {
        self.signals.insert(
            name.clone(),
            Signal {
                name,
                width,
                values: Vec::new(),
                trace_config: Some(trace_config),
            },
        );
    }

    pub fn add_value(&mut self, signal_name: &str, cycle: u64, value: Vec<u8>) {
        if let Some(signal) = self.signals.get_mut(signal_name) {
            signal.values.push((cycle, value));
            self.max_cycle = self.max_cycle.max(cycle);
        }
    }

    pub fn from_simulation_states(states: &[crate::simulator::SimulationState]) -> Self {
        let mut waveform = Waveform::new();

        if states.is_empty() {
            return waveform;
        }

        // Initialize signals from first state
        let first_state = &states[0];
        for (name, value) in &first_state.signals {
            waveform.add_signal(name.clone(), value.len() * 8);
        }
        for (name, value) in &first_state.registers {
            waveform.add_signal(format!("reg_{}", name), value.len() * 8);
        }

        // Add values from all states
        for state in states {
            for (name, value) in &state.signals {
                waveform.add_value(name, state.cycle, value.clone());
            }
            for (name, value) in &state.registers {
                waveform.add_value(&format!("reg_{}", name), state.cycle, value.clone());
            }
        }

        waveform
    }

    pub fn export_vcd(&self, path: &Path) -> std::io::Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        // VCD header
        writeln!(writer, "$date")?;
        writeln!(writer, "   Generated by SKALP Simulator")?;
        writeln!(writer, "$end")?;
        writeln!(writer, "$version")?;
        writeln!(writer, "   SKALP 0.1.0")?;
        writeln!(writer, "$end")?;
        writeln!(writer, "$timescale")?;
        writeln!(writer, "   1ps")?;
        writeln!(writer, "$end")?;

        // Variable definitions - organized by trace groups
        let mut identifier = 33u8; // Start with '!'
        let mut signal_map = HashMap::new();

        // Collect signals by group
        let mut groups: HashMap<Option<String>, Vec<(&String, &Signal)>> = HashMap::new();
        for (name, signal) in &self.signals {
            let group = signal.trace_config.as_ref().and_then(|tc| tc.group.clone());
            groups.entry(group).or_default().push((name, signal));
        }

        // Write top-level scope
        writeln!(writer, "$scope module top $end")?;

        // First, write ungrouped signals (those without trace config or no group)
        if let Some(ungrouped) = groups.get(&None) {
            for (name, signal) in ungrouped {
                let id_char = identifier as char;
                let id = id_char.to_string();
                // Use display_name if provided in trace config
                let display_name = signal.trace_config.as_ref()
                    .and_then(|tc| tc.display_name.as_ref())
                    .map(|s| s.as_str())
                    .unwrap_or(name.as_str());
                writeln!(writer, "$var wire {} {} {} $end", signal.width, id, display_name)?;
                signal_map.insert((*name).clone(), id.clone());
                identifier += 1;
                if identifier > 126 {
                    identifier = 33;
                }
            }
        }

        // Write grouped signals in their own scopes
        for (group_name, signals) in groups.iter() {
            if let Some(gn) = group_name {
                writeln!(writer, "$scope module {} $end", gn)?;
                for (name, signal) in signals {
                    let id_char = identifier as char;
                    let id = id_char.to_string();
                    // Use display_name if provided
                    let display_name = signal.trace_config.as_ref()
                        .and_then(|tc| tc.display_name.as_ref())
                        .map(|s| s.as_str())
                        .unwrap_or(name.as_str());
                    writeln!(writer, "$var wire {} {} {} $end", signal.width, id, display_name)?;
                    signal_map.insert((*name).clone(), id.clone());
                    identifier += 1;
                    if identifier > 126 {
                        identifier = 33;
                    }
                }
                writeln!(writer, "$upscope $end")?;
            }
        }

        writeln!(writer, "$upscope $end")?;
        writeln!(writer, "$enddefinitions $end")?;

        // Initial values
        writeln!(writer, "$dumpvars")?;
        for (name, signal) in &self.signals {
            if let Some(id) = signal_map.get(name) {
                if let Some((_, value)) = signal.values.first() {
                    writeln!(writer, "b{} {}", self.format_binary(value), id)?;
                }
            }
        }
        writeln!(writer, "$end")?;

        // Value changes
        let mut all_changes: Vec<(u64, String, Vec<u8>)> = Vec::new();

        for (name, signal) in &self.signals {
            if let Some(id) = signal_map.get(name) {
                for (cycle, value) in &signal.values {
                    all_changes.push((*cycle, id.clone(), value.clone()));
                }
            }
        }

        // Sort by cycle
        all_changes.sort_by_key(|c| c.0);

        let mut current_cycle = 0;
        for (cycle, id, value) in all_changes {
            if cycle != current_cycle {
                writeln!(writer, "#{}", cycle)?;
                current_cycle = cycle;
            }
            writeln!(writer, "b{} {}", self.format_binary(&value), id)?;
        }

        writer.flush()?;
        Ok(())
    }

    /// Export only signals marked with #[trace] attribute to VCD
    pub fn export_traced_vcd(&self, path: &Path) -> std::io::Result<()> {
        // Filter to only traced signals
        let traced_waveform = Waveform {
            signals: self.signals.iter()
                .filter(|(_, sig)| sig.trace_config.is_some())
                .map(|(k, v)| (k.clone(), v.clone()))
                .collect(),
            max_cycle: self.max_cycle,
        };
        traced_waveform.export_vcd(path)
    }

    /// Get list of all traced signal names
    pub fn get_traced_signals(&self) -> Vec<&str> {
        self.signals.iter()
            .filter(|(_, sig)| sig.trace_config.is_some())
            .map(|(name, _)| name.as_str())
            .collect()
    }

    /// Get list of traced signals in a specific group
    pub fn get_traced_signals_in_group(&self, group: &str) -> Vec<&str> {
        self.signals.iter()
            .filter(|(_, sig)| {
                sig.trace_config.as_ref()
                    .and_then(|tc| tc.group.as_ref())
                    .map(|g| g == group)
                    .unwrap_or(false)
            })
            .map(|(name, _)| name.as_str())
            .collect()
    }

    fn format_binary(&self, bytes: &[u8]) -> String {
        let mut result = String::new();
        for byte in bytes.iter().rev() {
            result.push_str(&format!("{:08b}", byte));
        }
        result
    }

    /// Format value according to trace config radix
    #[allow(dead_code)]
    fn format_value_with_radix(&self, bytes: &[u8], radix: TraceRadix) -> String {
        match radix {
            TraceRadix::Binary => self.format_binary(bytes),
            TraceRadix::Hex => {
                let mut result = String::new();
                for byte in bytes.iter().rev() {
                    result.push_str(&format!("{:02x}", byte));
                }
                result
            }
            TraceRadix::Unsigned => {
                // Convert bytes to unsigned integer
                let mut val: u128 = 0;
                for byte in bytes.iter().rev() {
                    val = (val << 8) | (*byte as u128);
                }
                val.to_string()
            }
            TraceRadix::Signed => {
                // Convert bytes to signed integer (two's complement)
                let mut val: i128 = 0;
                for byte in bytes.iter().rev() {
                    val = (val << 8) | (*byte as i128);
                }
                // Sign extend if necessary
                let width = bytes.len() * 8;
                if width < 128 && (val >> (width - 1)) & 1 != 0 {
                    val |= !((1i128 << width) - 1);
                }
                val.to_string()
            }
            TraceRadix::Ascii => {
                bytes.iter()
                    .map(|&b| if b.is_ascii_graphic() { b as char } else { '.' })
                    .collect()
            }
        }
    }

    pub fn get_signal_at_cycle(&self, signal_name: &str, cycle: u64) -> Option<Vec<u8>> {
        if let Some(signal) = self.signals.get(signal_name) {
            // Find the value at or before the requested cycle
            let mut last_value = None;
            for (c, value) in &signal.values {
                if *c <= cycle {
                    last_value = Some(value.clone());
                } else {
                    break;
                }
            }
            last_value
        } else {
            None
        }
    }

    pub fn get_signal_transitions(&self, signal_name: &str) -> Vec<(u64, Vec<u8>)> {
        if let Some(signal) = self.signals.get(signal_name) {
            signal.values.clone()
        } else {
            Vec::new()
        }
    }

    pub fn print_summary(&self) {
        println!("Waveform Summary:");
        println!("-----------------");
        println!("Total signals: {}", self.signals.len());
        println!("Max cycle: {}", self.max_cycle);
        println!("\nSignals:");

        for (name, signal) in &self.signals {
            println!(
                "  {} (width: {} bits, {} transitions)",
                name,
                signal.width,
                signal.values.len()
            );
        }
    }
}
