use indexmap::IndexMap;
use serde::Serialize;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

use skalp_frontend::hir::{TraceConfig, TraceRadix};

#[derive(Debug, Clone)]
pub struct Signal {
    pub name: String,
    pub width: usize,
    pub values: Vec<(u64, Vec<u8>)>, // (cycle, value)
    /// Trace configuration from #[trace] attribute (if any)
    pub trace_config: Option<TraceConfig>,
}

#[derive(Debug)]
pub struct Waveform {
    pub signals: IndexMap<String, Signal>,
    pub max_cycle: u64,
}

impl Default for Waveform {
    fn default() -> Self {
        Self::new()
    }
}

impl Waveform {
    pub fn new() -> Self {
        Waveform {
            signals: IndexMap::new(),
            max_cycle: 0,
        }
    }

    pub fn add_signal(&mut self, name: String, width: usize) {
        self.signals.insert(
            name.clone(),
            Signal {
                name,
                width,
                values: Vec::new(),
                trace_config: None,
            },
        );
    }

    /// Add a signal with trace configuration
    pub fn add_traced_signal(&mut self, name: String, width: usize, trace_config: TraceConfig) {
        self.signals.insert(
            name.clone(),
            Signal {
                name,
                width,
                values: Vec::new(),
                trace_config: Some(trace_config),
            },
        );
    }

    pub fn add_value(&mut self, signal_name: &str, cycle: u64, value: Vec<u8>) {
        if let Some(signal) = self.signals.get_mut(signal_name) {
            signal.values.push((cycle, value));
            self.max_cycle = self.max_cycle.max(cycle);
        }
    }

    pub fn from_simulation_states(states: &[crate::simulator::SimulationState]) -> Self {
        let mut waveform = Waveform::new();

        if states.is_empty() {
            return waveform;
        }

        // Initialize signals from first state
        let first_state = &states[0];
        for (name, value) in &first_state.signals {
            waveform.add_signal(name.clone(), value.len() * 8);
        }
        for (name, value) in &first_state.registers {
            waveform.add_signal(format!("reg_{}", name), value.len() * 8);
        }

        // Add values from all states
        for state in states {
            for (name, value) in &state.signals {
                waveform.add_value(name, state.cycle, value.clone());
            }
            for (name, value) in &state.registers {
                waveform.add_value(&format!("reg_{}", name), state.cycle, value.clone());
            }
        }

        waveform
    }

    pub fn export_vcd(&self, path: &Path) -> std::io::Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        // VCD header
        writeln!(writer, "$date")?;
        writeln!(writer, "   Generated by SKALP Simulator")?;
        writeln!(writer, "$end")?;
        writeln!(writer, "$version")?;
        writeln!(writer, "   SKALP 0.1.0")?;
        writeln!(writer, "$end")?;
        writeln!(writer, "$timescale")?;
        writeln!(writer, "   1ps")?;
        writeln!(writer, "$end")?;

        // Variable definitions - organized by trace groups
        let mut identifier = 33u8; // Start with '!'
        let mut signal_map = IndexMap::new();

        // Collect signals by group
        let mut groups: IndexMap<Option<String>, Vec<(&String, &Signal)>> = IndexMap::new();
        for (name, signal) in &self.signals {
            let group = signal.trace_config.as_ref().and_then(|tc| tc.group.clone());
            groups.entry(group).or_default().push((name, signal));
        }

        // Write top-level scope
        writeln!(writer, "$scope module top $end")?;

        // First, write ungrouped signals (those without trace config or no group)
        if let Some(ungrouped) = groups.get(&None) {
            for (name, signal) in ungrouped {
                let id_char = identifier as char;
                let id = id_char.to_string();
                // Use display_name if provided in trace config
                let display_name = signal
                    .trace_config
                    .as_ref()
                    .and_then(|tc| tc.display_name.as_ref())
                    .map(|s| s.as_str())
                    .unwrap_or(name.as_str());
                writeln!(
                    writer,
                    "$var wire {} {} {} $end",
                    signal.width, id, display_name
                )?;
                signal_map.insert((*name).clone(), id.clone());
                identifier += 1;
                if identifier > 126 {
                    identifier = 33;
                }
            }
        }

        // Write grouped signals in their own scopes
        for (group_name, signals) in groups.iter() {
            if let Some(gn) = group_name {
                writeln!(writer, "$scope module {} $end", gn)?;
                for (name, signal) in signals {
                    let id_char = identifier as char;
                    let id = id_char.to_string();
                    // Use display_name if provided
                    let display_name = signal
                        .trace_config
                        .as_ref()
                        .and_then(|tc| tc.display_name.as_ref())
                        .map(|s| s.as_str())
                        .unwrap_or(name.as_str());
                    writeln!(
                        writer,
                        "$var wire {} {} {} $end",
                        signal.width, id, display_name
                    )?;
                    signal_map.insert((*name).clone(), id.clone());
                    identifier += 1;
                    if identifier > 126 {
                        identifier = 33;
                    }
                }
                writeln!(writer, "$upscope $end")?;
            }
        }

        writeln!(writer, "$upscope $end")?;
        writeln!(writer, "$enddefinitions $end")?;

        // Initial values
        writeln!(writer, "$dumpvars")?;
        for (name, signal) in &self.signals {
            if let Some(id) = signal_map.get(name) {
                if let Some((_, value)) = signal.values.first() {
                    writeln!(writer, "b{} {}", self.format_binary(value), id)?;
                }
            }
        }
        writeln!(writer, "$end")?;

        // Value changes
        let mut all_changes: Vec<(u64, String, Vec<u8>)> = Vec::new();

        for (name, signal) in &self.signals {
            if let Some(id) = signal_map.get(name) {
                for (cycle, value) in &signal.values {
                    all_changes.push((*cycle, id.clone(), value.clone()));
                }
            }
        }

        // Sort by cycle
        all_changes.sort_by_key(|c| c.0);

        let mut current_cycle = 0;
        for (cycle, id, value) in all_changes {
            if cycle != current_cycle {
                writeln!(writer, "#{}", cycle)?;
                current_cycle = cycle;
            }
            writeln!(writer, "b{} {}", self.format_binary(&value), id)?;
        }

        writer.flush()?;
        Ok(())
    }

    /// Export only signals marked with #[trace] attribute to VCD
    pub fn export_traced_vcd(&self, path: &Path) -> std::io::Result<()> {
        // Filter to only traced signals
        let traced_waveform = Waveform {
            signals: self
                .signals
                .iter()
                .filter(|(_, sig)| sig.trace_config.is_some())
                .map(|(k, v)| (k.clone(), v.clone()))
                .collect(),
            max_cycle: self.max_cycle,
        };
        traced_waveform.export_vcd(path)
    }

    /// Get list of all traced signal names
    pub fn get_traced_signals(&self) -> Vec<&str> {
        self.signals
            .iter()
            .filter(|(_, sig)| sig.trace_config.is_some())
            .map(|(name, _)| name.as_str())
            .collect()
    }

    /// Get list of traced signals in a specific group
    pub fn get_traced_signals_in_group(&self, group: &str) -> Vec<&str> {
        self.signals
            .iter()
            .filter(|(_, sig)| {
                sig.trace_config
                    .as_ref()
                    .and_then(|tc| tc.group.as_ref())
                    .map(|g| g == group)
                    .unwrap_or(false)
            })
            .map(|(name, _)| name.as_str())
            .collect()
    }

    fn format_binary(&self, bytes: &[u8]) -> String {
        let mut result = String::new();
        for byte in bytes.iter().rev() {
            result.push_str(&format!("{:08b}", byte));
        }
        result
    }

    /// Format value according to trace config radix
    #[allow(dead_code)]
    fn format_value_with_radix(&self, bytes: &[u8], radix: TraceRadix) -> String {
        match radix {
            TraceRadix::Binary => self.format_binary(bytes),
            TraceRadix::Hex => {
                let mut result = String::new();
                for byte in bytes.iter().rev() {
                    result.push_str(&format!("{:02x}", byte));
                }
                result
            }
            TraceRadix::Unsigned => {
                // Convert bytes to unsigned integer
                let mut val: u128 = 0;
                for byte in bytes.iter().rev() {
                    val = (val << 8) | (*byte as u128);
                }
                val.to_string()
            }
            TraceRadix::Signed => {
                // Convert bytes to signed integer (two's complement)
                let mut val: i128 = 0;
                for byte in bytes.iter().rev() {
                    val = (val << 8) | (*byte as i128);
                }
                // Sign extend if necessary
                let width = bytes.len() * 8;
                if width < 128 && (val >> (width - 1)) & 1 != 0 {
                    val |= !((1i128 << width) - 1);
                }
                val.to_string()
            }
            TraceRadix::Ascii => bytes
                .iter()
                .map(|&b| if b.is_ascii_graphic() { b as char } else { '.' })
                .collect(),
        }
    }

    pub fn get_signal_at_cycle(&self, signal_name: &str, cycle: u64) -> Option<Vec<u8>> {
        if let Some(signal) = self.signals.get(signal_name) {
            // Find the value at or before the requested cycle
            let mut last_value = None;
            for (c, value) in &signal.values {
                if *c <= cycle {
                    last_value = Some(value.clone());
                } else {
                    break;
                }
            }
            last_value
        } else {
            None
        }
    }

    /// Get all signal values at a given waveform time.
    /// Returns display_name â†’ value for every signal that has a value at or before `time`.
    pub fn get_values_at_time(&self, time: u64) -> IndexMap<String, Vec<u8>> {
        let mut result = IndexMap::new();
        for (name, signal) in &self.signals {
            if let Some(value) = self.get_signal_at_cycle(name, time) {
                result.insert(name.clone(), value);
            }
        }
        result
    }

    pub fn get_signal_transitions(&self, signal_name: &str) -> Vec<(u64, Vec<u8>)> {
        if let Some(signal) = self.signals.get(signal_name) {
            signal.values.clone()
        } else {
            Vec::new()
        }
    }

    pub fn print_summary(&self) {
        println!("Waveform Summary:");
        println!("-----------------");
        println!("Total signals: {}", self.signals.len());
        println!("Max cycle: {}", self.max_cycle);
        println!("\nSignals:");

        for (name, signal) in &self.signals {
            println!(
                "  {} (width: {} bits, {} transitions)",
                name,
                signal.width,
                signal.values.len()
            );
        }
    }

    /// Export waveform in SKALP Waveform (.skw) JSON format
    pub fn export_skw(&self, path: &Path, design_name: &str) -> std::io::Result<()> {
        let skw = self.build_skw_data(design_name);
        let file = File::create(path)?;
        let writer = BufWriter::new(file);
        serde_json::to_writer_pretty(writer, &skw)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))
    }

    /// Export waveform in compressed SKALP Waveform (.skw.gz) format
    pub fn export_skw_compressed(&self, path: &Path, design_name: &str) -> std::io::Result<()> {
        let skw = self.build_skw_data(design_name);
        let file = File::create(path)?;
        let encoder = flate2::write::GzEncoder::new(BufWriter::new(file), flate2::Compression::fast());
        serde_json::to_writer(encoder, &skw)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))
    }

    fn build_skw_data(&self, design_name: &str) -> SkwData {
        let mut skw_signals = Vec::new();
        let mut changes = IndexMap::new();
        let mut groups: IndexMap<String, Vec<String>> = IndexMap::new();

        for (name, signal) in &self.signals {
            let sig_type = self.infer_signal_type(signal);
            let group = signal
                .trace_config
                .as_ref()
                .and_then(|tc| tc.group.clone())
                .unwrap_or_default();

            let display = signal.trace_config.as_ref().map(|tc| SkwSignalDisplay {
                radix: match tc.radix {
                    TraceRadix::Binary => "binary".to_string(),
                    TraceRadix::Hex => "hex".to_string(),
                    TraceRadix::Unsigned => "decimal".to_string(),
                    TraceRadix::Signed => "signed".to_string(),
                    TraceRadix::Ascii => "hex".to_string(),
                },
                color: None,
            });

            skw_signals.push(SkwSignal {
                name: name.clone(),
                width: signal.width,
                signal_type: sig_type,
                group: if group.is_empty() {
                    None
                } else {
                    Some(group.clone())
                },
                display,
            });

            if !group.is_empty() {
                groups
                    .entry(group)
                    .or_default()
                    .push(name.clone());
            }

            // Build sparse changes (only record when value actually changes)
            let mut sparse_changes: Vec<(u64, String)> = Vec::new();
            let mut prev_hex = String::new();
            for (cycle, value) in &signal.values {
                let hex = self.format_hex(value);
                if hex != prev_hex {
                    sparse_changes.push((*cycle, hex.clone()));
                    prev_hex = hex;
                }
            }
            changes.insert(name.clone(), sparse_changes);
        }

        let signal_groups: Vec<SkwSignalGroup> = groups
            .into_iter()
            .map(|(name, signals)| SkwSignalGroup { name, signals })
            .collect();

        SkwData {
            version: 1,
            design: design_name.to_string(),
            timescale: "1ns".to_string(),
            end_time: self.max_cycle,
            sim_cycles: self.max_cycle,
            signals: skw_signals,
            changes,
            annotations: Vec::new(),
            display_config: SkwDisplayConfig {
                default_radix: "hex".to_string(),
                signal_groups,
            },
        }
    }

    fn infer_signal_type(&self, signal: &Signal) -> String {
        let name_lower = signal.name.to_lowercase();
        if name_lower.contains("clk") || name_lower.contains("clock") {
            return "clock".to_string();
        }
        if name_lower.contains("rst") || name_lower.contains("reset") {
            return "reset".to_string();
        }
        if signal.width == 1 {
            return "bit".to_string();
        }
        "nat".to_string()
    }

    fn format_hex(&self, bytes: &[u8]) -> String {
        let mut result = String::new();
        for byte in bytes.iter().rev() {
            result.push_str(&format!("{:02x}", byte));
        }
        // Trim leading zeros but keep at least one char
        let trimmed = result.trim_start_matches('0');
        if trimmed.is_empty() {
            "0".to_string()
        } else {
            trimmed.to_string()
        }
    }
}

// --- SKALP Waveform (.skw) JSON Format ---

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SkwData {
    pub version: u32,
    pub design: String,
    pub timescale: String,
    pub end_time: u64,
    pub sim_cycles: u64,
    pub signals: Vec<SkwSignal>,
    pub changes: IndexMap<String, Vec<(u64, String)>>,
    pub annotations: Vec<SkwAnnotation>,
    pub display_config: SkwDisplayConfig,
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SkwSignal {
    pub name: String,
    pub width: usize,
    #[serde(rename = "type")]
    pub signal_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display: Option<SkwSignalDisplay>,
}

#[derive(Debug, Serialize)]
pub struct SkwSignalDisplay {
    pub radix: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct SkwAnnotation {
    pub time: u64,
    pub label: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SkwDisplayConfig {
    pub default_radix: String,
    pub signal_groups: Vec<SkwSignalGroup>,
}

#[derive(Debug, Serialize)]
pub struct SkwSignalGroup {
    pub name: String,
    pub signals: Vec<String>,
}
