use std::collections::HashMap;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

#[derive(Debug, Clone)]
pub struct Signal {
    pub name: String,
    pub width: usize,
    pub values: Vec<(u64, Vec<u8>)>, // (cycle, value)
}

#[derive(Debug)]
pub struct Waveform {
    pub signals: HashMap<String, Signal>,
    pub max_cycle: u64,
}

impl Waveform {
    pub fn new() -> Self {
        Waveform {
            signals: HashMap::new(),
            max_cycle: 0,
        }
    }

    pub fn add_signal(&mut self, name: String, width: usize) {
        self.signals.insert(
            name.clone(),
            Signal {
                name,
                width,
                values: Vec::new(),
            },
        );
    }

    pub fn add_value(&mut self, signal_name: &str, cycle: u64, value: Vec<u8>) {
        if let Some(signal) = self.signals.get_mut(signal_name) {
            signal.values.push((cycle, value));
            self.max_cycle = self.max_cycle.max(cycle);
        }
    }

    pub fn from_simulation_states(states: &[crate::simulator::SimulationState]) -> Self {
        let mut waveform = Waveform::new();

        if states.is_empty() {
            return waveform;
        }

        // Initialize signals from first state
        let first_state = &states[0];
        for (name, value) in &first_state.signals {
            waveform.add_signal(name.clone(), value.len() * 8);
        }
        for (name, value) in &first_state.registers {
            waveform.add_signal(format!("reg_{}", name), value.len() * 8);
        }

        // Add values from all states
        for state in states {
            for (name, value) in &state.signals {
                waveform.add_value(name, state.cycle, value.clone());
            }
            for (name, value) in &state.registers {
                waveform.add_value(&format!("reg_{}", name), state.cycle, value.clone());
            }
        }

        waveform
    }

    pub fn export_vcd(&self, path: &Path) -> std::io::Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        // VCD header
        writeln!(writer, "$date")?;
        writeln!(writer, "   Generated by SKALP Simulator")?;
        writeln!(writer, "$end")?;
        writeln!(writer, "$version")?;
        writeln!(writer, "   SKALP 0.1.0")?;
        writeln!(writer, "$end")?;
        writeln!(writer, "$timescale")?;
        writeln!(writer, "   1ps")?;
        writeln!(writer, "$end")?;

        // Variable definitions
        writeln!(writer, "$scope module top $end")?;

        let mut identifier = 33u8; // Start with '!'
        let mut signal_map = HashMap::new();

        for (name, signal) in &self.signals {
            let id_char = identifier as char;
            let id = id_char.to_string();
            writeln!(writer, "$var wire {} {} {} $end", signal.width, id, name)?;
            signal_map.insert(name.clone(), id.clone());
            identifier += 1;
            if identifier > 126 {
                identifier = 33; // Wrap around if needed
            }
        }

        writeln!(writer, "$upscope $end")?;
        writeln!(writer, "$enddefinitions $end")?;

        // Initial values
        writeln!(writer, "$dumpvars")?;
        for (name, signal) in &self.signals {
            if let Some(id) = signal_map.get(name) {
                if let Some((_, value)) = signal.values.first() {
                    writeln!(writer, "b{} {}", self.format_binary(value), id)?;
                }
            }
        }
        writeln!(writer, "$end")?;

        // Value changes
        let mut all_changes: Vec<(u64, String, Vec<u8>)> = Vec::new();

        for (name, signal) in &self.signals {
            if let Some(id) = signal_map.get(name) {
                for (cycle, value) in &signal.values {
                    all_changes.push((*cycle, id.clone(), value.clone()));
                }
            }
        }

        // Sort by cycle
        all_changes.sort_by_key(|c| c.0);

        let mut current_cycle = 0;
        for (cycle, id, value) in all_changes {
            if cycle != current_cycle {
                writeln!(writer, "#{}", cycle)?;
                current_cycle = cycle;
            }
            writeln!(writer, "b{} {}", self.format_binary(&value), id)?;
        }

        writer.flush()?;
        Ok(())
    }

    fn format_binary(&self, bytes: &[u8]) -> String {
        let mut result = String::new();
        for byte in bytes.iter().rev() {
            result.push_str(&format!("{:08b}", byte));
        }
        result
    }

    pub fn get_signal_at_cycle(&self, signal_name: &str, cycle: u64) -> Option<Vec<u8>> {
        if let Some(signal) = self.signals.get(signal_name) {
            // Find the value at or before the requested cycle
            let mut last_value = None;
            for (c, value) in &signal.values {
                if *c <= cycle {
                    last_value = Some(value.clone());
                } else {
                    break;
                }
            }
            last_value
        } else {
            None
        }
    }

    pub fn get_signal_transitions(&self, signal_name: &str) -> Vec<(u64, Vec<u8>)> {
        if let Some(signal) = self.signals.get(signal_name) {
            signal.values.clone()
        } else {
            Vec::new()
        }
    }

    pub fn print_summary(&self) {
        println!("Waveform Summary:");
        println!("-----------------");
        println!("Total signals: {}", self.signals.len());
        println!("Max cycle: {}", self.max_cycle);
        println!("\nSignals:");

        for (name, signal) in &self.signals {
            println!(
                "  {} (width: {} bits, {} transitions)",
                name,
                signal.width,
                signal.values.len()
            );
        }
    }
}
