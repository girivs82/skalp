//! SystemVerilog code generation from MIR
//!
//! This module generates proper SystemVerilog code from MIR,
//! preserving sequential logic, event blocks, and assignments.

use anyhow::Result;
use skalp_frontend::hir::{
    CdcConfig, CdcType, IsolationClamp, MemoryStyle, PowerConfig, VendorIpConfig, VendorType,
};
use skalp_mir::mir::PriorityMux;
use skalp_mir::mir::{Assertion, AssertionKind};
use skalp_mir::type_width; // Use shared type width calculations
use skalp_mir::{
    Assignment, AssignmentKind, DataType, EdgeType, EnumType, Mir, Module, Process, ProcessKind,
    SignalId, Statement, StructType,
};
use std::cell::RefCell;
use std::collections::{HashMap, HashSet};

// BUG FIX #85: Thread-local storage for tuple source mapping
// This maps signal IDs to their module instance prefix for resolving TupleFieldAccess
thread_local! {
    static TUPLE_SOURCE_MAP: RefCell<HashMap<SignalId, String>> = RefCell::new(HashMap::new());
}

/// BUG FIX #85: Build a mapping of signal IDs to their module instance source
/// This is used to correctly resolve TupleFieldAccess expressions when the base
/// signal is assigned from a module instance result (e.g., `_tuple_tmp_76 = inst_result_0`)
/// BUG FIX #92: Also handles Concat expressions containing module instance result signals
fn build_tuple_source_mapping(module: &Module) -> HashMap<SignalId, String> {
    let mut mapping = HashMap::new();

    for assign in &module.assignments {
        // Check if LHS is a signal
        if let skalp_mir::LValue::Signal(lhs_id) = &assign.lhs {
            // Case 1: RHS is a reference to another signal
            if let skalp_mir::ExpressionKind::Ref(skalp_mir::LValue::Signal(rhs_id)) =
                &assign.rhs.kind
            {
                // Check if RHS signal name contains "_inst_" and "_result_"
                // This indicates it's a module instance result signal
                if let Some(rhs_signal) = module.signals.iter().find(|s| s.id == *rhs_id) {
                    if rhs_signal.name.contains("_inst_") && rhs_signal.name.contains("_result_") {
                        // Extract the prefix (everything before "_result_N")
                        if let Some(pos) = rhs_signal.name.rfind("_result_") {
                            let prefix = &rhs_signal.name[..pos];
                            mapping.insert(*lhs_id, prefix.to_string());
                        }
                    }
                }
            }
            // BUG FIX #92: Case 2: RHS is a Concat of result signals
            // This happens when a tuple-returning function is called and the result is
            // assigned to a temporary signal as a Concat of all result signals
            else if let skalp_mir::ExpressionKind::Concat(elements) = &assign.rhs.kind {
                // Look for any signal reference in the Concat that looks like a module result
                for elem in elements {
                    if let skalp_mir::ExpressionKind::Ref(skalp_mir::LValue::Signal(elem_id)) =
                        &elem.kind
                    {
                        if let Some(elem_signal) = module.signals.iter().find(|s| s.id == *elem_id)
                        {
                            if elem_signal.name.contains("_inst_")
                                && elem_signal.name.contains("_result_")
                            {
                                // Extract the prefix (everything before "_result_N")
                                if let Some(pos) = elem_signal.name.rfind("_result_") {
                                    let prefix = &elem_signal.name[..pos];
                                    mapping.insert(*lhs_id, prefix.to_string());
                                    break; // Found a matching signal, no need to check others
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    mapping
}

/// Generate timing constraints TOML from MIR
///
/// Returns None if no constraints are defined, otherwise returns TOML content.
pub fn generate_constraints_toml(mir: &Mir) -> Option<String> {
    let mut has_constraints = false;
    let mut toml = String::new();

    toml.push_str("# Timing constraints generated by SKALP compiler\n");
    toml.push_str("# Convert to XDC/SDC using vendor-specific scripts\n\n");

    for module in &mir.modules {
        if let Some(ref vendor_config) = module.vendor_ip_config {
            // Clock definitions
            if !vendor_config.clocks.is_empty() {
                has_constraints = true;
                for (port, freq) in &vendor_config.clocks {
                    toml.push_str(&format!("[clocks.{}]\n", port));
                    toml.push_str(&format!("port = \"{}\"\n", port));
                    toml.push_str(&format!("frequency_mhz = {}\n\n", freq));
                }
            }

            // Async clock groups
            if !vendor_config.async_groups.is_empty() {
                has_constraints = true;
                for (clk1, clk2) in &vendor_config.async_groups {
                    toml.push_str("[[async_groups]]\n");
                    toml.push_str(&format!("clocks = [\"{}\", \"{}\"]\n\n", clk1, clk2));
                }
            }

            // Input delays
            if !vendor_config.input_delays.is_empty() {
                has_constraints = true;
                for (port, delay, clock) in &vendor_config.input_delays {
                    toml.push_str("[[input_delays]]\n");
                    toml.push_str(&format!("port = \"{}\"\n", port));
                    toml.push_str(&format!("delay_ns = {}\n", delay));
                    toml.push_str(&format!("clock = \"{}\"\n\n", clock));
                }
            }

            // Output delays
            if !vendor_config.output_delays.is_empty() {
                has_constraints = true;
                for (port, delay, clock) in &vendor_config.output_delays {
                    toml.push_str("[[output_delays]]\n");
                    toml.push_str(&format!("port = \"{}\"\n", port));
                    toml.push_str(&format!("delay_ns = {}\n", delay));
                    toml.push_str(&format!("clock = \"{}\"\n\n", clock));
                }
            }
        }
    }

    if has_constraints {
        Some(toml)
    } else {
        None
    }
}

/// Generate SystemVerilog from MIR
///
/// This function is the primary entry point for SystemVerilog generation.
pub fn generate_systemverilog_from_mir(mir: &Mir) -> Result<String> {
    let mut sv = String::new();

    // Add header comment
    sv.push_str("// Generated by SKALP compiler\n");
    sv.push_str(&format!("// Design: {}\n", mir.name));
    sv.push('\n');

    // Generate each module, skipping ONLY generic templates that have concrete instantiations
    // Strategy:
    // 1. Modules with generic/expression-based types (unresolved) are always skipped (not valid SystemVerilog)
    // 2. Modules with parameters but concrete types can be emitted as parameterized SystemVerilog modules
    // 3. Concrete modules (no parameters, all types resolved) are always emitted
    for mir_module in mir.modules.iter() {
        // Skip modules with unresolved/generic types - these cannot be converted to SystemVerilog
        if has_generic_types(mir_module) {
            continue;
        }

        // Emit all modules with concrete types (even if they have parameters)
        // SystemVerilog supports parameterized modules
        sv.push_str(&generate_module(mir_module, mir)?);
    }

    Ok(sv)
}

/// Check if a module has any generic/expression-based types in its ports
/// Generic types include NatExpr, BitExpr, IntExpr, LogicExpr which contain unresolved expressions
fn has_generic_types(module: &Module) -> bool {
    module
        .ports
        .iter()
        .any(|port| is_generic_type(&port.port_type))
}

/// Check if a data type is generic (contains unresolved expressions)
fn is_generic_type(data_type: &DataType) -> bool {
    match data_type {
        // Expression-based types are generic
        DataType::NatExpr { .. }
        | DataType::BitExpr { .. }
        | DataType::IntExpr { .. }
        | DataType::LogicExpr { .. } => true,
        // Parameter-based types are also generic
        DataType::NatParam { .. }
        | DataType::BitParam { .. }
        | DataType::IntParam { .. }
        | DataType::LogicParam { .. } => true,
        // Recursively check composite types
        DataType::Array(element_type, _) => is_generic_type(element_type),
        DataType::Struct(struct_type) => struct_type
            .fields
            .iter()
            .any(|field| is_generic_type(&field.field_type)),
        DataType::Union(union_type) => union_type
            .fields
            .iter()
            .any(|field| is_generic_type(&field.field_type)),
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => is_generic_type(element_type),
        // All other types are concrete
        _ => false,
    }
}

/// BUG FIX #8: Compute the actual width of an expression
/// This is needed because variables are declared with their type width (e.g., fp32 = 32 bits)
/// but may be assigned expressions with different widths (e.g., {a, b, c} = 96 bits)
fn compute_expression_width(expr: &skalp_mir::Expression, mir_module: &Module) -> Option<usize> {
    match &expr.kind {
        skalp_mir::ExpressionKind::Literal(value) => match value {
            skalp_mir::Value::Integer(_) => Some(32),
            skalp_mir::Value::Float(_) => Some(32), // Single-precision float
            skalp_mir::Value::BitVector { width, .. } => Some(*width),
            _ => None,
        },
        skalp_mir::ExpressionKind::Ref(lvalue) => {
            // Get the width of the referenced LValue
            compute_lvalue_width(lvalue, mir_module)
        }
        skalp_mir::ExpressionKind::Concat(exprs) => {
            // Sum the widths of all concatenated expressions
            let mut total_width = 0;
            for e in exprs {
                if let Some(w) = compute_expression_width(e, mir_module) {
                    total_width += w;
                } else {
                    return None; // Can't determine width
                }
            }
            Some(total_width)
        }
        skalp_mir::ExpressionKind::Binary { left, right, .. } => {
            // For binary ops, use the wider of the two operands
            let left_width = compute_expression_width(left, mir_module)?;
            let right_width = compute_expression_width(right, mir_module)?;
            Some(left_width.max(right_width))
        }
        skalp_mir::ExpressionKind::Conditional {
            then_expr,
            else_expr,
            ..
        } => {
            // Use the wider of the two branches
            let then_width = compute_expression_width(then_expr, mir_module)?;
            let else_width = compute_expression_width(else_expr, mir_module)?;
            Some(then_width.max(else_width))
        }
        skalp_mir::ExpressionKind::Cast { target_type, .. } => {
            // Cast specifies the target type width
            Some(safe_get_type_width(target_type))
        }
        _ => None, // For other expressions, can't determine width statically
    }
}

/// Helper to compute type width, handling struct types specially
fn safe_get_type_width(data_type: &DataType) -> usize {
    match data_type {
        DataType::Struct(struct_type) => type_width::get_struct_total_width(struct_type),
        _ => type_width::get_type_width(data_type),
    }
}

/// Compute the width of an LValue
fn compute_lvalue_width(lvalue: &skalp_mir::LValue, mir_module: &Module) -> Option<usize> {
    match lvalue {
        skalp_mir::LValue::Variable(var_id) => {
            // Find the variable and return its type width
            mir_module
                .variables
                .iter()
                .find(|v| v.id == *var_id)
                .map(|v| safe_get_type_width(&v.var_type))
        }
        skalp_mir::LValue::Signal(sig_id) => {
            // Find the signal and return its type width
            mir_module
                .signals
                .iter()
                .find(|s| s.id == *sig_id)
                .map(|s| safe_get_type_width(&s.signal_type))
        }
        skalp_mir::LValue::Port(port_id) => {
            // Find the port and return its type width
            mir_module
                .ports
                .iter()
                .find(|p| p.id == *port_id)
                .map(|p| safe_get_type_width(&p.port_type))
        }
        skalp_mir::LValue::BitSelect { .. } => Some(1), // Single bit
        skalp_mir::LValue::RangeSelect { high, low, .. } => {
            // For constant range selects, try to compute the width
            // Otherwise return None for dynamic ranges
            if let (
                skalp_mir::ExpressionKind::Literal(skalp_mir::Value::Integer(h)),
                skalp_mir::ExpressionKind::Literal(skalp_mir::Value::Integer(l)),
            ) = (&high.kind, &low.kind)
            {
                Some((h - l + 1) as usize)
            } else {
                None // Dynamic range, can't determine statically
            }
        }
        _ => None,
    }
}

/// BUG FIX #8: Build a map of variable IDs to their actual widths by analyzing assignments
/// Variables may be declared with a type width (e.g., fp32 = 32 bits) but assigned expressions
/// with different widths (e.g., concatenation of 3 fp32 values = 96 bits)
fn infer_variable_widths(mir_module: &Module) -> HashMap<skalp_mir::VariableId, usize> {
    let mut width_map = HashMap::new();

    // Scan continuous assignments
    for assign in &mir_module.assignments {
        if let skalp_mir::LValue::Variable(var_id) = &assign.lhs {
            // Compute the width of the RHS expression
            if let Some(width) = compute_expression_width(&assign.rhs, mir_module) {
                // Get the variable's declared type width
                if let Some(var) = mir_module.variables.iter().find(|v| v.id == *var_id) {
                    let type_w = safe_get_type_width(&var.var_type);
                    // If the expression width differs from type width, record the actual width
                    if width != type_w {
                        width_map.insert(*var_id, width);
                    }
                }
            }
        }
    }

    // Scan process assignments
    for process in &mir_module.processes {
        scan_statements_for_variable_widths(&process.body.statements, mir_module, &mut width_map);
    }

    width_map
}

/// Recursively scan statements to find variable assignments and infer widths
fn scan_statements_for_variable_widths(
    statements: &[Statement],
    mir_module: &Module,
    width_map: &mut HashMap<skalp_mir::VariableId, usize>,
) {
    for stmt in statements {
        match stmt {
            Statement::Assignment(assign) => {
                if let skalp_mir::LValue::Variable(var_id) = &assign.lhs {
                    if let Some(width) = compute_expression_width(&assign.rhs, mir_module) {
                        if let Some(var) = mir_module.variables.iter().find(|v| v.id == *var_id) {
                            let type_w = safe_get_type_width(&var.var_type);
                            if width != type_w {
                                width_map.insert(*var_id, width);
                            }
                        }
                    }
                }
            }
            Statement::If(if_stmt) => {
                scan_statements_for_variable_widths(
                    &if_stmt.then_block.statements,
                    mir_module,
                    width_map,
                );
                if let Some(else_blk) = &if_stmt.else_block {
                    scan_statements_for_variable_widths(
                        &else_blk.statements,
                        mir_module,
                        width_map,
                    );
                }
            }
            Statement::Case(case_stmt) => {
                for item in &case_stmt.items {
                    scan_statements_for_variable_widths(
                        &item.block.statements,
                        mir_module,
                        width_map,
                    );
                }
                if let Some(def_blk) = &case_stmt.default {
                    scan_statements_for_variable_widths(&def_blk.statements, mir_module, width_map);
                }
            }
            _ => {}
        }
    }
}

/// Generate a single SystemVerilog module
fn generate_module(mir_module: &Module, mir: &Mir) -> Result<String> {
    // Check if this is a vendor IP wrapper - generate special output
    if let Some(ref vendor_config) = mir_module.vendor_ip_config {
        return generate_vendor_ip_wrapper(mir_module, vendor_config);
    }

    let mut sv = String::new();

    // BUG FIX #8: Infer actual variable widths from their assignments
    // Variables may be typed as fp32 (32 bits) but assigned concatenations (96+ bits)
    let variable_width_overrides = infer_variable_widths(mir_module);

    // BUG FIX #85: Build and set tuple source mapping for TupleFieldAccess resolution
    let tuple_mapping = build_tuple_source_mapping(mir_module);
    TUPLE_SOURCE_MAP.with(|map| {
        *map.borrow_mut() = tuple_mapping;
    });

    // Collect all unique struct and enum types from ports and signals
    let mut struct_types: HashSet<String> = HashSet::new();
    let mut enum_types: HashSet<String> = HashSet::new();

    collect_types_from_module(mir_module, &mut struct_types, &mut enum_types);

    // Generate typedefs for structs and enums
    sv.push_str(&generate_typedefs(mir_module, &struct_types, &enum_types));

    // Module header with parameters
    sv.push_str(&format!("module {} ", mir_module.name));

    // Generate parameter list if any
    if !mir_module.parameters.is_empty() {
        sv.push_str("#(\n");
        let mut params = Vec::new();
        for param in &mir_module.parameters {
            let param_str = match &param.param_type {
                skalp_mir::GenericParameterType::Type => {
                    // Type parameters become Verilog parameters
                    if let Some(default) = &param.default {
                        format!("    parameter {} = {}", param.name, format_value(default))
                    } else {
                        format!("    parameter {} = 8", param.name) // Default to 8 if no default given
                    }
                }
                skalp_mir::GenericParameterType::Const(_) => {
                    // Const parameters become localparam
                    if let Some(default) = &param.default {
                        format!("    parameter {} = {}", param.name, format_value(default))
                    } else {
                        format!("    parameter {}", param.name)
                    }
                }
                skalp_mir::GenericParameterType::Width => {
                    // Width parameters are regular parameters
                    if let Some(default) = &param.default {
                        format!("    parameter {} = {}", param.name, format_value(default))
                    } else {
                        format!("    parameter {} = 32", param.name)
                    }
                }
                skalp_mir::GenericParameterType::ClockDomain => {
                    // Clock domain parameters are not emitted as Verilog parameters
                    continue;
                }
                skalp_mir::GenericParameterType::PowerDomain => {
                    // Power domain parameters are not emitted as Verilog parameters
                    // They are used for safety analysis and power domain crossing checks
                    continue;
                }
                skalp_mir::GenericParameterType::Intent => {
                    // Intent parameters are not emitted as Verilog parameters
                    // They are used for HLS optimization and synthesis directives
                    continue;
                }
            };
            params.push(param_str);
        }
        sv.push_str(&params.join(",\n"));
        sv.push_str("\n) ");
    }

    sv.push_str("(\n");

    // Generate port list (MIR already has flattened ports)
    let mut ports = Vec::new();
    for port in &mir_module.ports {
        let direction = match port.direction {
            skalp_mir::PortDirection::Input => "input",
            skalp_mir::PortDirection::Output => "output",
            skalp_mir::PortDirection::InOut => "inout",
        };

        let (element_width, array_dim) = get_type_dimensions(&port.port_type);
        ports.push(format!(
            "    {} {}{}{}",
            direction, element_width, port.name, array_dim
        ));
    }

    if !ports.is_empty() {
        sv.push_str(&ports.join(",\n"));
        sv.push('\n');
    }

    sv.push_str(");\n\n");

    // Generate internal signal declarations (MIR already has flattened signals)
    for signal in &mir_module.signals {
        // Check if this is a memory signal with memory_config
        if let Some(mem_config) = &signal.memory_config {
            // Generate memory-inferrable SystemVerilog with synthesis attributes
            // Format: (* ram_style = "block" *) reg [WIDTH-1:0] mem [0:DEPTH-1];

            // Determine data width from config or signal type
            let data_width = mem_config
                .width
                .unwrap_or_else(|| type_width::get_type_width(&signal.signal_type) as u32);

            // Generate synthesis attribute based on memory style
            let ram_style_attr = match mem_config.style {
                MemoryStyle::Auto => String::new(), // No attribute for auto
                MemoryStyle::Block => "    (* ram_style = \"block\" *)\n".to_string(),
                MemoryStyle::Distributed => "    (* ram_style = \"distributed\" *)\n".to_string(),
                MemoryStyle::Ultra => "    (* ram_style = \"ultra\" *)\n".to_string(),
                MemoryStyle::Register => "    (* ram_style = \"registers\" *)\n".to_string(),
            };

            // Add comment with memory configuration details
            sv.push_str(&format!(
                "    // Memory: depth={}, width={}, ports={}, read_latency={}{}\n",
                mem_config.depth,
                data_width,
                mem_config.ports,
                mem_config.read_latency,
                if mem_config.read_only {
                    ", read_only"
                } else {
                    ""
                }
            ));

            // Add synthesis attribute if applicable
            sv.push_str(&ram_style_attr);

            // Generate memory array declaration
            // Memories are always reg arrays for proper BRAM inference
            let width_str = if data_width > 1 {
                format!("[{}:0] ", data_width - 1)
            } else {
                String::new()
            };

            sv.push_str(&format!(
                "    reg {}{} [0:{}];\n",
                width_str,
                signal.name,
                mem_config.depth - 1
            ));
        } else if let Some(cdc_config) = &signal.cdc_config {
            // CDC signal - generate synchronizer chain
            let (element_width, array_dim) = get_type_dimensions(&signal.signal_type);
            let data_width = type_width::get_type_width(&signal.signal_type);

            // Generate CDC synchronizer based on type
            generate_cdc_synchronizer(
                &mut sv,
                &signal.name,
                &element_width,
                &array_dim,
                data_width,
                cdc_config,
            );
        } else {
            // Standard signal declaration (non-memory)
            let (element_width, array_dim) = get_type_dimensions(&signal.signal_type);

            // Determine if it's a reg or wire based on usage
            let signal_type = if is_register(signal, mir_module) {
                "reg"
            } else {
                "wire"
            };

            // Generate power intent synthesis attributes if present
            if let Some(power_config) = &signal.power_config {
                generate_power_attributes(&mut sv, &signal.name, power_config);
            }

            // Generate power domain annotation if present
            if let Some(ref power_domain) = signal.power_domain {
                sv.push_str(&format!("    (* power_domain = \"{}\" *)\n", power_domain));
            }

            // Format: wire [element_width] name [array_dim];
            sv.push_str(&format!(
                "    {} {}{}{}",
                signal_type, element_width, signal.name, array_dim
            ));

            // Add initial value if present
            if let Some(init) = &signal.initial {
                sv.push_str(&format!(" = {}", format_value(init)));
            }

            sv.push_str(";\n");

            // Generate isolation logic if configured
            if let Some(power_config) = &signal.power_config {
                if let Some(isolation) = &power_config.isolation {
                    generate_isolation_logic(
                        &mut sv,
                        &signal.name,
                        &element_width,
                        &array_dim,
                        isolation,
                    );
                }
            }
        }
    }

    if !mir_module.signals.is_empty() {
        sv.push('\n');
    }

    // Generate internal variable declarations with collision detection
    // Track which names have been declared to detect collisions
    let mut declared_variable_names: HashMap<String, skalp_mir::VariableId> = HashMap::new();
    let mut variable_unique_names: HashMap<skalp_mir::VariableId, String> = HashMap::new();

    for variable in &mir_module.variables {
        // BUG FIX #8: Check if we have an inferred width override for this variable
        // If so, use the actual expression width instead of the type width
        let (element_width, array_dim) =
            if let Some(&inferred_width) = variable_width_overrides.get(&variable.id) {
                // Use the inferred width (e.g., 96 bits for concat of 3x32-bit values)
                let width_str = if inferred_width > 1 {
                    format!("[{}:0] ", inferred_width - 1)
                } else {
                    String::new()
                };
                (width_str, String::new()) // No array dimension for overridden widths
            } else {
                // Use the type-based width
                get_type_dimensions(&variable.var_type)
            };

        // Check if this variable name has already been declared
        let unique_name = if declared_variable_names.contains_key(&variable.name) {
            // Collision detected - use unique name with variable ID suffix
            format!("{}_{}", variable.name, variable.id.0)
        } else {
            // First occurrence - use original name and track it
            declared_variable_names.insert(variable.name.clone(), variable.id);
            variable.name.clone()
        };

        // Store the unique name mapping for use in variable references
        variable_unique_names.insert(variable.id, unique_name.clone());

        // Variables are always logic (combinational variables in processes)
        sv.push_str(&format!(
            "    logic {}{}{}",
            element_width, unique_name, array_dim
        ));

        // Add initial value if present
        if let Some(init) = &variable.initial {
            sv.push_str(&format!(" = {}", format_value(init)));
        }

        sv.push_str(";\n");
    }

    if !mir_module.variables.is_empty() {
        sv.push('\n');
    }

    // Generate continuous assignments - expand struct assignments
    // Track assigned targets to avoid duplicates from match arm let bindings
    let mut assigned_targets: HashSet<String> = HashSet::new();
    let mut assignment_count = 0;

    for assign in &mir_module.assignments {
        let expanded = expand_struct_assignment(&assign.lhs, &assign.rhs, mir_module);
        for (lhs_str, rhs_str) in expanded {
            // Check if this target has already been assigned
            if assigned_targets.contains(&lhs_str) {
                // Skip duplicate assignment (from duplicate let bindings in match arms)
                continue;
            }

            assigned_targets.insert(lhs_str.clone());
            sv.push_str(&format!("    assign {} = {};\n", lhs_str, rhs_str));
            assignment_count += 1;
        }
    }

    if assignment_count > 0 {
        sv.push('\n');
    }

    // Generate module instances
    for instance in &mir_module.instances {
        sv.push_str(&generate_instance(instance, mir_module, mir)?);
        sv.push('\n');
    }

    // Generate processes (always blocks)
    for process in &mir_module.processes {
        sv.push_str(&generate_process(process, mir_module)?);
        sv.push('\n');
    }

    // Generate breakpoint assertions (SVA)
    let breakpoint_signals: Vec<_> = mir_module
        .signals
        .iter()
        .filter(|s| s.breakpoint_config.is_some())
        .collect();
    if !breakpoint_signals.is_empty() {
        sv.push_str("\n    // Debug Breakpoint Assertions\n");
        sv.push_str("    // Synthesized as SVA - use $stop in simulation\n");
        for signal in breakpoint_signals {
            if let Some(bp_config) = &signal.breakpoint_config {
                sv.push_str(&generate_breakpoint_assertion(&signal.name, bp_config));
            }
        }
    }

    // Generate formal verification assertions (SVA)
    if !mir_module.assertions.is_empty() {
        sv.push_str("\n    // Formal Verification Assertions\n");
        for assertion in &mir_module.assertions {
            sv.push_str(&generate_assertion(assertion, mir_module));
        }
    }

    sv.push_str("endmodule\n");
    Ok(sv)
}

/// Generate a module instance
fn generate_instance(
    instance: &skalp_mir::ModuleInstance,
    parent_module: &Module,
    mir: &Mir,
) -> Result<String> {
    let mut sv = String::new();

    // Look up the module being instantiated to get its name and ports
    let instantiated_module = mir
        .modules
        .iter()
        .find(|m| m.id == instance.module)
        .ok_or_else(|| {
            anyhow::anyhow!(
                "Module ID {:?} not found for instance {}",
                instance.module,
                instance.name
            )
        })?;

    // Start with module name
    sv.push_str(&format!("    {} ", instantiated_module.name));

    // Add parameter overrides if any
    if !instance.parameters.is_empty() {
        sv.push_str("#(\n");
        let params: Vec<String> = instance
            .parameters
            .iter()
            .map(|(name, value)| format!("        .{}({})", name, format_value(value)))
            .collect();
        sv.push_str(&params.join(",\n"));
        sv.push_str("\n    ) ");
    }

    // Instance name
    sv.push_str(&format!("{} (\n", instance.name));

    // Port connections - expand struct/vector ports into individual flattened connections
    let mut connections: Vec<String> = Vec::new();

    for (port_name, expr) in &instance.connections {
        // Look up the port in the instantiated module to get its type
        let port = instantiated_module
            .ports
            .iter()
            .find(|p| p.name == *port_name);

        if let Some(port) = port {
            // Port found by exact name - expand based on its type
            let expanded_connections =
                expand_port_connection(port_name, &port.port_type, expr, parent_module);

            // Format each expanded connection
            for (port_field, signal_expr) in expanded_connections {
                connections.push(format!("        .{}({})", port_field, signal_expr));
            }
        } else {
            // Port not found by exact name - check if there are flattened ports with this prefix
            // This handles the case where HIR had "vertex" but MIR flattened it to
            // "vertex_position_x", "vertex_position_y", etc.
            // We need to distinguish between scalar ports like "vertex_valid" and
            // flattened struct fields like "vertex_position_x"
            let prefix = format!("{}_", port_name);
            let flattened_ports: Vec<_> = instantiated_module
                .ports
                .iter()
                .filter(|p| {
                    // Port must start with prefix
                    if !p.name.starts_with(&prefix) {
                        return false;
                    }
                    let suffix = &p.name[port_name.len()..];
                    // Check if this is a flattened struct/vector field
                    // Two patterns indicate flattening:
                    // 1. Nested struct: base_field_subfield (2+ underscores in suffix)
                    // 2. Vector components: base_x, base_y, base_z, base_w (1 underscore + component)
                    let underscore_count = suffix.chars().filter(|&c| c == '_').count();
                    if underscore_count >= 2 {
                        // Nested struct field
                        true
                    } else if underscore_count == 1 {
                        // Check if it's a vector component (_x, _y, _z, _w)
                        suffix.ends_with("_x")
                            || suffix.ends_with("_y")
                            || suffix.ends_with("_z")
                            || suffix.ends_with("_w")
                    } else {
                        false
                    }
                })
                .collect();

            if !flattened_ports.is_empty() {
                // Found flattened ports - we need to infer the structure and expand
                // Get the signal name from the expression
                if let skalp_mir::ExpressionKind::Ref(lvalue) = &expr.kind {
                    let signal_full_name = format_lvalue_with_context(lvalue, parent_module);

                    // The signal might be referencing a flattened field (like geom_vertex_position_x)
                    // We need to extract the base name (like geom_vertex)
                    // Check if the signal name has a suffix matching the first flattened port
                    let first_port_suffix = &flattened_ports[0].name[port_name.len()..];
                    let signal_base_name = if signal_full_name.ends_with(first_port_suffix) {
                        // Strip the suffix to get the base name
                        &signal_full_name[..signal_full_name.len() - first_port_suffix.len()]
                    } else {
                        // Signal doesn't have the expected suffix, use as-is
                        &signal_full_name
                    };

                    // For each flattened port, construct a matching signal name
                    for port in flattened_ports {
                        // Extract the suffix after the port_name prefix
                        let suffix = &port.name[port_name.len()..]; // includes the leading _
                        let signal_name = format!("{}{}", signal_base_name, suffix);
                        connections.push(format!("        .{}({})", port.name, signal_name));
                    }
                } else {
                    // Expression is not a simple reference, can't expand
                    // Use simple connection and hope for the best
                    connections.push(format!(
                        "        .{}({})",
                        port_name,
                        format_expression_with_context(expr, parent_module)
                    ));
                }
            } else {
                // No ports found at all - use simple connection
                connections.push(format!(
                    "        .{}({})",
                    port_name,
                    format_expression_with_context(expr, parent_module)
                ));
            }
        }
    }

    sv.push_str(&connections.join(",\n"));
    sv.push_str("\n    );\n");

    Ok(sv)
}

/// Generate an always block from a process
fn generate_process(process: &Process, module: &Module) -> Result<String> {
    let mut sv = String::new();

    // Generate always block header
    match process.kind {
        ProcessKind::Sequential => {
            sv.push_str("    always_ff @(");
            sv.push_str(&format_sensitivity(&process.sensitivity, module));
            sv.push_str(") begin\n");
        }
        ProcessKind::Combinational => {
            sv.push_str("    always_comb begin\n");
        }
        ProcessKind::General => {
            sv.push_str("    always @(");
            sv.push_str(&format_sensitivity(&process.sensitivity, module));
            sv.push_str(") begin\n");
        }
        ProcessKind::Async => {
            // NCL async process - use always_comb for now
            // Phase 7 will generate proper NCL-specific Verilog
            sv.push_str("    always_comb begin // NCL async\n");
        }
    }

    // Generate body statements
    for statement in &process.body.statements {
        sv.push_str(&generate_statement(statement, module, 2)?);
    }

    sv.push_str("    end\n");
    Ok(sv)
}

/// Generate a statement
fn generate_statement(stmt: &Statement, module: &Module, indent_level: usize) -> Result<String> {
    let indent = "    ".repeat(indent_level);
    let mut sv = String::new();

    match stmt {
        Statement::Assignment(assign) => {
            let op = match assign.kind {
                AssignmentKind::NonBlocking => "<=",
                AssignmentKind::Blocking => "=",
            };
            sv.push_str(&format!(
                "{}{} {} {};\n",
                indent,
                format_lvalue_with_context(&assign.lhs, module),
                op,
                format_expression_with_context(&assign.rhs, module)
            ));
        }
        Statement::If(if_stmt) => {
            sv.push_str(&format!(
                "{}if ({}) begin\n",
                indent,
                format_expression_with_context(&if_stmt.condition, module)
            ));
            for s in &if_stmt.then_block.statements {
                sv.push_str(&generate_statement(s, module, indent_level + 1)?);
            }
            sv.push_str(&format!("{}end", indent));

            if let Some(else_block) = &if_stmt.else_block {
                sv.push_str(" else begin\n");
                for s in &else_block.statements {
                    sv.push_str(&generate_statement(s, module, indent_level + 1)?);
                }
                sv.push_str(&format!("{}end", indent));
            }
            sv.push('\n');
        }
        Statement::Case(case_stmt) => {
            sv.push_str(&format!(
                "{}case ({})\n",
                indent,
                format_expression_with_context(&case_stmt.expr, module)
            ));

            // Generate case items
            for item in &case_stmt.items {
                let values = item
                    .values
                    .iter()
                    .map(|v| format_expression_with_context(v, module))
                    .collect::<Vec<_>>()
                    .join(", ");
                sv.push_str(&format!("    {}{}: begin\n", indent, values));

                for s in &item.block.statements {
                    sv.push_str(&generate_statement(s, module, indent_level + 2)?);
                }
                sv.push_str(&format!("    {}end\n", indent));
            }

            // Generate default case if present
            if let Some(default_block) = &case_stmt.default {
                sv.push_str(&format!("    {}default: begin\n", indent));
                for s in &default_block.statements {
                    sv.push_str(&generate_statement(s, module, indent_level + 2)?);
                }
                sv.push_str(&format!("    {}end\n", indent));
            }

            sv.push_str(&format!("{}endcase\n", indent));
        }
        Statement::Loop(_) => {
            // TODO: Implement loop statement generation
            sv.push_str(&format!("{}// TODO: loop statement\n", indent));
        }
        Statement::Block(block) => {
            sv.push_str(&format!("{}begin\n", indent));
            for s in &block.statements {
                sv.push_str(&generate_statement(s, module, indent_level + 1)?);
            }
            sv.push_str(&format!("{}end\n", indent));
        }
        Statement::ResolvedConditional(resolved) => {
            // Generate as a single ternary assignment - synthesis-resolved form
            let op = match resolved.kind {
                AssignmentKind::NonBlocking => "<=",
                AssignmentKind::Blocking => "=",
            };

            // Build nested ternary expression from priority mux
            let ternary_expr = build_ternary_expression(&resolved.resolved, module);
            sv.push_str(&format!(
                "{}{} {} {};\n",
                indent,
                format_lvalue_with_context(&resolved.target, module),
                op,
                ternary_expr
            ));
        }
        // Verification statements: Assert, Assume, Cover
        // NOTE: The MIR representation is backend-agnostic. Each backend can interpret these
        // statements as appropriate for its target:
        //   - SystemVerilog/Verilog: SVA (SystemVerilog Assertions) - this implementation
        //   - Simulation: Runtime checks with debug output
        //   - GPU/Metal: Shader assertions or debug printf
        //   - Formal tools: Property specifications for model checking
        //   - Synthesis: Ignore or convert to synthesizable checks
        Statement::Assert(assert_stmt) => {
            // SystemVerilog: Generate immediate assertion with severity
            // assert(condition) else $severity("message");
            let condition = format_expression_with_context(&assert_stmt.condition, module);
            let severity_call = match assert_stmt.severity {
                skalp_mir::mir::AssertionSeverity::Info => "$info",
                skalp_mir::mir::AssertionSeverity::Warning => "$warning",
                skalp_mir::mir::AssertionSeverity::Error => "$error",
                skalp_mir::mir::AssertionSeverity::Fatal => "$fatal",
            };
            if let Some(msg) = &assert_stmt.message {
                sv.push_str(&format!(
                    "{}assert({}) else {}(\"{}\");\n",
                    indent, condition, severity_call, msg
                ));
            } else {
                sv.push_str(&format!(
                    "{}assert({}) else {}(\"Assertion failed\");\n",
                    indent, condition, severity_call
                ));
            }
        }
        Statement::Assume(assume_stmt) => {
            // Generate assumption: assume(condition);
            let condition = format_expression_with_context(&assume_stmt.condition, module);
            if let Some(msg) = &assume_stmt.message {
                sv.push_str(&format!("{}assume({}); // {}\n", indent, condition, msg));
            } else {
                sv.push_str(&format!("{}assume({});\n", indent, condition));
            }
        }
        Statement::Cover(cover_stmt) => {
            // Generate cover point: cover(condition);
            let condition = format_expression_with_context(&cover_stmt.condition, module);
            if let Some(lbl) = &cover_stmt.label {
                sv.push_str(&format!("{}{}: cover({});\n", indent, lbl, condition));
            } else {
                sv.push_str(&format!("{}cover({});\n", indent, condition));
            }
        }
    }

    Ok(sv)
}

/// Build nested ternary expression from priority mux
fn build_ternary_expression(mux: &PriorityMux, module: &Module) -> String {
    let mut result = format_expression_with_context(&mux.default, module);

    // Build ternary chain from right to left (lowest to highest priority)
    for case in mux.cases.iter().rev() {
        result = format!(
            "({}) ? ({}) : ({})",
            format_expression_with_context(&case.condition, module),
            format_expression_with_context(&case.value, module),
            result
        );
    }

    result
}

/// Build parallel one-hot mux expression
/// Generates: ({W{sel==v0}} & a) | ({W{sel==v1}} & b) | ...
/// This assumes mutually exclusive conditions for correct operation
fn build_parallel_mux_expression(mux: &skalp_mir::ParallelMux, module: &Module) -> String {
    let width = mux.result_width;
    let selector = format_expression_with_context(&mux.selector, module);

    let mut terms: Vec<String> = Vec::new();

    for case in &mux.cases {
        let match_val = format_expression_with_context(&case.match_value, module);
        let value = format_expression_with_context(&case.value, module);

        // Generate: ({width{selector == match_val}} & value)
        // The replication {width{cond}} creates a width-bit mask of all 1s or all 0s
        terms.push(format!(
            "({{{}'{{({}) == ({})}}}} & ({}))",
            width, selector, match_val, value
        ));
    }

    // Add default case if present
    if let Some(ref default) = mux.default {
        // Default fires when no other case matches
        // Generate: ({width{!(sel==v0 || sel==v1 || ...)}} & default)
        let no_match_cond: Vec<String> = mux
            .cases
            .iter()
            .map(|c| {
                format!(
                    "({}) == ({})",
                    selector,
                    format_expression_with_context(&c.match_value, module)
                )
            })
            .collect();
        let default_val = format_expression_with_context(default, module);
        // Format: ({32{!(cond)}} & (val))
        // Escaping: {{ = {, }} = }, so {{{}'{{...}}}} produces {32'{...}}
        terms.push(format!(
            "({{{}'{{!({})}}}} & ({}))",
            width,
            no_match_cond.join(" || "),
            default_val
        ));
    }

    // OR all terms together
    if terms.is_empty() {
        format!("{}'b0", width)
    } else {
        terms.join(" | ")
    }
}

/// Format sensitivity list
fn format_sensitivity(sensitivity: &skalp_mir::SensitivityList, module: &Module) -> String {
    match sensitivity {
        skalp_mir::SensitivityList::Always => "*".to_string(),
        skalp_mir::SensitivityList::Level(signals) => signals
            .iter()
            .map(|s| format_lvalue_with_context(s, module))
            .collect::<Vec<_>>()
            .join(" or "),
        skalp_mir::SensitivityList::Edge(edges) => edges
            .iter()
            .map(|e| {
                let edge_str = match e.edge {
                    EdgeType::Rising => "posedge",
                    EdgeType::Falling => "negedge",
                    EdgeType::Both => "",
                    EdgeType::Active => {
                        if is_active_high_reset(&e.signal, module) {
                            "posedge"
                        } else {
                            "negedge"
                        }
                    }
                    EdgeType::Inactive => {
                        if is_active_high_reset(&e.signal, module) {
                            "negedge"
                        } else {
                            "posedge"
                        }
                    }
                };
                if edge_str.is_empty() {
                    format_lvalue_with_context(&e.signal, module)
                } else {
                    format!(
                        "{} {}",
                        edge_str,
                        format_lvalue_with_context(&e.signal, module)
                    )
                }
            })
            .collect::<Vec<_>>()
            .join(" or "),
    }
}

/// Check if a reset signal is active-high by looking up its port type in the module.
/// Defaults to active-high if the signal type cannot be determined.
fn is_active_high_reset(signal: &skalp_mir::LValue, module: &Module) -> bool {
    match signal {
        skalp_mir::LValue::Port(port_id) => {
            if let Some(port) = module.ports.iter().find(|p| p.id == *port_id) {
                if let DataType::Reset { active_high, .. } = &port.port_type {
                    return *active_high;
                }
            }
            true // default: active-high
        }
        skalp_mir::LValue::Signal(signal_id) => {
            if let Some(sig) = module.signals.iter().find(|s| s.id == *signal_id) {
                if let DataType::Reset { active_high, .. } = &sig.signal_type {
                    return *active_high;
                }
            }
            true // default: active-high
        }
        _ => true, // default: active-high
    }
}

/// Format an lvalue with module context for name lookup
fn format_lvalue_with_context(lvalue: &skalp_mir::LValue, module: &Module) -> String {
    match lvalue {
        skalp_mir::LValue::Signal(id) => {
            // Find the signal name by ID
            module
                .signals
                .iter()
                .find(|s| s.id == *id)
                .map(|s| s.name.clone())
                .unwrap_or_else(|| format!("signal_{}", id.0))
        }
        skalp_mir::LValue::Variable(id) => {
            // Find the variable by ID
            let variable = module.variables.iter().find(|v| v.id == *id);

            if let Some(var) = variable {
                // Check if this variable is the first one with this name
                // The first occurrence keeps the original name, subsequent ones get suffixed
                let first_with_name = module.variables.iter().find(|v| v.name == var.name);

                if let Some(first_var) = first_with_name {
                    if first_var.id == *id {
                        // This is the first variable with this name - use original name
                        var.name.clone()
                    } else {
                        // This is not the first - check if there are multiple with same name
                        let same_name_count = module
                            .variables
                            .iter()
                            .filter(|v| v.name == var.name)
                            .count();

                        if same_name_count > 1 {
                            // Name collision exists - use unique name with ID suffix
                            format!("{}_{}", var.name, id.0)
                        } else {
                            // No collision (shouldn't happen, but handle it)
                            var.name.clone()
                        }
                    }
                } else {
                    // Shouldn't happen, but fallback to original name
                    var.name.clone()
                }
            } else {
                // Variable not found - use fallback
                format!("var_{}", id.0)
            }
        }
        skalp_mir::LValue::Port(id) => {
            // Find the port name by ID
            for port in &module.ports {}
            module
                .ports
                .iter()
                .find(|p| p.id == *id)
                .map(|p| p.name.clone())
                .unwrap_or_else(|| format!("port_{}", id.0))
        }
        skalp_mir::LValue::BitSelect { base, index } => {
            format!(
                "{}[{}]",
                format_lvalue_with_context(base, module),
                format_expression_with_context(index, module)
            )
        }
        skalp_mir::LValue::RangeSelect { base, high, low } => {
            format!(
                "{}[{}:{}]",
                format_lvalue_with_context(base, module),
                format_expression_with_context(high, module),
                format_expression_with_context(low, module)
            )
        }
        skalp_mir::LValue::Concat(lvalues) => {
            let parts: Vec<_> = lvalues
                .iter()
                .map(|lv| format_lvalue_with_context(lv, module))
                .collect();
            format!("{{{}}}", parts.join(", "))
        }
    }
}

/// Format an lvalue (fallback without context)
fn format_lvalue(lvalue: &skalp_mir::LValue) -> String {
    match lvalue {
        skalp_mir::LValue::Signal(id) => format!("signal_{}", id.0),
        skalp_mir::LValue::Variable(id) => format!("var_{}", id.0),
        skalp_mir::LValue::Port(id) => format!("port_{}", id.0),
        skalp_mir::LValue::BitSelect { base, index } => {
            format!("{}[{}]", format_lvalue(base), format_expression(index))
        }
        skalp_mir::LValue::RangeSelect { base, high, low } => {
            format!(
                "{}[{}:{}]",
                format_lvalue(base),
                format_expression(high),
                format_expression(low)
            )
        }
        skalp_mir::LValue::Concat(lvalues) => {
            let parts: Vec<_> = lvalues.iter().map(format_lvalue).collect();
            format!("{{{}}}", parts.join(", "))
        }
    }
}

/// Format an expression with module context
fn format_expression_with_context(expr: &skalp_mir::Expression, module: &Module) -> String {
    match &expr.kind {
        skalp_mir::ExpressionKind::Literal(val) => format_value(val),
        skalp_mir::ExpressionKind::Ref(lval) => format_lvalue_with_context(lval, module),
        skalp_mir::ExpressionKind::Binary { op, left, right } => {
            format!(
                "({} {} {})",
                format_expression_with_context(left, module),
                format_binary_op(op),
                format_expression_with_context(right, module)
            )
        }
        skalp_mir::ExpressionKind::Unary { op, operand } => {
            format!(
                "{}{}",
                format_unary_op(op),
                format_expression_with_context(operand, module)
            )
        }
        skalp_mir::ExpressionKind::Conditional {
            cond,
            then_expr,
            else_expr,
        } => {
            format!(
                "({} ? {} : {})",
                format_expression_with_context(cond, module),
                format_expression_with_context(then_expr, module),
                format_expression_with_context(else_expr, module)
            )
        }
        skalp_mir::ExpressionKind::Concat(exprs) => {
            let parts: Vec<_> = exprs
                .iter()
                .map(|e| format_expression_with_context(e, module))
                .collect();
            format!("{{{}}}", parts.join(", "))
        }
        skalp_mir::ExpressionKind::Replicate { count, value } => {
            format!(
                "{{{}{{{}}}}}",
                format_expression_with_context(count, module),
                format_expression_with_context(value, module)
            )
        }
        skalp_mir::ExpressionKind::FunctionCall { name, args } => {
            // Function calls are inlined by MIR, so reaching here means
            // an unresolved function call (should be rare)
            let arg_strs: Vec<_> = args
                .iter()
                .map(|a| format_expression_with_context(a, module))
                .collect();
            format!("{}({})", name, arg_strs.join(", "))
        }
        skalp_mir::ExpressionKind::Cast { expr, .. } => {
            // Cast is a no-op for SystemVerilog (bitwise reinterpretation)
            format_expression_with_context(expr, module)
        }
        // BUG FIX #85: Handle tuple/field access for module synthesis
        skalp_mir::ExpressionKind::TupleFieldAccess { base, index } => {
            // First, check if the base is a signal reference that's in our tuple source mapping
            if let skalp_mir::ExpressionKind::Ref(skalp_mir::LValue::Signal(sig_id)) = &base.kind {
                // Check the thread-local mapping for this signal
                let prefix = TUPLE_SOURCE_MAP.with(|map| map.borrow().get(sig_id).cloned());

                if let Some(inst_prefix) = prefix {
                    // Found in mapping - use the module instance result signal directly
                    return format!("{}_result_{}", inst_prefix, index);
                }
            }

            // BUG FIX #92: Handle case where base is a Concat expression
            // This happens when tuple destructuring is substituted inline (Block handling)
            // Concat elements are in reversed order: {result_N-1, ..., result_1, result_0}
            // So to get element at logical index I, we need element at position (N - 1 - I)
            if let skalp_mir::ExpressionKind::Concat(elements) = &base.kind {
                let num_elements = elements.len();
                // Calculate reversed position: index 0 is at the end of the Concat (LSB)
                let reversed_idx = num_elements.saturating_sub(1).saturating_sub(*index);
                if reversed_idx < num_elements {
                    return format_expression_with_context(&elements[reversed_idx], module);
                }
            }

            // For tuple returns from synthesized modules, the base signal name ends with _result_N
            // We need to replace N with the correct index
            let base_str = format_expression_with_context(base, module);

            // Check if this is a module result signal (pattern: *_inst_*_result_* or *_result_*)
            // Transform <prefix>_result_0 to <prefix>_result_<index>
            if let Some(prefix) = base_str.strip_suffix("_result_0") {
                format!("{}_result_{}", prefix, index)
            } else if base_str.contains("_result_") {
                // Already has a result suffix, try to replace the index
                // Find the last occurrence of _result_ and replace what follows
                if let Some(pos) = base_str.rfind("_result_") {
                    let prefix = &base_str[..pos];
                    format!("{}_result_{}", prefix, index)
                } else {
                    base_str
                }
            } else {
                // Not a module result signal - just return base (fallback)
                base_str
            }
        }
        skalp_mir::ExpressionKind::FieldAccess { base, .. } => {
            // Named field access - similar handling
            format_expression_with_context(base, module)
        }
    }
}

/// Format an expression (fallback without context)
fn format_expression(expr: &skalp_mir::Expression) -> String {
    match &expr.kind {
        skalp_mir::ExpressionKind::Literal(val) => format_value(val),
        skalp_mir::ExpressionKind::Ref(lval) => format_lvalue(lval),
        skalp_mir::ExpressionKind::Binary { op, left, right } => {
            format!(
                "({} {} {})",
                format_expression(left),
                format_binary_op(op),
                format_expression(right)
            )
        }
        skalp_mir::ExpressionKind::Unary { op, operand } => {
            format!("{}{}", format_unary_op(op), format_expression(operand))
        }
        skalp_mir::ExpressionKind::Conditional {
            cond,
            then_expr,
            else_expr,
        } => {
            format!(
                "({} ? {} : {})",
                format_expression(cond),
                format_expression(then_expr),
                format_expression(else_expr)
            )
        }
        skalp_mir::ExpressionKind::Concat(exprs) => {
            let parts: Vec<_> = exprs.iter().map(format_expression).collect();
            format!("{{{}}}", parts.join(", "))
        }
        skalp_mir::ExpressionKind::Replicate { count, value } => {
            format!(
                "{{{}{{{}}}}}",
                format_expression(count),
                format_expression(value)
            )
        }
        skalp_mir::ExpressionKind::FunctionCall { name, args } => {
            // Function calls are inlined by MIR, so reaching here means
            // an unresolved function call (should be rare)
            let arg_strs: Vec<_> = args.iter().map(format_expression).collect();
            format!("{}({})", name, arg_strs.join(", "))
        }
        skalp_mir::ExpressionKind::Cast { expr, .. } => {
            // Cast is a no-op for SystemVerilog (bitwise reinterpretation)
            format_expression(expr)
        }
        // BUG FIX #85: Handle tuple/field access for module synthesis
        skalp_mir::ExpressionKind::TupleFieldAccess { base, .. } => format_expression(base),
        skalp_mir::ExpressionKind::FieldAccess { base, .. } => format_expression(base),
    }
}

/// Format a value
fn format_value(value: &skalp_mir::Value) -> String {
    match value {
        skalp_mir::Value::Integer(n) => n.to_string(),
        skalp_mir::Value::Float(f) => {
            // BUG FIX #17: Convert float to IEEE 754 bit representation
            // Hardware doesn't have native float types, so we represent floats as bit patterns
            // For f32: convert to IEEE 754 32-bit representation as hex literal
            let bits = (*f as f32).to_bits();
            format!("32'h{:08X}", bits)
        }
        skalp_mir::Value::BitVector { width, value } => {
            format!("{}'b{:0width$b}", width, value, width = *width)
        }
        skalp_mir::Value::String(s) => format!("\"{}\"", s),
        skalp_mir::Value::Unknown => "'x".to_string(),
        skalp_mir::Value::HighZ => "'z".to_string(),
    }
}

/// Format binary operator
fn format_binary_op(op: &skalp_mir::BinaryOp) -> &'static str {
    match op {
        skalp_mir::BinaryOp::Add => "+",
        skalp_mir::BinaryOp::Sub => "-",
        skalp_mir::BinaryOp::Mul => "*",
        skalp_mir::BinaryOp::Div => "/",
        skalp_mir::BinaryOp::Mod => "%",
        skalp_mir::BinaryOp::And => "&", // Logical operations (same as bitwise in Verilog context)
        skalp_mir::BinaryOp::Or => "|",
        skalp_mir::BinaryOp::Xor => "^",
        skalp_mir::BinaryOp::BitwiseAnd => "&",
        skalp_mir::BinaryOp::BitwiseOr => "|",
        skalp_mir::BinaryOp::BitwiseXor => "^",
        skalp_mir::BinaryOp::LogicalAnd => "&&",
        skalp_mir::BinaryOp::LogicalOr => "||",
        skalp_mir::BinaryOp::Equal => "==",
        skalp_mir::BinaryOp::NotEqual => "!=",
        skalp_mir::BinaryOp::Less => "<",
        skalp_mir::BinaryOp::LessEqual => "<=",
        skalp_mir::BinaryOp::Greater => ">",
        skalp_mir::BinaryOp::GreaterEqual => ">=",
        skalp_mir::BinaryOp::LeftShift => "<<",
        skalp_mir::BinaryOp::RightShift => ">>",
    }
}

/// Format unary operator
fn format_unary_op(op: &skalp_mir::UnaryOp) -> &'static str {
    match op {
        skalp_mir::UnaryOp::BitwiseNot => "~",
        skalp_mir::UnaryOp::Not => "!",
        skalp_mir::UnaryOp::Negate => "-",
        skalp_mir::UnaryOp::Reduce(reduce_op) => match reduce_op {
            skalp_mir::ReduceOp::And => "&",
            skalp_mir::ReduceOp::Or => "|",
            skalp_mir::ReduceOp::Xor => "^",
            skalp_mir::ReduceOp::Nand => "~&",
            skalp_mir::ReduceOp::Nor => "~|",
            skalp_mir::ReduceOp::Xnor => "~^",
        },
    }
}

/// Get width specification string for a data type
fn get_width_spec(data_type: &skalp_mir::DataType) -> String {
    match data_type {
        skalp_mir::DataType::Bit(width)
        | skalp_mir::DataType::Logic(width)
        | skalp_mir::DataType::Nat(width) => {
            if *width > 1 {
                format!("[{}:0] ", width - 1)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Int(width) => {
            if *width > 1 {
                format!("signed [{}:0] ", width - 1)
            } else {
                "signed ".to_string()
            }
        }
        skalp_mir::DataType::Bool => String::new(), // Boolean is single bit
        // Parametric types use parameter name
        skalp_mir::DataType::BitParam { param, default }
        | skalp_mir::DataType::LogicParam { param, default }
        | skalp_mir::DataType::NatParam { param, default } => {
            if *default > 1 {
                format!("[{}-1:0] ", param)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::IntParam { param, default } => {
            if *default > 1 {
                format!("signed [{}-1:0] ", param)
            } else {
                "signed ".to_string()
            }
        }
        // Expression-based parametric types - convert MIR expression to SystemVerilog
        skalp_mir::DataType::BitExpr { expr, default }
        | skalp_mir::DataType::LogicExpr { expr, default }
        | skalp_mir::DataType::NatExpr { expr, default } => {
            if *default > 1 {
                // Convert MIR expression to SystemVerilog string
                let expr_str = convert_mir_expr_to_sv(expr);
                format!("[{}-1:0] ", expr_str)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::IntExpr { expr, default } => {
            if *default > 1 {
                let expr_str = convert_mir_expr_to_sv(expr);
                format!("signed [{}-1:0] ", expr_str)
            } else {
                "signed ".to_string()
            }
        }
        skalp_mir::DataType::Clock { .. } => String::new(), // Clocks are single bit
        skalp_mir::DataType::Reset { .. } => String::new(), // Resets are single bit
        skalp_mir::DataType::Event => String::new(),        // Events have no width
        skalp_mir::DataType::Array(element_type, size) => {
            // Array format: [element_width][0:size-1]
            let element_width = get_width_spec(element_type);
            if *size > 1 {
                format!("{}[0:{}] ", element_width.trim(), size - 1)
            } else {
                element_width
            }
        }
        skalp_mir::DataType::Struct(struct_type) => {
            // For structs, calculate total width
            let mut total_width = 0;
            for field in &struct_type.fields {
                total_width += get_type_width(&field.field_type);
            }
            if total_width > 1 {
                format!("[{}:0] ", total_width - 1)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Enum(_) => {
            // Enums default to 32-bit
            "[31:0] ".to_string()
        }
        skalp_mir::DataType::Union(union_type) => {
            // Unions use the width of the largest field
            let mut max_width = 0;
            for field in &union_type.fields {
                let width = get_type_width(&field.field_type);
                if width > max_width {
                    max_width = width;
                }
            }
            if max_width > 1 {
                format!("[{}:0] ", max_width - 1)
            } else {
                String::new()
            }
        }
        // Floating-point types have fixed widths
        skalp_mir::DataType::Float16 => "[15:0] ".to_string(),
        skalp_mir::DataType::Float32 => "[31:0] ".to_string(),
        skalp_mir::DataType::Float64 => "[63:0] ".to_string(),
        // Vector types - width is element_width * component_count
        skalp_mir::DataType::Vec2(element_type) => {
            let elem_width = get_type_width(element_type);
            let total_width = elem_width * 2;
            if total_width > 1 {
                format!("[{}:0] ", total_width - 1)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Vec3(element_type) => {
            let elem_width = get_type_width(element_type);
            let total_width = elem_width * 3;
            if total_width > 1 {
                format!("[{}:0] ", total_width - 1)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Vec4(element_type) => {
            let elem_width = get_type_width(element_type);
            let total_width = elem_width * 4;
            if total_width > 1 {
                format!("[{}:0] ", total_width - 1)
            } else {
                String::new()
            }
        }
        // NCL dual-rail type - physical width is 2x logical width
        skalp_mir::DataType::Ncl(logical_width) => {
            let physical_width = logical_width * 2;
            if physical_width > 1 {
                format!("[{}:0] ", physical_width - 1)
            } else {
                String::new()
            }
        }
    }
}

/// Get type dimensions split into element width and array dimensions
/// Returns (element_width, array_dimensions)
/// For non-arrays: returns (width_spec, "")
/// For arrays: returns (element_width_spec, " [0:size-1]")
fn get_type_dimensions(data_type: &skalp_mir::DataType) -> (String, String) {
    match data_type {
        skalp_mir::DataType::Array(element_type, size) => {
            // Recursively handle nested arrays
            let (inner_element, inner_array) = get_type_dimensions(element_type);
            let array_dim = if *size > 1 {
                format!("{} [0:{}]", inner_array, size - 1)
            } else {
                inner_array
            };
            (inner_element, array_dim)
        }
        _ => {
            // Non-array types: return width spec with no array dimension
            (get_width_spec(data_type), String::new())
        }
    }
}

/// Get the width in bits of a data type
///
/// **Note:** Uses the shared type_width module for consistent width calculation.
/// After Phase 2 of the refactoring, MIR ports and signals should only have
/// scalar types. If composite types appear here, it indicates a bug in HIRMIR.
fn get_type_width(data_type: &skalp_mir::DataType) -> usize {
    type_width::get_type_width(data_type)
}

/// Flatten a port with struct type into individual signals
/// For example: vertex: Vertex becomes vertex_position_x, vertex_position_y, etc.
fn flatten_port_to_signals(
    name: &str,
    port_type: &DataType,
    direction: &str,
    ports: &mut Vec<String>,
) {
    match port_type {
        DataType::Struct(struct_type) => {
            // Recursively flatten each field
            for field in &struct_type.fields {
                let field_name = format!("{}_{}", name, field.name);
                flatten_port_to_signals(&field_name, &field.field_type, direction, ports);
            }
        }
        DataType::Vec2(element_type) => {
            // Flatten Vec2 into x, y components
            let x_name = format!("{}_x", name);
            let y_name = format!("{}_y", name);
            flatten_port_to_signals(&x_name, element_type, direction, ports);
            flatten_port_to_signals(&y_name, element_type, direction, ports);
        }
        DataType::Vec3(element_type) => {
            // Flatten Vec3 into x, y, z components
            let x_name = format!("{}_x", name);
            let y_name = format!("{}_y", name);
            let z_name = format!("{}_z", name);
            flatten_port_to_signals(&x_name, element_type, direction, ports);
            flatten_port_to_signals(&y_name, element_type, direction, ports);
            flatten_port_to_signals(&z_name, element_type, direction, ports);
        }
        DataType::Vec4(element_type) => {
            // Flatten Vec4 into x, y, z, w components
            let x_name = format!("{}_x", name);
            let y_name = format!("{}_y", name);
            let z_name = format!("{}_z", name);
            let w_name = format!("{}_w", name);
            flatten_port_to_signals(&x_name, element_type, direction, ports);
            flatten_port_to_signals(&y_name, element_type, direction, ports);
            flatten_port_to_signals(&z_name, element_type, direction, ports);
            flatten_port_to_signals(&w_name, element_type, direction, ports);
        }
        _ => {
            // Non-struct type - add as single port
            let (element_width, array_dim) = get_type_dimensions(port_type);
            ports.push(format!(
                "    {} {}{}{}",
                direction, element_width, name, array_dim
            ));
        }
    }
}

/// Expand a struct assignment into individual field assignments
/// Returns a vector of (lhs_string, rhs_string) pairs
fn expand_struct_assignment(
    lhs: &skalp_mir::LValue,
    rhs: &skalp_mir::Expression,
    module: &Module,
) -> Vec<(String, String)> {
    let mut assignments = Vec::new();

    // Get the base lvalue and its type
    let (base_lvalue, lvalue_type) = match lhs {
        skalp_mir::LValue::Signal(id) => {
            let signal = module.signals.iter().find(|s| s.id == *id);
            if let Some(sig) = signal {
                (lhs, &sig.signal_type)
            } else {
                // If signal not found, return as-is
                assignments.push((
                    format_lvalue_with_context(lhs, module),
                    format_expression_with_context(rhs, module),
                ));
                return assignments;
            }
        }
        skalp_mir::LValue::Port(id) => {
            let port = module.ports.iter().find(|p| p.id == *id);
            if let Some(p) = port {
                (lhs, &p.port_type)
            } else {
                // If port not found, return as-is
                assignments.push((
                    format_lvalue_with_context(lhs, module),
                    format_expression_with_context(rhs, module),
                ));
                return assignments;
            }
        }
        _ => {
            // For other lvalue types (bit select, range select, etc.), return as-is
            assignments.push((
                format_lvalue_with_context(lhs, module),
                format_expression_with_context(rhs, module),
            ));
            return assignments;
        }
    };

    // Check if it's a struct or vector type that needs expansion
    match lvalue_type {
        DataType::Struct(struct_type) => {
            // Get the base name for LHS
            let lhs_base_name = format_lvalue_with_context(base_lvalue, module);

            // Check if RHS is also a signal/port reference to expand from
            let rhs_base_name = if let skalp_mir::ExpressionKind::Ref(rhs_lvalue) = &rhs.kind {
                Some(format_lvalue_with_context(rhs_lvalue, module))
            } else {
                None
            };

            // Expand each field
            for field in &struct_type.fields {
                let lhs_field_name = format!("{}_{}", lhs_base_name, field.name);
                let rhs_field_expr = if let Some(ref rhs_name) = rhs_base_name {
                    format!("{}_{}", rhs_name, field.name)
                } else {
                    // RHS is not a simple reference, can't expand
                    // This shouldn't happen for simple struct assignments
                    format_expression_with_context(rhs, module)
                };

                // Recursively expand nested structs
                expand_field_assignment(
                    &lhs_field_name,
                    &rhs_field_expr,
                    &field.field_type,
                    &mut assignments,
                );
            }
        }
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => {
            // Get the base name for LHS
            let lhs_base_name = format_lvalue_with_context(base_lvalue, module);

            // Check if RHS is also a signal/port reference
            let rhs_base_name = if let skalp_mir::ExpressionKind::Ref(rhs_lvalue) = &rhs.kind {
                Some(format_lvalue_with_context(rhs_lvalue, module))
            } else {
                None
            };

            // Determine component names based on vector type
            let components = match lvalue_type {
                DataType::Vec2(_) => vec!["x", "y"],
                DataType::Vec3(_) => vec!["x", "y", "z"],
                DataType::Vec4(_) => vec!["x", "y", "z", "w"],
                _ => unreachable!(),
            };

            // Expand each component
            for component in components {
                let lhs_comp_name = format!("{}_{}", lhs_base_name, component);
                let rhs_comp_expr = if let Some(ref rhs_name) = rhs_base_name {
                    format!("{}_{}", rhs_name, component)
                } else {
                    format_expression_with_context(rhs, module)
                };

                expand_field_assignment(
                    &lhs_comp_name,
                    &rhs_comp_expr,
                    element_type,
                    &mut assignments,
                );
            }
        }
        _ => {
            // Not a struct type, return as single assignment
            assignments.push((
                format_lvalue_with_context(lhs, module),
                format_expression_with_context(rhs, module),
            ));
        }
    }

    assignments
}

/// Helper to recursively expand nested struct fields
fn expand_field_assignment(
    lhs_name: &str,
    rhs_expr: &str,
    field_type: &DataType,
    assignments: &mut Vec<(String, String)>,
) {
    match field_type {
        DataType::Struct(struct_type) => {
            // Recursively expand nested struct fields
            for field in &struct_type.fields {
                let nested_lhs = format!("{}_{}", lhs_name, field.name);
                let nested_rhs = format!("{}_{}", rhs_expr, field.name);
                expand_field_assignment(&nested_lhs, &nested_rhs, &field.field_type, assignments);
            }
        }
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => {
            let components = match field_type {
                DataType::Vec2(_) => vec!["x", "y"],
                DataType::Vec3(_) => vec!["x", "y", "z"],
                DataType::Vec4(_) => vec!["x", "y", "z", "w"],
                _ => unreachable!(),
            };

            for component in components {
                let nested_lhs = format!("{}_{}", lhs_name, component);
                let nested_rhs = format!("{}_{}", rhs_expr, component);
                expand_field_assignment(&nested_lhs, &nested_rhs, element_type, assignments);
            }
        }
        _ => {
            // Leaf field - add assignment
            assignments.push((lhs_name.to_string(), rhs_expr.to_string()));
        }
    }
}

/// Expand a port connection for flattened struct/vector types
/// Returns a vector of (port_field_name, signal_field_expr) pairs
/// This handles entity instantiation where both ports and signals may be flattened
fn expand_port_connection(
    port_name: &str,
    port_type: &DataType,
    signal_expr: &skalp_mir::Expression,
    parent_module: &Module,
) -> Vec<(String, String)> {
    let mut connections = Vec::new();

    match port_type {
        DataType::Struct(struct_type) => {
            // Get the signal base name if it's a simple reference
            let signal_base_name = if let skalp_mir::ExpressionKind::Ref(lvalue) = &signal_expr.kind
            {
                Some(format_lvalue_with_context(lvalue, parent_module))
            } else {
                None
            };

            // Expand each field
            for field in &struct_type.fields {
                let port_field_name = format!("{}_{}", port_name, field.name);
                let signal_field_name = if let Some(ref signal_name) = signal_base_name {
                    format!("{}_{}", signal_name, field.name)
                } else {
                    // Can't expand non-reference expressions, use as-is
                    format_expression_with_context(signal_expr, parent_module)
                };

                // Recursively expand nested types
                expand_port_connection_field(
                    &port_field_name,
                    &signal_field_name,
                    &field.field_type,
                    &mut connections,
                );
            }
        }
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => {
            // Get the signal base name
            let signal_base_name = if let skalp_mir::ExpressionKind::Ref(lvalue) = &signal_expr.kind
            {
                Some(format_lvalue_with_context(lvalue, parent_module))
            } else {
                None
            };

            // Determine components
            let components = match port_type {
                DataType::Vec2(_) => vec!["x", "y"],
                DataType::Vec3(_) => vec!["x", "y", "z"],
                DataType::Vec4(_) => vec!["x", "y", "z", "w"],
                _ => unreachable!(),
            };

            // Expand each component
            for component in components {
                let port_comp_name = format!("{}_{}", port_name, component);
                let signal_comp_name = if let Some(ref signal_name) = signal_base_name {
                    format!("{}_{}", signal_name, component)
                } else {
                    format_expression_with_context(signal_expr, parent_module)
                };

                expand_port_connection_field(
                    &port_comp_name,
                    &signal_comp_name,
                    element_type,
                    &mut connections,
                );
            }
        }
        _ => {
            // Scalar type - single connection
            connections.push((
                port_name.to_string(),
                format_expression_with_context(signal_expr, parent_module),
            ));
        }
    }

    connections
}

/// Helper to recursively expand nested struct/vector fields in port connections
fn expand_port_connection_field(
    port_field_name: &str,
    signal_field_name: &str,
    field_type: &DataType,
    connections: &mut Vec<(String, String)>,
) {
    match field_type {
        DataType::Struct(struct_type) => {
            // Recursively expand nested struct
            for field in &struct_type.fields {
                let nested_port = format!("{}_{}", port_field_name, field.name);
                let nested_signal = format!("{}_{}", signal_field_name, field.name);
                expand_port_connection_field(
                    &nested_port,
                    &nested_signal,
                    &field.field_type,
                    connections,
                );
            }
        }
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => {
            let components = match field_type {
                DataType::Vec2(_) => vec!["x", "y"],
                DataType::Vec3(_) => vec!["x", "y", "z"],
                DataType::Vec4(_) => vec!["x", "y", "z", "w"],
                _ => unreachable!(),
            };

            for component in components {
                let nested_port = format!("{}_{}", port_field_name, component);
                let nested_signal = format!("{}_{}", signal_field_name, component);
                expand_port_connection_field(
                    &nested_port,
                    &nested_signal,
                    element_type,
                    connections,
                );
            }
        }
        _ => {
            // Leaf field - add connection
            connections.push((port_field_name.to_string(), signal_field_name.to_string()));
        }
    }
}

/// Flatten a signal with struct type into individual declarations
/// For example: vertex: Vertex becomes vertex_position_x, vertex_position_y, etc.
fn flatten_signal_to_declarations(
    name: &str,
    signal_type: &DataType,
    reg_or_wire: &str,
    initial_value: &Option<skalp_mir::Value>,
    declarations: &mut Vec<String>,
) {
    match signal_type {
        DataType::Struct(struct_type) => {
            // Recursively flatten each field
            for field in &struct_type.fields {
                let field_name = format!("{}_{}", name, field.name);
                // For struct fields, we don't propagate the initial value
                // (would need to extract field values from struct literal)
                flatten_signal_to_declarations(
                    &field_name,
                    &field.field_type,
                    reg_or_wire,
                    &None,
                    declarations,
                );
            }
        }
        DataType::Vec2(element_type) => {
            // Flatten Vec2 into x, y components
            flatten_signal_to_declarations(
                &format!("{}_x", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_y", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
        }
        DataType::Vec3(element_type) => {
            // Flatten Vec3 into x, y, z components
            flatten_signal_to_declarations(
                &format!("{}_x", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_y", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_z", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
        }
        DataType::Vec4(element_type) => {
            // Flatten Vec4 into x, y, z, w components
            flatten_signal_to_declarations(
                &format!("{}_x", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_y", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_z", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_w", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
        }
        _ => {
            // Non-struct type - add as single declaration
            let (element_width, array_dim) = get_type_dimensions(signal_type);
            let mut decl = format!("    {} {}{}{}", reg_or_wire, element_width, name, array_dim);

            // Add initial value if present
            if let Some(init) = initial_value {
                decl.push_str(&format!(" = {}", format_value(init)));
            }

            declarations.push(decl);
        }
    }
}

/// Check if a signal is a register (assigned in sequential blocks)
fn is_register(signal: &skalp_mir::Signal, module: &Module) -> bool {
    // A signal is a register if it's assigned in any sequential process
    for process in &module.processes {
        if process.kind == ProcessKind::Sequential
            && is_signal_assigned_in_block(&signal.id, &process.body)
        {
            return true;
        }
    }
    false
}

/// Check if a signal is assigned in a block
fn is_signal_assigned_in_block(signal_id: &skalp_mir::SignalId, block: &skalp_mir::Block) -> bool {
    for stmt in &block.statements {
        match stmt {
            Statement::Assignment(assign) => {
                // Check if this assignment targets the signal (directly or through indexing/slicing)
                if lvalue_contains_signal(&assign.lhs, signal_id) {
                    return true;
                }
            }
            Statement::If(if_stmt) => {
                if is_signal_assigned_in_block(signal_id, &if_stmt.then_block) {
                    return true;
                }
                if let Some(else_block) = &if_stmt.else_block {
                    if is_signal_assigned_in_block(signal_id, else_block) {
                        return true;
                    }
                }
            }
            Statement::Case(case_stmt) => {
                // Check all case items
                for item in &case_stmt.items {
                    if is_signal_assigned_in_block(signal_id, &item.block) {
                        return true;
                    }
                }
                // Check default case
                if let Some(default_block) = &case_stmt.default {
                    if is_signal_assigned_in_block(signal_id, default_block) {
                        return true;
                    }
                }
            }
            Statement::Block(block) => {
                if is_signal_assigned_in_block(signal_id, block) {
                    return true;
                }
            }
            _ => {}
        }
    }
    false
}

/// Check if an LValue references a specific signal (directly or through indexing/slicing)
fn lvalue_contains_signal(lvalue: &skalp_mir::LValue, signal_id: &skalp_mir::SignalId) -> bool {
    match lvalue {
        skalp_mir::LValue::Signal(id) => id == signal_id,
        skalp_mir::LValue::BitSelect { base, .. } => lvalue_contains_signal(base, signal_id),
        skalp_mir::LValue::RangeSelect { base, .. } => lvalue_contains_signal(base, signal_id),
        skalp_mir::LValue::Concat(items) => items
            .iter()
            .any(|item| lvalue_contains_signal(item, signal_id)),
        _ => false,
    }
}

/// Collect all struct and enum types used in a module
fn collect_types_from_module(
    module: &Module,
    struct_types: &mut HashSet<String>,
    enum_types: &mut HashSet<String>,
) {
    // Collect from port types
    for port in &module.ports {
        collect_types_from_datatype(&port.port_type, struct_types, enum_types);
    }

    // Collect from signal types
    for signal in &module.signals {
        collect_types_from_datatype(&signal.signal_type, struct_types, enum_types);
    }
}

/// Recursively collect struct and enum types from a DataType
fn collect_types_from_datatype(
    data_type: &DataType,
    struct_types: &mut HashSet<String>,
    enum_types: &mut HashSet<String>,
) {
    match data_type {
        DataType::Struct(struct_type) => {
            struct_types.insert(struct_type.name.clone());
            // Collect types from struct fields
            for field in &struct_type.fields {
                collect_types_from_datatype(&field.field_type, struct_types, enum_types);
            }
        }
        DataType::Enum(enum_type) => {
            enum_types.insert(enum_type.name.clone());
            // Collect types from enum base type
            collect_types_from_datatype(&enum_type.base_type, struct_types, enum_types);
        }
        DataType::Array(element_type, _) => {
            collect_types_from_datatype(element_type, struct_types, enum_types);
        }
        DataType::Union(union_type) => {
            // For unions, collect field types (treat similar to structs for now)
            for field in &union_type.fields {
                collect_types_from_datatype(&field.field_type, struct_types, enum_types);
            }
        }
        _ => {} // Primitive types don't need typedef collection
    }
}

/// Generate SystemVerilog typedefs for collected struct and enum types
fn generate_typedefs(
    module: &Module,
    struct_type_names: &HashSet<String>,
    enum_type_names: &HashSet<String>,
) -> String {
    let mut typedefs = String::new();

    if struct_type_names.is_empty() && enum_type_names.is_empty() {
        return typedefs;
    }

    // Find the actual type definitions in the module's port/signal types
    let mut generated_structs: HashSet<String> = HashSet::new();
    let mut generated_enums: HashSet<String> = HashSet::new();

    // Generate struct typedefs
    for port in &module.ports {
        generate_typedefs_for_datatype(
            &port.port_type,
            &mut typedefs,
            &mut generated_structs,
            &mut generated_enums,
            struct_type_names,
            enum_type_names,
        );
    }

    for signal in &module.signals {
        generate_typedefs_for_datatype(
            &signal.signal_type,
            &mut typedefs,
            &mut generated_structs,
            &mut generated_enums,
            struct_type_names,
            enum_type_names,
        );
    }

    if !typedefs.is_empty() {
        typedefs.push('\n');
    }

    typedefs
}

/// Generate typedefs for a specific DataType
fn generate_typedefs_for_datatype(
    data_type: &DataType,
    typedefs: &mut String,
    generated_structs: &mut HashSet<String>,
    generated_enums: &mut HashSet<String>,
    target_structs: &HashSet<String>,
    target_enums: &HashSet<String>,
) {
    match data_type {
        DataType::Struct(struct_type) => {
            if target_structs.contains(&struct_type.name)
                && !generated_structs.contains(&struct_type.name)
            {
                // Generate struct fields first (in case they reference other types)
                for field in &struct_type.fields {
                    generate_typedefs_for_datatype(
                        &field.field_type,
                        typedefs,
                        generated_structs,
                        generated_enums,
                        target_structs,
                        target_enums,
                    );
                }

                // Generate the struct typedef
                typedefs.push_str("typedef struct {\n");
                for field in &struct_type.fields {
                    let field_width = get_width_spec(&field.field_type);
                    typedefs.push_str(&format!(
                        "    {}{} {};\n",
                        get_systemverilog_type(&field.field_type),
                        field_width,
                        field.name
                    ));
                }
                typedefs.push_str(&format!("}} {};\n\n", struct_type.name));

                generated_structs.insert(struct_type.name.clone());
            }
        }
        DataType::Enum(enum_type) => {
            if target_enums.contains(&enum_type.name) && !generated_enums.contains(&enum_type.name)
            {
                // Generate base type first
                generate_typedefs_for_datatype(
                    &enum_type.base_type,
                    typedefs,
                    generated_structs,
                    generated_enums,
                    target_structs,
                    target_enums,
                );

                // Generate the enum typedef
                let base_width = get_width_spec(&enum_type.base_type);
                typedefs.push_str(&format!(
                    "typedef enum {}{} {{\n",
                    get_systemverilog_type(&enum_type.base_type),
                    base_width
                ));

                for (i, variant) in enum_type.variants.iter().enumerate() {
                    if i > 0 {
                        typedefs.push_str(",\n");
                    }
                    if let Some(value) = &variant.value {
                        typedefs.push_str(&format!(
                            "    {} = {}",
                            variant.name,
                            format_value(value)
                        ));
                    } else {
                        typedefs.push_str(&format!("    {}", variant.name));
                    }
                }
                typedefs.push_str(&format!("\n}} {};\n\n", enum_type.name));

                generated_enums.insert(enum_type.name.clone());
            }
        }
        DataType::Array(element_type, _) => {
            generate_typedefs_for_datatype(
                element_type,
                typedefs,
                generated_structs,
                generated_enums,
                target_structs,
                target_enums,
            );
        }
        DataType::Union(union_type) => {
            // Handle unions similarly to structs for now
            for field in &union_type.fields {
                generate_typedefs_for_datatype(
                    &field.field_type,
                    typedefs,
                    generated_structs,
                    generated_enums,
                    target_structs,
                    target_enums,
                );
            }
        }
        _ => {} // Primitive types don't need typedef generation
    }
}

/// Get the SystemVerilog type name for a DataType (for typedef generation)
fn get_systemverilog_type(data_type: &DataType) -> &'static str {
    match data_type {
        DataType::Bit(_) | DataType::BitParam { .. } | DataType::BitExpr { .. } => "bit",
        DataType::Logic(_) | DataType::LogicParam { .. } | DataType::LogicExpr { .. } => "logic",
        DataType::Int(_) | DataType::IntParam { .. } | DataType::IntExpr { .. } => "int",
        DataType::Nat(_) | DataType::NatParam { .. } | DataType::NatExpr { .. } => "logic", // Use logic for unsigned naturals
        _ => "logic", // Default to logic for other types
    }
}

/// Convert a MIR expression to a SystemVerilog expression string
/// This is specifically for const expressions used in type positions (like clog2(SIZE))
fn convert_mir_expr_to_sv(expr: &skalp_mir::Expression) -> String {
    match &expr.kind {
        skalp_mir::ExpressionKind::Literal(val) => format_value(val),
        skalp_mir::ExpressionKind::Binary { op, left, right } => {
            format!(
                "({}{}{})",
                convert_mir_expr_to_sv(left),
                format_binary_op(op),
                convert_mir_expr_to_sv(right)
            )
        }
        skalp_mir::ExpressionKind::FunctionCall { name, args } => {
            // Handle built-in functions that map to SystemVerilog functions
            match name.as_str() {
                "clog2" => {
                    // clog2(x)  $clog2(x)
                    if args.len() == 1 {
                        format!("$clog2({})", convert_mir_expr_to_sv(&args[0]))
                    } else {
                        "$clog2(0)".to_string() // Fallback for invalid args
                    }
                }
                "pow2" => {
                    // pow2(x)  (1 << x)
                    if args.len() == 1 {
                        format!("(1 << {})", convert_mir_expr_to_sv(&args[0]))
                    } else {
                        "1".to_string() // Fallback
                    }
                }
                _ => {
                    // Generic parameter reference (stored as FunctionCall with no args)
                    // or unknown function
                    if args.is_empty() {
                        // This is a parameter reference like SIZE
                        name.clone()
                    } else {
                        // Unknown function - try to emit as-is
                        let arg_strs: Vec<_> = args.iter().map(convert_mir_expr_to_sv).collect();
                        format!("{}({})", name, arg_strs.join(", "))
                    }
                }
            }
        }
        _ => {
            // For other expression types (like Ref, Conditional, etc.), use the general formatter
            format_expression(expr)
        }
    }
}

/// Generate a formal verification assertion (SVA)
/// Outputs SystemVerilog Assertions for assert!, assume!, and cover! statements
fn generate_assertion(assertion: &Assertion, module: &Module) -> String {
    let condition = format_expression_with_context(&assertion.condition, module);

    match assertion.kind {
        AssertionKind::Assert => {
            if let Some(ref msg) = assertion.message {
                format!(
                    "    assert property ({}) else $error(\"{}\");\n",
                    condition, msg
                )
            } else {
                format!("    assert property ({});\n", condition)
            }
        }
        AssertionKind::Assume => {
            if let Some(ref msg) = assertion.message {
                format!("    assume property ({}); // {}\n", condition, msg)
            } else {
                format!("    assume property ({});\n", condition)
            }
        }
        AssertionKind::Cover => {
            if let Some(ref name) = assertion.message {
                format!("    cover property ({}) $info(\"{}\");\n", condition, name)
            } else {
                format!("    cover property ({});\n", condition)
            }
        }
    }
}

/// Generate a breakpoint assertion for debugging
///
/// Generates SystemVerilog Assertions (SVA) that can trigger $stop or $info
/// in simulation for debugging purposes.
///
/// # Examples
///
/// Simple breakpoint (triggers on non-zero value):
/// ```systemverilog
/// // Breakpoint: error_flag
/// always @(error_flag) if (error_flag) $stop;
/// ```
///
/// Conditional breakpoint:
/// ```systemverilog
/// // Breakpoint: overflow_counter (condition: count > 100)
/// always @(*) if (count > 100) begin
///     $display("BREAKPOINT: overflow_counter - count > 100");
///     $stop;
/// end
/// ```
fn generate_breakpoint_assertion(
    signal_name: &str,
    bp_config: &skalp_frontend::hir::BreakpointConfig,
) -> String {
    let mut sv = String::new();

    // Get the breakpoint name for display
    let bp_name = bp_config.name.as_deref().unwrap_or(signal_name);

    // Add comment
    if let Some(ref condition) = bp_config.condition {
        sv.push_str(&format!(
            "    // Breakpoint: {} (condition: {})\n",
            bp_name, condition
        ));
    } else {
        sv.push_str(&format!("    // Breakpoint: {}\n", bp_name));
    }

    // Determine the condition expression
    let condition_expr = if let Some(ref cond) = bp_config.condition {
        cond.clone()
    } else {
        // Default: trigger when signal is non-zero
        signal_name.to_string()
    };

    // Determine the action: $stop for errors, $display + $stop for others
    let action = if bp_config.is_error {
        if let Some(ref msg) = bp_config.message {
            format!("$error(\"BREAKPOINT [{}]: {}\"); $stop;", bp_name, msg)
        } else {
            format!("$error(\"BREAKPOINT [{}] triggered\"); $stop;", bp_name)
        }
    } else if let Some(ref msg) = bp_config.message {
        format!("$display(\"BREAKPOINT [{}]: {}\"); $stop;", bp_name, msg)
    } else {
        format!("$display(\"BREAKPOINT [{}] triggered\"); $stop;", bp_name)
    };

    // Generate the assertion block
    // Use always @(*) for combinational checks to ensure condition is evaluated
    sv.push_str(&format!(
        "    always @(*) if ({}) begin\n        {}\n    end\n",
        condition_expr, action
    ));

    sv
}

/// Generate CDC synchronizer logic for a signal
///
/// Based on the CdcConfig, generates appropriate synchronizer structures:
/// - TwoFF: Simple 2-stage (or N-stage) flip-flop chain for single-bit signals
/// - Gray: Gray code encoder/decoder for multi-bit values
/// - Handshake: Request/acknowledge handshake protocol
/// - Pulse: Pulse synchronizer for edge detection
/// - AsyncFifo: Async FIFO with dual-clock pointers (generates comment only)
fn generate_cdc_synchronizer(
    sv: &mut String,
    signal_name: &str,
    element_width: &str,
    array_dim: &str,
    data_width: usize,
    cdc_config: &CdcConfig,
) {
    let stages = cdc_config.sync_stages as usize;
    let from_domain = cdc_config.from_domain.as_deref().unwrap_or("async");
    let to_domain = cdc_config.to_domain.as_deref().unwrap_or("sync");

    // Add CDC comment header
    sv.push_str(&format!(
        "    // CDC Synchronizer: {} -> {}, type={:?}, stages={}\n",
        from_domain, to_domain, cdc_config.cdc_type, stages
    ));

    match cdc_config.cdc_type {
        CdcType::TwoFF => {
            // Generate N-stage flip-flop synchronizer chain
            // For single-bit or narrow signals
            generate_two_ff_synchronizer(sv, signal_name, element_width, array_dim, stages);
        }
        CdcType::Gray => {
            // Generate Gray code synchronizer for multi-bit values
            // Converts binary -> gray -> sync stages -> binary
            if data_width > 1 {
                generate_gray_code_synchronizer(
                    sv,
                    signal_name,
                    element_width,
                    array_dim,
                    data_width,
                    stages,
                );
            } else {
                // Fall back to 2FF for single-bit
                generate_two_ff_synchronizer(sv, signal_name, element_width, array_dim, stages);
            }
        }
        CdcType::Pulse => {
            // Generate pulse synchronizer for edge detection across domains
            generate_pulse_synchronizer(sv, signal_name, element_width, array_dim, stages);
        }
        CdcType::Handshake => {
            // Generate handshake synchronizer signals
            generate_handshake_synchronizer(sv, signal_name, element_width, array_dim, stages);
        }
        CdcType::AsyncFifo => {
            // Async FIFO is too complex for inline generation
            // Generate placeholder with instantiation hint
            sv.push_str(&format!(
                "    // TODO: Instantiate async FIFO for {} (requires external module)\n",
                signal_name
            ));
            sv.push_str(&format!(
                "    // Suggested: async_fifo #(.WIDTH({})) {}_fifo (.*);\n",
                data_width, signal_name
            ));
            // Generate the base signal as wire
            sv.push_str(&format!(
                "    wire {}{}{};\n",
                element_width, signal_name, array_dim
            ));
        }
    }
}

/// Generate N-stage flip-flop synchronizer
/// Creates: signal_sync_0, signal_sync_1, ..., signal (final output)
fn generate_two_ff_synchronizer(
    sv: &mut String,
    signal_name: &str,
    element_width: &str,
    array_dim: &str,
    stages: usize,
) {
    // Generate intermediate stage registers
    // (* ASYNC_REG = "TRUE" *) attribute helps tools recognize CDC chain
    for i in 0..stages {
        sv.push_str("    (* ASYNC_REG = \"TRUE\" *)\n");
        sv.push_str(&format!(
            "    reg {}{}_sync_{}{};\n",
            element_width, signal_name, i, array_dim
        ));
    }

    // The final output signal is the last sync stage
    sv.push_str(&format!(
        "    wire {}{}{} = {}_sync_{};\n",
        element_width,
        signal_name,
        array_dim,
        signal_name,
        stages - 1
    ));
}

/// Generate Gray code synchronizer for multi-bit CDC
/// Converts binary -> gray (source domain), syncs gray, converts gray -> binary (dest domain)
fn generate_gray_code_synchronizer(
    sv: &mut String,
    signal_name: &str,
    element_width: &str,
    array_dim: &str,
    data_width: usize,
    stages: usize,
) {
    let width_m1 = data_width - 1;

    // Binary input (source domain)
    sv.push_str(&format!(
        "    wire {}{}_bin_in{};\n",
        element_width, signal_name, array_dim
    ));

    // Gray-coded version (source domain)
    sv.push_str(&format!(
        "    wire {}{}_gray{};\n",
        element_width, signal_name, array_dim
    ));

    // Synchronizer stages for gray code
    for i in 0..stages {
        sv.push_str("    (* ASYNC_REG = \"TRUE\" *)\n");
        sv.push_str(&format!(
            "    reg {}{}_gray_sync_{}{};\n",
            element_width, signal_name, i, array_dim
        ));
    }

    // Binary output (destination domain)
    sv.push_str(&format!(
        "    wire {}{}{};\n",
        element_width, signal_name, array_dim
    ));

    // Binary to Gray conversion: gray = bin ^ (bin >> 1)
    sv.push_str(&format!(
        "    assign {}_gray = {}_bin_in ^ ({}_bin_in >> 1);\n",
        signal_name, signal_name, signal_name
    ));

    // Gray to Binary conversion (XOR chain)
    // For n-bit: bin[n-1] = gray[n-1], bin[i] = bin[i+1] ^ gray[i]
    sv.push_str("    // Gray to binary decoder\n");

    if data_width <= 8 {
        // Inline decoder for small widths
        sv.push_str(&format!(
            "    assign {}[{}] = {}_gray_sync_{}[{}];\n",
            signal_name,
            width_m1,
            signal_name,
            stages - 1,
            width_m1
        ));
        for i in (0..width_m1).rev() {
            sv.push_str(&format!(
                "    assign {}[{}] = {}[{}] ^ {}_gray_sync_{}[{}];\n",
                signal_name,
                i,
                signal_name,
                i + 1,
                signal_name,
                stages - 1,
                i
            ));
        }
    } else {
        // Generate-based decoder for larger widths
        sv.push_str(&format!(
            "    // Use generate block for {}-bit gray decoder\n",
            data_width
        ));
        sv.push_str(&format!(
            "    assign {} = gray_to_bin({}_gray_sync_{});\n",
            signal_name,
            signal_name,
            stages - 1
        ));
    }
}

/// Generate pulse synchronizer for edge detection across domains
fn generate_pulse_synchronizer(
    sv: &mut String,
    signal_name: &str,
    element_width: &str,
    array_dim: &str,
    stages: usize,
) {
    // Toggle flip-flop in source domain
    sv.push_str(&format!("    reg {}_toggle{};\n", signal_name, array_dim));

    // Synchronizer chain for toggle
    for i in 0..stages {
        sv.push_str("    (* ASYNC_REG = \"TRUE\" *)\n");
        sv.push_str(&format!(
            "    reg {}_toggle_sync_{}{};\n",
            signal_name, i, array_dim
        ));
    }

    // Previous value for edge detection
    sv.push_str(&format!(
        "    reg {}_toggle_prev{};\n",
        signal_name, array_dim
    ));

    // Output pulse (XOR of synced toggle and previous)
    sv.push_str(&format!(
        "    wire {}{}{} = {}_toggle_sync_{} ^ {}_toggle_prev;\n",
        element_width,
        signal_name,
        array_dim,
        signal_name,
        stages - 1,
        signal_name
    ));
}

/// Generate handshake synchronizer signals
fn generate_handshake_synchronizer(
    sv: &mut String,
    signal_name: &str,
    element_width: &str,
    array_dim: &str,
    stages: usize,
) {
    // Request signal (source domain)
    sv.push_str(&format!("    reg {}_req{};\n", signal_name, array_dim));

    // Request synchronizer chain (into destination domain)
    for i in 0..stages {
        sv.push_str("    (* ASYNC_REG = \"TRUE\" *)\n");
        sv.push_str(&format!(
            "    reg {}_req_sync_{}{};\n",
            signal_name, i, array_dim
        ));
    }

    // Acknowledge signal (destination domain)
    sv.push_str(&format!("    reg {}_ack{};\n", signal_name, array_dim));

    // Acknowledge synchronizer chain (back to source domain)
    for i in 0..stages {
        sv.push_str("    (* ASYNC_REG = \"TRUE\" *)\n");
        sv.push_str(&format!(
            "    reg {}_ack_sync_{}{};\n",
            signal_name, i, array_dim
        ));
    }

    // Data holding register (stable during handshake)
    sv.push_str(&format!(
        "    reg {}{}_data{};\n",
        element_width, signal_name, array_dim
    ));

    // Output is the data register
    sv.push_str(&format!(
        "    wire {}{}{} = {}_data;\n",
        element_width, signal_name, array_dim, signal_name
    ));
}

// ============================================================================
// Power Intent Code Generation
// ============================================================================

/// Generate power intent synthesis attributes for a signal
///
/// This generates vendor-specific synthesis attributes that help EDA tools
/// recognize signals that require special power handling:
/// - Retention registers: preserved during power-down
/// - Isolation cells: clamp outputs when source domain is off
/// - Level shifters: voltage domain crossings
fn generate_power_attributes(sv: &mut String, signal_name: &str, power_config: &PowerConfig) {
    // Track if we generated any power-related comments
    let mut has_power_comment = false;

    // Generate retention attributes if configured
    if let Some(retention) = &power_config.retention {
        if !has_power_comment {
            sv.push_str(&format!("    // Power Intent: {}\n", signal_name));
            has_power_comment = true;
        }

        // Xilinx/AMD: RETAIN attribute for UltraScale+ retention flops
        sv.push_str("    (* RETAIN = \"TRUE\" *)\n");
        // Intel/Altera: preserve attribute
        sv.push_str("    (* preserve = \"true\" *)\n");
        // Generic: DONT_TOUCH prevents optimization of retention logic
        sv.push_str("    (* DONT_TOUCH = \"TRUE\" *)\n");

        // Add retention strategy as comment
        let strategy_str = match retention.strategy {
            skalp_frontend::hir::RetentionStrategy::Auto => "auto",
            skalp_frontend::hir::RetentionStrategy::BalloonLatch => "balloon_latch",
            skalp_frontend::hir::RetentionStrategy::ShadowRegister => "shadow_register",
        };
        sv.push_str(&format!("    // Retention strategy: {}\n", strategy_str));

        // Add save/restore signals if specified
        if let Some(save_sig) = &retention.save_signal {
            sv.push_str(&format!("    // Save signal: {}\n", save_sig));
        }
        if let Some(restore_sig) = &retention.restore_signal {
            sv.push_str(&format!("    // Restore signal: {}\n", restore_sig));
        }
    }

    // Generate isolation attributes if configured (comment header only, logic generated separately)
    if let Some(isolation) = &power_config.isolation {
        if !has_power_comment {
            sv.push_str(&format!("    // Power Intent: {}\n", signal_name));
            has_power_comment = true;
        }

        let clamp_str = match isolation.clamp {
            IsolationClamp::Low => "low (0)",
            IsolationClamp::High => "high (1)",
            IsolationClamp::Latch => "latch (hold)",
        };
        sv.push_str(&format!("    // Isolation: clamp={}\n", clamp_str));

        if let Some(enable) = &isolation.enable_signal {
            let polarity = if isolation.active_high {
                "active-high"
            } else {
                "active-low"
            };
            sv.push_str(&format!(
                "    // Isolation enable: {} ({})\n",
                enable, polarity
            ));
        }
    }

    // Generate level shifter attributes if configured
    if let Some(level_shift) = &power_config.level_shift {
        if !has_power_comment {
            sv.push_str(&format!("    // Power Intent: {}\n", signal_name));
            // has_power_comment = true;  // Uncomment if more attributes added after
        }

        let shift_type = match level_shift.shifter_type {
            skalp_frontend::hir::LevelShifterType::Auto => "auto",
            skalp_frontend::hir::LevelShifterType::LowToHigh => "low_to_high",
            skalp_frontend::hir::LevelShifterType::HighToLow => "high_to_low",
        };
        sv.push_str(&format!("    // Level shifter: type={}\n", shift_type));

        if let Some(from) = &level_shift.from_domain {
            sv.push_str(&format!("    // Level shift from domain: {}\n", from));
        }
        if let Some(to) = &level_shift.to_domain {
            sv.push_str(&format!("    // Level shift to domain: {}\n", to));
        }

        // Add synthesis hint for level shifter cell insertion
        sv.push_str("    (* LEVEL_SHIFTER = \"TRUE\" *)\n");
    }
}

/// Generate isolation logic for a signal
///
/// Isolation cells clamp the output of a powered-down domain to a safe value.
/// This generates a mux-based isolation cell that can be recognized by synthesis tools.
fn generate_isolation_logic(
    sv: &mut String,
    signal_name: &str,
    element_width: &str,
    array_dim: &str,
    isolation: &skalp_frontend::hir::IsolationConfig,
) {
    // Only generate explicit isolation logic if we have an enable signal
    if let Some(enable) = &isolation.enable_signal {
        let isolated_name = format!("{}_isolated", signal_name);

        // Determine clamp value based on clamp type
        let clamp_value = match isolation.clamp {
            IsolationClamp::Low => "'0".to_string(),  // All zeros
            IsolationClamp::High => "'1".to_string(), // All ones (SystemVerilog '1 fills width)
            IsolationClamp::Latch => {
                // For latch mode, we keep the previous value (no explicit clamp logic)
                sv.push_str(&format!(
                    "    // Latch isolation: {} retains value when {} is asserted\n",
                    signal_name, enable
                ));
                return;
            }
        };

        // Generate isolation cell with DONT_TOUCH to prevent optimization
        sv.push_str("    (* DONT_TOUCH = \"TRUE\" *)\n");
        sv.push_str(&format!(
            "    wire {}{}_isolated{};\n",
            element_width, signal_name, array_dim
        ));

        // Generate the isolation mux
        // When isolation is active (enable asserted), output clamp value
        // Otherwise, pass through the signal
        if isolation.active_high {
            // Active high: enable=1 means isolate (clamp)
            sv.push_str(&format!(
                "    assign {} = {} ? {} : {};\n",
                isolated_name, enable, clamp_value, signal_name
            ));
        } else {
            // Active low: enable=0 means isolate (clamp)
            sv.push_str(&format!(
                "    assign {} = {} ? {} : {};\n",
                isolated_name, enable, signal_name, clamp_value
            ));
        }
    }
}

/// Generate SystemVerilog wrapper module for vendor IP
///
/// For vendor IP entities, we generate a module that wraps the vendor IP core
/// with the entity's ports connected directly to the IP.
fn generate_vendor_ip_wrapper(
    mir_module: &Module,
    vendor_config: &VendorIpConfig,
) -> Result<String> {
    let mut sv = String::new();

    // Add header comment
    let vendor_name = match vendor_config.vendor {
        VendorType::Xilinx => "Xilinx (AMD)",
        VendorType::Intel => "Intel (Altera)",
        VendorType::Lattice => "Lattice",
        VendorType::Generic => "Generic",
    };

    sv.push_str(&format!(
        "// Vendor IP Wrapper: {} ({})\n",
        vendor_config.ip_name, vendor_name
    ));
    if let Some(ref lib) = vendor_config.library {
        sv.push_str(&format!("// Library: {}\n", lib));
    }
    if let Some(ref ver) = vendor_config.version {
        sv.push_str(&format!("// Version: {}\n", ver));
    }
    sv.push_str("// Generated by Skalp - do not edit manually\n\n");

    // Module header with parameters
    sv.push_str(&format!("module {} ", mir_module.name));

    // Generate parameter list if any
    if !mir_module.parameters.is_empty() {
        sv.push_str("#(\n");
        let mut params = Vec::new();
        for param in &mir_module.parameters {
            let param_str = match &param.param_type {
                skalp_mir::GenericParameterType::Type
                | skalp_mir::GenericParameterType::Const(_)
                | skalp_mir::GenericParameterType::Width => {
                    if let Some(default) = &param.default {
                        format!("    parameter {} = {}", param.name, format_value(default))
                    } else {
                        format!("    parameter {} = 32", param.name)
                    }
                }
                skalp_mir::GenericParameterType::ClockDomain
                | skalp_mir::GenericParameterType::PowerDomain
                | skalp_mir::GenericParameterType::Intent => continue,
            };
            params.push(param_str);
        }
        sv.push_str(&params.join(",\n"));
        sv.push_str("\n) ");
    }

    sv.push_str("(\n");

    // Generate port list
    let mut ports = Vec::new();
    for port in &mir_module.ports {
        let direction = match port.direction {
            skalp_mir::PortDirection::Input => "input",
            skalp_mir::PortDirection::Output => "output",
            skalp_mir::PortDirection::InOut => "inout",
        };

        let (element_width, array_dim) = get_type_dimensions(&port.port_type);
        ports.push(format!(
            "    {} {}{}{}",
            direction, element_width, port.name, array_dim
        ));
    }

    if !ports.is_empty() {
        sv.push_str(&ports.join(",\n"));
        sv.push('\n');
    }

    sv.push_str(");\n\n");

    // Generate vendor IP instantiation
    if vendor_config.black_box {
        // Black-box: just declare as a placeholder comment
        sv.push_str("    // Black-box IP - implement externally\n");
        sv.push_str(&format!(
            "    // Instantiate {} with port connections\n",
            vendor_config.ip_name
        ));
    } else {
        // Generate actual instantiation
        sv.push_str(&format!(
            "    // Instantiate vendor IP: {}\n",
            vendor_config.ip_name
        ));

        // For Xilinx IP, add XPM library prefix if applicable
        let ip_module_name = if vendor_config.vendor == VendorType::Xilinx {
            if let Some(ref lib) = vendor_config.library {
                if lib == "xpm" && !vendor_config.ip_name.starts_with("xpm_") {
                    format!("xpm_{}", vendor_config.ip_name)
                } else {
                    vendor_config.ip_name.clone()
                }
            } else {
                vendor_config.ip_name.clone()
            }
        } else {
            vendor_config.ip_name.clone()
        };

        sv.push_str(&format!("    {} ", ip_module_name));

        // Add IP-specific parameters from vendor_ip attribute
        // These are passed through as-is to the vendor IP (e.g., FIFO_DEPTH = 1024)
        if !vendor_config.parameters.is_empty() {
            sv.push_str("#(\n");
            let param_connections: Vec<String> = vendor_config
                .parameters
                .iter()
                .map(|(key, value)| format!("        .{}({})", key, value))
                .collect();
            sv.push_str(&param_connections.join(",\n"));
            sv.push_str("\n    ) ");
        } else if !mir_module.parameters.is_empty() {
            // Fallback to module generic parameters if no IP-specific params
            sv.push_str("#(\n");
            let param_connections: Vec<String> = mir_module
                .parameters
                .iter()
                .filter_map(|p| {
                    // Skip clock domain, power domain, and intent parameters
                    match p.param_type {
                        skalp_mir::GenericParameterType::ClockDomain
                        | skalp_mir::GenericParameterType::PowerDomain
                        | skalp_mir::GenericParameterType::Intent => None,
                        _ => Some(format!("        .{}({})", p.name, p.name)),
                    }
                })
                .collect();
            sv.push_str(&param_connections.join(",\n"));
            sv.push_str("\n    ) ");
        }

        // Instance name
        sv.push_str(&format!("{}_inst (\n", mir_module.name));

        // Build a map for port aliasing (entity_port -> ip_port)
        let port_mapping: std::collections::HashMap<&str, &str> = vendor_config
            .port_map
            .iter()
            .map(|(entity, ip)| (entity.as_str(), ip.as_str()))
            .collect();

        // Connect ports (entity ports to IP ports, with optional aliasing)
        let mut all_connections: Vec<String> = mir_module
            .ports
            .iter()
            .map(|p| {
                // Use mapped IP port name if available, otherwise use entity port name
                let ip_port_name = match port_mapping.get(p.name.as_str()) {
                    Some(mapped) => *mapped,
                    None => p.name.as_str(),
                };
                format!("        .{}({})", ip_port_name, p.name)
            })
            .collect();

        // Add tie-low connections (unused IP inputs tied to 0)
        for port in &vendor_config.tie_low {
            all_connections.push(format!("        .{}(1'b0)", port));
        }

        // Add tie-high connections (unused IP inputs tied to 1)
        for port in &vendor_config.tie_high {
            all_connections.push(format!("        .{}(1'b1)", port));
        }

        // Add unconnected ports (unused IP outputs left open)
        for port in &vendor_config.unconnected {
            all_connections.push(format!("        .{}()", port));
        }

        sv.push_str(&all_connections.join(",\n"));

        sv.push_str("\n    );\n");
    }

    sv.push_str("\nendmodule\n");

    Ok(sv)
}
