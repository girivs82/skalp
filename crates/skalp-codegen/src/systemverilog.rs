//! SystemVerilog code generation from MIR
//!
//! This module generates proper SystemVerilog code from MIR,
//! preserving sequential logic, event blocks, and assignments.

use anyhow::Result;
use skalp_lir::LirDesign;
use skalp_mir::mir::PriorityMux;
use skalp_mir::type_width; // Use shared type width calculations
use skalp_mir::{
    Assignment, AssignmentKind, DataType, EdgeType, EnumType, Mir, Module, Process, ProcessKind,
    Statement, StructType,
};
use std::collections::{HashMap, HashSet};

/// Generate SystemVerilog from MIR and LIR
pub fn generate_systemverilog_from_mir(mir: &Mir, lir: &LirDesign) -> Result<String> {
    let mut sv = String::new();

    // Add header comment
    sv.push_str("// Generated by SKALP compiler\n");
    sv.push_str(&format!("// Design: {}\n", mir.name));
    sv.push('\n');

    // Generate each module, skipping ONLY generic templates that have concrete instantiations
    // Strategy:
    // 1. Modules with generic/expression-based types (unresolved) are always skipped (not valid SystemVerilog)
    // 2. Modules with parameters but concrete types can be emitted as parameterized SystemVerilog modules
    // 3. Concrete modules (no parameters, all types resolved) are always emitted
    for (mir_module, lir_module) in mir.modules.iter().zip(lir.modules.iter()) {
        // Skip modules with unresolved/generic types - these cannot be converted to SystemVerilog
        if has_generic_types(mir_module) {
            continue;
        }

        // Emit all modules with concrete types (even if they have parameters)
        // SystemVerilog supports parameterized modules
        sv.push_str(&generate_module(mir_module, lir_module, mir)?);
    }

    Ok(sv)
}

/// Check if a module has any generic/expression-based types in its ports
/// Generic types include NatExpr, BitExpr, IntExpr, LogicExpr which contain unresolved expressions
fn has_generic_types(module: &Module) -> bool {
    module
        .ports
        .iter()
        .any(|port| is_generic_type(&port.port_type))
}

/// Check if a data type is generic (contains unresolved expressions)
fn is_generic_type(data_type: &DataType) -> bool {
    match data_type {
        // Expression-based types are generic
        DataType::NatExpr { .. }
        | DataType::BitExpr { .. }
        | DataType::IntExpr { .. }
        | DataType::LogicExpr { .. } => true,
        // Parameter-based types are also generic
        DataType::NatParam { .. }
        | DataType::BitParam { .. }
        | DataType::IntParam { .. }
        | DataType::LogicParam { .. } => true,
        // Recursively check composite types
        DataType::Array(element_type, _) => is_generic_type(element_type),
        DataType::Struct(struct_type) => struct_type
            .fields
            .iter()
            .any(|field| is_generic_type(&field.field_type)),
        DataType::Union(union_type) => union_type
            .fields
            .iter()
            .any(|field| is_generic_type(&field.field_type)),
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => is_generic_type(element_type),
        // All other types are concrete
        _ => false,
    }
}

/// Generate a single SystemVerilog module
fn generate_module(
    mir_module: &Module,
    lir_module: &skalp_lir::LirModule,
    mir: &Mir,
) -> Result<String> {
    let mut sv = String::new();

    // Collect all unique struct and enum types from ports and signals
    let mut struct_types: HashSet<String> = HashSet::new();
    let mut enum_types: HashSet<String> = HashSet::new();

    collect_types_from_module(mir_module, &mut struct_types, &mut enum_types);

    // Generate typedefs for structs and enums
    sv.push_str(&generate_typedefs(mir_module, &struct_types, &enum_types));

    // Module header with parameters
    sv.push_str(&format!("module {} ", mir_module.name));

    // Generate parameter list if any
    if !mir_module.parameters.is_empty() {
        sv.push_str("#(\n");
        let mut params = Vec::new();
        for param in &mir_module.parameters {
            let param_str = match &param.param_type {
                skalp_mir::GenericParameterType::Type => {
                    // Type parameters become Verilog parameters
                    if let Some(default) = &param.default {
                        format!("    parameter {} = {}", param.name, format_value(default))
                    } else {
                        format!("    parameter {} = 8", param.name) // Default to 8 if no default given
                    }
                }
                skalp_mir::GenericParameterType::Const(_) => {
                    // Const parameters become localparam
                    if let Some(default) = &param.default {
                        format!("    parameter {} = {}", param.name, format_value(default))
                    } else {
                        format!("    parameter {}", param.name)
                    }
                }
                skalp_mir::GenericParameterType::Width => {
                    // Width parameters are regular parameters
                    if let Some(default) = &param.default {
                        format!("    parameter {} = {}", param.name, format_value(default))
                    } else {
                        format!("    parameter {} = 32", param.name)
                    }
                }
                skalp_mir::GenericParameterType::ClockDomain => {
                    // Clock domain parameters are not emitted as Verilog parameters
                    continue;
                }
                skalp_mir::GenericParameterType::Intent => {
                    // Intent parameters are not emitted as Verilog parameters
                    // They are used for HLS optimization and synthesis directives
                    continue;
                }
            };
            params.push(param_str);
        }
        sv.push_str(&params.join(",\n"));
        sv.push_str("\n) ");
    }

    sv.push_str("(\n");

    // Generate port list (MIR already has flattened ports)
    let mut ports = Vec::new();
    for port in &mir_module.ports {
        let direction = match port.direction {
            skalp_mir::PortDirection::Input => "input",
            skalp_mir::PortDirection::Output => "output",
            skalp_mir::PortDirection::InOut => "inout",
        };

        let (element_width, array_dim) = get_type_dimensions(&port.port_type);
        ports.push(format!(
            "    {} {}{}{}",
            direction, element_width, port.name, array_dim
        ));
    }

    if !ports.is_empty() {
        sv.push_str(&ports.join(",\n"));
        sv.push('\n');
    }

    sv.push_str(");\n\n");

    // Generate internal signal declarations (MIR already has flattened signals)
    for signal in &mir_module.signals {
        let (element_width, array_dim) = get_type_dimensions(&signal.signal_type);

        // Determine if it's a reg or wire based on usage
        let signal_type = if is_register(signal, mir_module) {
            "reg"
        } else {
            "wire"
        };

        // Format: wire [element_width] name [array_dim];
        sv.push_str(&format!(
            "    {} {}{}{}",
            signal_type, element_width, signal.name, array_dim
        ));

        // Add initial value if present
        if let Some(init) = &signal.initial {
            sv.push_str(&format!(" = {}", format_value(init)));
        }

        sv.push_str(";\n");
    }

    if !mir_module.signals.is_empty() {
        sv.push('\n');
    }

    // Generate internal variable declarations with collision detection
    // Track which names have been declared to detect collisions
    let mut declared_variable_names: HashMap<String, skalp_mir::VariableId> = HashMap::new();
    let mut variable_unique_names: HashMap<skalp_mir::VariableId, String> = HashMap::new();

    for variable in &mir_module.variables {
        let (element_width, array_dim) = get_type_dimensions(&variable.var_type);

        // Check if this variable name has already been declared
        let unique_name = if declared_variable_names.contains_key(&variable.name) {
            // Collision detected - use unique name with variable ID suffix
            format!("{}_{}", variable.name, variable.id.0)
        } else {
            // First occurrence - use original name and track it
            declared_variable_names.insert(variable.name.clone(), variable.id);
            variable.name.clone()
        };

        // Store the unique name mapping for use in variable references
        variable_unique_names.insert(variable.id, unique_name.clone());

        // Variables are always logic (combinational variables in processes)
        sv.push_str(&format!(
            "    logic {}{}{}",
            element_width, unique_name, array_dim
        ));

        // Add initial value if present
        if let Some(init) = &variable.initial {
            sv.push_str(&format!(" = {}", format_value(init)));
        }

        sv.push_str(";\n");
    }

    if !mir_module.variables.is_empty() {
        sv.push('\n');
    }

    // Generate continuous assignments - expand struct assignments
    // Track assigned targets to avoid duplicates from match arm let bindings
    let mut assigned_targets: HashSet<String> = HashSet::new();
    let mut assignment_count = 0;

    for assign in &mir_module.assignments {
        eprintln!(
            "[CODEGEN_DEBUG] Assignment RHS type: {:?}",
            std::mem::discriminant(&assign.rhs)
        );
        let expanded = expand_struct_assignment(&assign.lhs, &assign.rhs, mir_module);
        for (lhs_str, rhs_str) in expanded {
            // Check if this target has already been assigned
            if assigned_targets.contains(&lhs_str) {
                // Skip duplicate assignment (from duplicate let bindings in match arms)
                continue;
            }

            assigned_targets.insert(lhs_str.clone());
            eprintln!(
                "[CODEGEN_DEBUG] Generating assignment: {} = {}",
                lhs_str, rhs_str
            );
            sv.push_str(&format!("    assign {} = {};\n", lhs_str, rhs_str));
            assignment_count += 1;
        }
    }

    if assignment_count > 0 {
        sv.push('\n');
    }

    // Generate module instances
    for instance in &mir_module.instances {
        sv.push_str(&generate_instance(instance, mir_module, mir)?);
        sv.push('\n');
    }

    // Generate processes (always blocks)
    for process in &mir_module.processes {
        sv.push_str(&generate_process(process, mir_module)?);
        sv.push('\n');
    }

    sv.push_str("endmodule\n");
    Ok(sv)
}

/// Generate a module instance
fn generate_instance(
    instance: &skalp_mir::ModuleInstance,
    parent_module: &Module,
    mir: &Mir,
) -> Result<String> {
    let mut sv = String::new();

    // Look up the module being instantiated to get its name and ports
    let instantiated_module = mir
        .modules
        .iter()
        .find(|m| m.id == instance.module)
        .ok_or_else(|| {
            anyhow::anyhow!(
                "Module ID {:?} not found for instance {}",
                instance.module,
                instance.name
            )
        })?;

    // Start with module name
    sv.push_str(&format!("    {} ", instantiated_module.name));

    // Add parameter overrides if any
    if !instance.parameters.is_empty() {
        sv.push_str("#(\n");
        let params: Vec<String> = instance
            .parameters
            .iter()
            .map(|(name, value)| format!("        .{}({})", name, format_value(value)))
            .collect();
        sv.push_str(&params.join(",\n"));
        sv.push_str("\n    ) ");
    }

    // Instance name
    sv.push_str(&format!("{} (\n", instance.name));

    // Port connections - expand struct/vector ports into individual flattened connections
    let mut connections: Vec<String> = Vec::new();

    for (port_name, expr) in &instance.connections {
        // Look up the port in the instantiated module to get its type
        let port = instantiated_module
            .ports
            .iter()
            .find(|p| p.name == *port_name);

        if let Some(port) = port {
            // Port found by exact name - expand based on its type
            let expanded_connections =
                expand_port_connection(port_name, &port.port_type, expr, parent_module);

            // Format each expanded connection
            for (port_field, signal_expr) in expanded_connections {
                connections.push(format!("        .{}({})", port_field, signal_expr));
            }
        } else {
            // Port not found by exact name - check if there are flattened ports with this prefix
            // This handles the case where HIR had "vertex" but MIR flattened it to
            // "vertex_position_x", "vertex_position_y", etc.
            // We need to distinguish between scalar ports like "vertex_valid" and
            // flattened struct fields like "vertex_position_x"
            let prefix = format!("{}_", port_name);
            let flattened_ports: Vec<_> = instantiated_module
                .ports
                .iter()
                .filter(|p| {
                    // Port must start with prefix
                    if !p.name.starts_with(&prefix) {
                        return false;
                    }
                    let suffix = &p.name[port_name.len()..];
                    // Check if this is a flattened struct/vector field
                    // Two patterns indicate flattening:
                    // 1. Nested struct: base_field_subfield (2+ underscores in suffix)
                    // 2. Vector components: base_x, base_y, base_z, base_w (1 underscore + component)
                    let underscore_count = suffix.chars().filter(|&c| c == '_').count();
                    if underscore_count >= 2 {
                        // Nested struct field
                        true
                    } else if underscore_count == 1 {
                        // Check if it's a vector component (_x, _y, _z, _w)
                        suffix.ends_with("_x")
                            || suffix.ends_with("_y")
                            || suffix.ends_with("_z")
                            || suffix.ends_with("_w")
                    } else {
                        false
                    }
                })
                .collect();

            if !flattened_ports.is_empty() {
                // Found flattened ports - we need to infer the structure and expand
                // Get the signal name from the expression
                if let skalp_mir::Expression::Ref(lvalue) = expr {
                    let signal_full_name = format_lvalue_with_context(lvalue, parent_module);

                    // The signal might be referencing a flattened field (like geom_vertex_position_x)
                    // We need to extract the base name (like geom_vertex)
                    // Check if the signal name has a suffix matching the first flattened port
                    let first_port_suffix = &flattened_ports[0].name[port_name.len()..];
                    let signal_base_name = if signal_full_name.ends_with(first_port_suffix) {
                        // Strip the suffix to get the base name
                        &signal_full_name[..signal_full_name.len() - first_port_suffix.len()]
                    } else {
                        // Signal doesn't have the expected suffix, use as-is
                        &signal_full_name
                    };

                    // For each flattened port, construct a matching signal name
                    for port in flattened_ports {
                        // Extract the suffix after the port_name prefix
                        let suffix = &port.name[port_name.len()..]; // includes the leading _
                        let signal_name = format!("{}{}", signal_base_name, suffix);
                        connections.push(format!("        .{}({})", port.name, signal_name));
                    }
                } else {
                    // Expression is not a simple reference, can't expand
                    // Use simple connection and hope for the best
                    connections.push(format!(
                        "        .{}({})",
                        port_name,
                        format_expression_with_context(expr, parent_module)
                    ));
                }
            } else {
                // No ports found at all - use simple connection
                connections.push(format!(
                    "        .{}({})",
                    port_name,
                    format_expression_with_context(expr, parent_module)
                ));
            }
        }
    }

    sv.push_str(&connections.join(",\n"));
    sv.push_str("\n    );\n");

    Ok(sv)
}

/// Generate an always block from a process
fn generate_process(process: &Process, module: &Module) -> Result<String> {
    let mut sv = String::new();

    // Generate always block header
    match process.kind {
        ProcessKind::Sequential => {
            sv.push_str("    always_ff @(");
            sv.push_str(&format_sensitivity(&process.sensitivity, module));
            sv.push_str(") begin\n");
        }
        ProcessKind::Combinational => {
            sv.push_str("    always_comb begin\n");
        }
        ProcessKind::General => {
            sv.push_str("    always @(");
            sv.push_str(&format_sensitivity(&process.sensitivity, module));
            sv.push_str(") begin\n");
        }
    }

    // Generate body statements
    for statement in &process.body.statements {
        sv.push_str(&generate_statement(statement, module, 2)?);
    }

    sv.push_str("    end\n");
    Ok(sv)
}

/// Generate a statement
fn generate_statement(stmt: &Statement, module: &Module, indent_level: usize) -> Result<String> {
    let indent = "    ".repeat(indent_level);
    let mut sv = String::new();

    match stmt {
        Statement::Assignment(assign) => {
            let op = match assign.kind {
                AssignmentKind::NonBlocking => "<=",
                AssignmentKind::Blocking => "=",
            };
            sv.push_str(&format!(
                "{}{} {} {};\n",
                indent,
                format_lvalue_with_context(&assign.lhs, module),
                op,
                format_expression_with_context(&assign.rhs, module)
            ));
        }
        Statement::If(if_stmt) => {
            sv.push_str(&format!(
                "{}if ({}) begin\n",
                indent,
                format_expression_with_context(&if_stmt.condition, module)
            ));
            for s in &if_stmt.then_block.statements {
                sv.push_str(&generate_statement(s, module, indent_level + 1)?);
            }
            sv.push_str(&format!("{}end", indent));

            if let Some(else_block) = &if_stmt.else_block {
                sv.push_str(" else begin\n");
                for s in &else_block.statements {
                    sv.push_str(&generate_statement(s, module, indent_level + 1)?);
                }
                sv.push_str(&format!("{}end", indent));
            }
            sv.push('\n');
        }
        Statement::Case(case_stmt) => {
            sv.push_str(&format!(
                "{}case ({})\n",
                indent,
                format_expression_with_context(&case_stmt.expr, module)
            ));

            // Generate case items
            for item in &case_stmt.items {
                let values = item
                    .values
                    .iter()
                    .map(|v| format_expression_with_context(v, module))
                    .collect::<Vec<_>>()
                    .join(", ");
                sv.push_str(&format!("    {}{}: begin\n", indent, values));

                for s in &item.block.statements {
                    sv.push_str(&generate_statement(s, module, indent_level + 2)?);
                }
                sv.push_str(&format!("    {}end\n", indent));
            }

            // Generate default case if present
            if let Some(default_block) = &case_stmt.default {
                sv.push_str(&format!("    {}default: begin\n", indent));
                for s in &default_block.statements {
                    sv.push_str(&generate_statement(s, module, indent_level + 2)?);
                }
                sv.push_str(&format!("    {}end\n", indent));
            }

            sv.push_str(&format!("{}endcase\n", indent));
        }
        Statement::Loop(_) => {
            // TODO: Implement loop statement generation
            sv.push_str(&format!("{}// TODO: loop statement\n", indent));
        }
        Statement::Block(block) => {
            sv.push_str(&format!("{}begin\n", indent));
            for s in &block.statements {
                sv.push_str(&generate_statement(s, module, indent_level + 1)?);
            }
            sv.push_str(&format!("{}end\n", indent));
        }
        Statement::ResolvedConditional(resolved) => {
            // Generate as a single ternary assignment - synthesis-resolved form
            let op = match resolved.kind {
                AssignmentKind::NonBlocking => "<=",
                AssignmentKind::Blocking => "=",
            };

            // Build nested ternary expression from priority mux
            let ternary_expr = build_ternary_expression(&resolved.resolved, module);
            sv.push_str(&format!(
                "{}{} {} {};\n",
                indent,
                format_lvalue_with_context(&resolved.target, module),
                op,
                ternary_expr
            ));
        }
    }

    Ok(sv)
}

/// Build nested ternary expression from priority mux
fn build_ternary_expression(mux: &PriorityMux, module: &Module) -> String {
    let mut result = format_expression_with_context(&mux.default, module);

    // Build ternary chain from right to left (lowest to highest priority)
    for case in mux.cases.iter().rev() {
        result = format!(
            "({}) ? ({}) : ({})",
            format_expression_with_context(&case.condition, module),
            format_expression_with_context(&case.value, module),
            result
        );
    }

    result
}

/// Format sensitivity list
fn format_sensitivity(sensitivity: &skalp_mir::SensitivityList, module: &Module) -> String {
    match sensitivity {
        skalp_mir::SensitivityList::Always => "*".to_string(),
        skalp_mir::SensitivityList::Level(signals) => signals
            .iter()
            .map(|s| format_lvalue_with_context(s, module))
            .collect::<Vec<_>>()
            .join(" or "),
        skalp_mir::SensitivityList::Edge(edges) => edges
            .iter()
            .map(|e| {
                let edge_str = match e.edge {
                    EdgeType::Rising => "posedge",
                    EdgeType::Falling => "negedge",
                    EdgeType::Both => "",
                    EdgeType::Active => "",
                    EdgeType::Inactive => "",
                };
                if edge_str.is_empty() {
                    format_lvalue_with_context(&e.signal, module)
                } else {
                    format!(
                        "{} {}",
                        edge_str,
                        format_lvalue_with_context(&e.signal, module)
                    )
                }
            })
            .collect::<Vec<_>>()
            .join(" or "),
    }
}

/// Format an lvalue with module context for name lookup
fn format_lvalue_with_context(lvalue: &skalp_mir::LValue, module: &Module) -> String {
    match lvalue {
        skalp_mir::LValue::Signal(id) => {
            // Find the signal name by ID
            module
                .signals
                .iter()
                .find(|s| s.id == *id)
                .map(|s| s.name.clone())
                .unwrap_or_else(|| format!("signal_{}", id.0))
        }
        skalp_mir::LValue::Variable(id) => {
            // Find the variable by ID
            let variable = module.variables.iter().find(|v| v.id == *id);

            if let Some(var) = variable {
                // Check if this variable is the first one with this name
                // The first occurrence keeps the original name, subsequent ones get suffixed
                let first_with_name = module.variables.iter().find(|v| v.name == var.name);

                if let Some(first_var) = first_with_name {
                    if first_var.id == *id {
                        // This is the first variable with this name - use original name
                        var.name.clone()
                    } else {
                        // This is not the first - check if there are multiple with same name
                        let same_name_count = module
                            .variables
                            .iter()
                            .filter(|v| v.name == var.name)
                            .count();

                        if same_name_count > 1 {
                            // Name collision exists - use unique name with ID suffix
                            format!("{}_{}", var.name, id.0)
                        } else {
                            // No collision (shouldn't happen, but handle it)
                            var.name.clone()
                        }
                    }
                } else {
                    // Shouldn't happen, but fallback to original name
                    var.name.clone()
                }
            } else {
                // Variable not found - use fallback
                format!("var_{}", id.0)
            }
        }
        skalp_mir::LValue::Port(id) => {
            // Find the port name by ID
            for port in &module.ports {}
            module
                .ports
                .iter()
                .find(|p| p.id == *id)
                .map(|p| p.name.clone())
                .unwrap_or_else(|| format!("port_{}", id.0))
        }
        skalp_mir::LValue::BitSelect { base, index } => {
            format!(
                "{}[{}]",
                format_lvalue_with_context(base, module),
                format_expression_with_context(index, module)
            )
        }
        skalp_mir::LValue::RangeSelect { base, high, low } => {
            format!(
                "{}[{}:{}]",
                format_lvalue_with_context(base, module),
                format_expression_with_context(high, module),
                format_expression_with_context(low, module)
            )
        }
        skalp_mir::LValue::Concat(lvalues) => {
            let parts: Vec<_> = lvalues
                .iter()
                .map(|lv| format_lvalue_with_context(lv, module))
                .collect();
            format!("{{{}}}", parts.join(", "))
        }
    }
}

/// Format an lvalue (fallback without context)
fn format_lvalue(lvalue: &skalp_mir::LValue) -> String {
    match lvalue {
        skalp_mir::LValue::Signal(id) => format!("signal_{}", id.0),
        skalp_mir::LValue::Variable(id) => format!("var_{}", id.0),
        skalp_mir::LValue::Port(id) => format!("port_{}", id.0),
        skalp_mir::LValue::BitSelect { base, index } => {
            format!("{}[{}]", format_lvalue(base), format_expression(index))
        }
        skalp_mir::LValue::RangeSelect { base, high, low } => {
            format!(
                "{}[{}:{}]",
                format_lvalue(base),
                format_expression(high),
                format_expression(low)
            )
        }
        skalp_mir::LValue::Concat(lvalues) => {
            let parts: Vec<_> = lvalues.iter().map(format_lvalue).collect();
            format!("{{{}}}", parts.join(", "))
        }
    }
}

/// Format an expression with module context
fn format_expression_with_context(expr: &skalp_mir::Expression, module: &Module) -> String {
    match expr {
        skalp_mir::Expression::Literal(val) => format_value(val),
        skalp_mir::Expression::Ref(lval) => format_lvalue_with_context(lval, module),
        skalp_mir::Expression::Binary { op, left, right } => {
            format!(
                "({} {} {})",
                format_expression_with_context(left, module),
                format_binary_op(op),
                format_expression_with_context(right, module)
            )
        }
        skalp_mir::Expression::Unary { op, operand } => {
            // Special handling for FSqrt - it's a function call in SystemVerilog
            if matches!(op, skalp_mir::UnaryOp::FSqrt) {
                format!(
                    "$sqrt({})",
                    format_expression_with_context(operand, module)
                )
            } else {
                format!(
                    "{}{}",
                    format_unary_op(op),
                    format_expression_with_context(operand, module)
                )
            }
        }
        skalp_mir::Expression::Conditional {
            cond,
            then_expr,
            else_expr,
        } => {
            format!(
                "({} ? {} : {})",
                format_expression_with_context(cond, module),
                format_expression_with_context(then_expr, module),
                format_expression_with_context(else_expr, module)
            )
        }
        skalp_mir::Expression::Concat(exprs) => {
            let parts: Vec<_> = exprs
                .iter()
                .map(|e| format_expression_with_context(e, module))
                .collect();
            format!("{{{}}}", parts.join(", "))
        }
        skalp_mir::Expression::Replicate { count, value } => {
            format!(
                "{{{}{{{}}}}}",
                format_expression_with_context(count, module),
                format_expression_with_context(value, module)
            )
        }
        skalp_mir::Expression::FunctionCall { name, args } => {
            let arg_strs: Vec<_> = args
                .iter()
                .map(|a| format_expression_with_context(a, module))
                .collect();
            format!("{}({})", name, arg_strs.join(", "))
        }
        skalp_mir::Expression::Cast { expr, .. } => {
            // Cast is a no-op for SystemVerilog (bitwise reinterpretation)
            format_expression_with_context(expr, module)
        }
    }
}

/// Format an expression (fallback without context)
fn format_expression(expr: &skalp_mir::Expression) -> String {
    match expr {
        skalp_mir::Expression::Literal(val) => format_value(val),
        skalp_mir::Expression::Ref(lval) => format_lvalue(lval),
        skalp_mir::Expression::Binary { op, left, right } => {
            format!(
                "({} {} {})",
                format_expression(left),
                format_binary_op(op),
                format_expression(right)
            )
        }
        skalp_mir::Expression::Unary { op, operand } => {
            format!("{}{}", format_unary_op(op), format_expression(operand))
        }
        skalp_mir::Expression::Conditional {
            cond,
            then_expr,
            else_expr,
        } => {
            format!(
                "({} ? {} : {})",
                format_expression(cond),
                format_expression(then_expr),
                format_expression(else_expr)
            )
        }
        skalp_mir::Expression::Concat(exprs) => {
            let parts: Vec<_> = exprs.iter().map(format_expression).collect();
            format!("{{{}}}", parts.join(", "))
        }
        skalp_mir::Expression::Replicate { count, value } => {
            format!(
                "{{{}{{{}}}}}",
                format_expression(count),
                format_expression(value)
            )
        }
        skalp_mir::Expression::FunctionCall { name, args } => {
            let arg_strs: Vec<_> = args.iter().map(format_expression).collect();
            format!("{}({})", name, arg_strs.join(", "))
        }
        skalp_mir::Expression::Cast { expr, .. } => {
            // Cast is a no-op for SystemVerilog (bitwise reinterpretation)
            format_expression(expr)
        }
    }
}

/// Format a value
fn format_value(value: &skalp_mir::Value) -> String {
    match value {
        skalp_mir::Value::Integer(n) => n.to_string(),
        skalp_mir::Value::Float(f) => f.to_string(),
        skalp_mir::Value::BitVector { width, value } => {
            format!("{}'b{:0width$b}", width, value, width = *width)
        }
        skalp_mir::Value::String(s) => format!("\"{}\"", s),
        skalp_mir::Value::Unknown => "'x".to_string(),
        skalp_mir::Value::HighZ => "'z".to_string(),
    }
}

/// Format binary operator
fn format_binary_op(op: &skalp_mir::BinaryOp) -> &'static str {
    match op {
        skalp_mir::BinaryOp::Add => "+",
        skalp_mir::BinaryOp::Sub => "-",
        skalp_mir::BinaryOp::Mul => "*",
        skalp_mir::BinaryOp::Div => "/",
        skalp_mir::BinaryOp::Mod => "%",
        skalp_mir::BinaryOp::FAdd => "+",
        skalp_mir::BinaryOp::FSub => "-",
        skalp_mir::BinaryOp::FMul => "*",
        skalp_mir::BinaryOp::FDiv => "/",
        skalp_mir::BinaryOp::And => "&", // Logical operations (same as bitwise in Verilog context)
        skalp_mir::BinaryOp::Or => "|",
        skalp_mir::BinaryOp::Xor => "^",
        skalp_mir::BinaryOp::BitwiseAnd => "&",
        skalp_mir::BinaryOp::BitwiseOr => "|",
        skalp_mir::BinaryOp::BitwiseXor => "^",
        skalp_mir::BinaryOp::LogicalAnd => "&&",
        skalp_mir::BinaryOp::LogicalOr => "||",
        skalp_mir::BinaryOp::Equal => "==",
        skalp_mir::BinaryOp::NotEqual => "!=",
        skalp_mir::BinaryOp::Less => "<",
        skalp_mir::BinaryOp::LessEqual => "<=",
        skalp_mir::BinaryOp::Greater => ">",
        skalp_mir::BinaryOp::GreaterEqual => ">=",
        skalp_mir::BinaryOp::FEqual => "==",
        skalp_mir::BinaryOp::FNotEqual => "!=",
        skalp_mir::BinaryOp::FLess => "<",
        skalp_mir::BinaryOp::FLessEqual => "<=",
        skalp_mir::BinaryOp::FGreater => ">",
        skalp_mir::BinaryOp::FGreaterEqual => ">=",
        skalp_mir::BinaryOp::LeftShift => "<<",
        skalp_mir::BinaryOp::RightShift => ">>",
    }
}

/// Format unary operator
fn format_unary_op(op: &skalp_mir::UnaryOp) -> &'static str {
    match op {
        skalp_mir::UnaryOp::BitwiseNot => "~",
        skalp_mir::UnaryOp::Not => "!",
        skalp_mir::UnaryOp::Negate => "-",
        skalp_mir::UnaryOp::Reduce(reduce_op) => match reduce_op {
            skalp_mir::ReduceOp::And => "&",
            skalp_mir::ReduceOp::Or => "|",
            skalp_mir::ReduceOp::Xor => "^",
            skalp_mir::ReduceOp::Nand => "~&",
            skalp_mir::ReduceOp::Nor => "~|",
            skalp_mir::ReduceOp::Xnor => "~^",
        },
        // FSqrt is handled specially in format_expression_with_context as $sqrt()
        skalp_mir::UnaryOp::FSqrt => "$sqrt",
    }
}

/// Get width specification string for a data type
fn get_width_spec(data_type: &skalp_mir::DataType) -> String {
    match data_type {
        skalp_mir::DataType::Bit(width)
        | skalp_mir::DataType::Logic(width)
        | skalp_mir::DataType::Int(width)
        | skalp_mir::DataType::Nat(width) => {
            if *width > 1 {
                format!("[{}:0] ", width - 1)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Bool => String::new(), // Boolean is single bit
        // Parametric types use parameter name
        skalp_mir::DataType::BitParam { param, default }
        | skalp_mir::DataType::LogicParam { param, default }
        | skalp_mir::DataType::IntParam { param, default }
        | skalp_mir::DataType::NatParam { param, default } => {
            if *default > 1 {
                format!("[{}-1:0] ", param)
            } else {
                String::new()
            }
        }
        // Expression-based parametric types - convert MIR expression to SystemVerilog
        skalp_mir::DataType::BitExpr { expr, default }
        | skalp_mir::DataType::LogicExpr { expr, default }
        | skalp_mir::DataType::IntExpr { expr, default }
        | skalp_mir::DataType::NatExpr { expr, default } => {
            if *default > 1 {
                // Convert MIR expression to SystemVerilog string
                let expr_str = convert_mir_expr_to_sv(expr);
                format!("[{}-1:0] ", expr_str)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Clock { .. } => String::new(), // Clocks are single bit
        skalp_mir::DataType::Reset { .. } => String::new(), // Resets are single bit
        skalp_mir::DataType::Event => String::new(),        // Events have no width
        skalp_mir::DataType::Array(element_type, size) => {
            // Array format: [element_width][0:size-1]
            let element_width = get_width_spec(element_type);
            if *size > 1 {
                format!("{}[0:{}] ", element_width.trim(), size - 1)
            } else {
                element_width
            }
        }
        skalp_mir::DataType::Struct(struct_type) => {
            // For structs, calculate total width
            let mut total_width = 0;
            for field in &struct_type.fields {
                total_width += get_type_width(&field.field_type);
            }
            if total_width > 1 {
                format!("[{}:0] ", total_width - 1)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Enum(_) => {
            // Enums default to 32-bit
            "[31:0] ".to_string()
        }
        skalp_mir::DataType::Union(union_type) => {
            // Unions use the width of the largest field
            let mut max_width = 0;
            for field in &union_type.fields {
                let width = get_type_width(&field.field_type);
                if width > max_width {
                    max_width = width;
                }
            }
            if max_width > 1 {
                format!("[{}:0] ", max_width - 1)
            } else {
                String::new()
            }
        }
        // Floating-point types have fixed widths
        skalp_mir::DataType::Float16 => "[15:0] ".to_string(),
        skalp_mir::DataType::Float32 => "[31:0] ".to_string(),
        skalp_mir::DataType::Float64 => "[63:0] ".to_string(),
        // Vector types - width is element_width * component_count
        skalp_mir::DataType::Vec2(element_type) => {
            let elem_width = get_type_width(element_type);
            let total_width = elem_width * 2;
            if total_width > 1 {
                format!("[{}:0] ", total_width - 1)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Vec3(element_type) => {
            let elem_width = get_type_width(element_type);
            let total_width = elem_width * 3;
            if total_width > 1 {
                format!("[{}:0] ", total_width - 1)
            } else {
                String::new()
            }
        }
        skalp_mir::DataType::Vec4(element_type) => {
            let elem_width = get_type_width(element_type);
            let total_width = elem_width * 4;
            if total_width > 1 {
                format!("[{}:0] ", total_width - 1)
            } else {
                String::new()
            }
        }
    }
}

/// Get type dimensions split into element width and array dimensions
/// Returns (element_width, array_dimensions)
/// For non-arrays: returns (width_spec, "")
/// For arrays: returns (element_width_spec, " [0:size-1]")
fn get_type_dimensions(data_type: &skalp_mir::DataType) -> (String, String) {
    match data_type {
        skalp_mir::DataType::Array(element_type, size) => {
            // Recursively handle nested arrays
            let (inner_element, inner_array) = get_type_dimensions(element_type);
            let array_dim = if *size > 1 {
                format!("{} [0:{}]", inner_array, size - 1)
            } else {
                inner_array
            };
            (inner_element, array_dim)
        }
        _ => {
            // Non-array types: return width spec with no array dimension
            (get_width_spec(data_type), String::new())
        }
    }
}

/// Get the width in bits of a data type
///
/// **Note:** Uses the shared type_width module for consistent width calculation.
/// After Phase 2 of the refactoring, MIR ports and signals should only have
/// scalar types. If composite types appear here, it indicates a bug in HIR→MIR.
fn get_type_width(data_type: &skalp_mir::DataType) -> usize {
    type_width::get_type_width(data_type)
}

/// Flatten a port with struct type into individual signals
/// For example: vertex: Vertex becomes vertex_position_x, vertex_position_y, etc.
fn flatten_port_to_signals(
    name: &str,
    port_type: &DataType,
    direction: &str,
    ports: &mut Vec<String>,
) {
    match port_type {
        DataType::Struct(struct_type) => {
            // Recursively flatten each field
            for field in &struct_type.fields {
                let field_name = format!("{}_{}", name, field.name);
                flatten_port_to_signals(&field_name, &field.field_type, direction, ports);
            }
        }
        DataType::Vec2(element_type) => {
            // Flatten Vec2 into x, y components
            let x_name = format!("{}_x", name);
            let y_name = format!("{}_y", name);
            flatten_port_to_signals(&x_name, element_type, direction, ports);
            flatten_port_to_signals(&y_name, element_type, direction, ports);
        }
        DataType::Vec3(element_type) => {
            // Flatten Vec3 into x, y, z components
            let x_name = format!("{}_x", name);
            let y_name = format!("{}_y", name);
            let z_name = format!("{}_z", name);
            flatten_port_to_signals(&x_name, element_type, direction, ports);
            flatten_port_to_signals(&y_name, element_type, direction, ports);
            flatten_port_to_signals(&z_name, element_type, direction, ports);
        }
        DataType::Vec4(element_type) => {
            // Flatten Vec4 into x, y, z, w components
            let x_name = format!("{}_x", name);
            let y_name = format!("{}_y", name);
            let z_name = format!("{}_z", name);
            let w_name = format!("{}_w", name);
            flatten_port_to_signals(&x_name, element_type, direction, ports);
            flatten_port_to_signals(&y_name, element_type, direction, ports);
            flatten_port_to_signals(&z_name, element_type, direction, ports);
            flatten_port_to_signals(&w_name, element_type, direction, ports);
        }
        _ => {
            // Non-struct type - add as single port
            let (element_width, array_dim) = get_type_dimensions(port_type);
            ports.push(format!(
                "    {} {}{}{}",
                direction, element_width, name, array_dim
            ));
        }
    }
}

/// Expand a struct assignment into individual field assignments
/// Returns a vector of (lhs_string, rhs_string) pairs
fn expand_struct_assignment(
    lhs: &skalp_mir::LValue,
    rhs: &skalp_mir::Expression,
    module: &Module,
) -> Vec<(String, String)> {
    let mut assignments = Vec::new();

    // Get the base lvalue and its type
    let (base_lvalue, lvalue_type) = match lhs {
        skalp_mir::LValue::Signal(id) => {
            let signal = module.signals.iter().find(|s| s.id == *id);
            if let Some(sig) = signal {
                (lhs, &sig.signal_type)
            } else {
                // If signal not found, return as-is
                assignments.push((
                    format_lvalue_with_context(lhs, module),
                    format_expression_with_context(rhs, module),
                ));
                return assignments;
            }
        }
        skalp_mir::LValue::Port(id) => {
            let port = module.ports.iter().find(|p| p.id == *id);
            if let Some(p) = port {
                (lhs, &p.port_type)
            } else {
                // If port not found, return as-is
                assignments.push((
                    format_lvalue_with_context(lhs, module),
                    format_expression_with_context(rhs, module),
                ));
                return assignments;
            }
        }
        _ => {
            // For other lvalue types (bit select, range select, etc.), return as-is
            assignments.push((
                format_lvalue_with_context(lhs, module),
                format_expression_with_context(rhs, module),
            ));
            return assignments;
        }
    };

    // Check if it's a struct or vector type that needs expansion
    match lvalue_type {
        DataType::Struct(struct_type) => {
            // Get the base name for LHS
            let lhs_base_name = format_lvalue_with_context(base_lvalue, module);

            // Check if RHS is also a signal/port reference to expand from
            let rhs_base_name = if let skalp_mir::Expression::Ref(rhs_lvalue) = rhs {
                Some(format_lvalue_with_context(rhs_lvalue, module))
            } else {
                None
            };

            // Expand each field
            for field in &struct_type.fields {
                let lhs_field_name = format!("{}_{}", lhs_base_name, field.name);
                let rhs_field_expr = if let Some(ref rhs_name) = rhs_base_name {
                    format!("{}_{}", rhs_name, field.name)
                } else {
                    // RHS is not a simple reference, can't expand
                    // This shouldn't happen for simple struct assignments
                    format_expression_with_context(rhs, module)
                };

                // Recursively expand nested structs
                expand_field_assignment(
                    &lhs_field_name,
                    &rhs_field_expr,
                    &field.field_type,
                    &mut assignments,
                );
            }
        }
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => {
            // Get the base name for LHS
            let lhs_base_name = format_lvalue_with_context(base_lvalue, module);

            // Check if RHS is also a signal/port reference
            let rhs_base_name = if let skalp_mir::Expression::Ref(rhs_lvalue) = rhs {
                Some(format_lvalue_with_context(rhs_lvalue, module))
            } else {
                None
            };

            // Determine component names based on vector type
            let components = match lvalue_type {
                DataType::Vec2(_) => vec!["x", "y"],
                DataType::Vec3(_) => vec!["x", "y", "z"],
                DataType::Vec4(_) => vec!["x", "y", "z", "w"],
                _ => unreachable!(),
            };

            // Expand each component
            for component in components {
                let lhs_comp_name = format!("{}_{}", lhs_base_name, component);
                let rhs_comp_expr = if let Some(ref rhs_name) = rhs_base_name {
                    format!("{}_{}", rhs_name, component)
                } else {
                    format_expression_with_context(rhs, module)
                };

                expand_field_assignment(
                    &lhs_comp_name,
                    &rhs_comp_expr,
                    element_type,
                    &mut assignments,
                );
            }
        }
        _ => {
            // Not a struct type, return as single assignment
            assignments.push((
                format_lvalue_with_context(lhs, module),
                format_expression_with_context(rhs, module),
            ));
        }
    }

    assignments
}

/// Helper to recursively expand nested struct fields
fn expand_field_assignment(
    lhs_name: &str,
    rhs_expr: &str,
    field_type: &DataType,
    assignments: &mut Vec<(String, String)>,
) {
    match field_type {
        DataType::Struct(struct_type) => {
            // Recursively expand nested struct fields
            for field in &struct_type.fields {
                let nested_lhs = format!("{}_{}", lhs_name, field.name);
                let nested_rhs = format!("{}_{}", rhs_expr, field.name);
                expand_field_assignment(&nested_lhs, &nested_rhs, &field.field_type, assignments);
            }
        }
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => {
            let components = match field_type {
                DataType::Vec2(_) => vec!["x", "y"],
                DataType::Vec3(_) => vec!["x", "y", "z"],
                DataType::Vec4(_) => vec!["x", "y", "z", "w"],
                _ => unreachable!(),
            };

            for component in components {
                let nested_lhs = format!("{}_{}", lhs_name, component);
                let nested_rhs = format!("{}_{}", rhs_expr, component);
                expand_field_assignment(&nested_lhs, &nested_rhs, element_type, assignments);
            }
        }
        _ => {
            // Leaf field - add assignment
            assignments.push((lhs_name.to_string(), rhs_expr.to_string()));
        }
    }
}

/// Expand a port connection for flattened struct/vector types
/// Returns a vector of (port_field_name, signal_field_expr) pairs
/// This handles entity instantiation where both ports and signals may be flattened
fn expand_port_connection(
    port_name: &str,
    port_type: &DataType,
    signal_expr: &skalp_mir::Expression,
    parent_module: &Module,
) -> Vec<(String, String)> {
    let mut connections = Vec::new();

    match port_type {
        DataType::Struct(struct_type) => {
            // Get the signal base name if it's a simple reference
            let signal_base_name = if let skalp_mir::Expression::Ref(lvalue) = signal_expr {
                Some(format_lvalue_with_context(lvalue, parent_module))
            } else {
                None
            };

            // Expand each field
            for field in &struct_type.fields {
                let port_field_name = format!("{}_{}", port_name, field.name);
                let signal_field_name = if let Some(ref signal_name) = signal_base_name {
                    format!("{}_{}", signal_name, field.name)
                } else {
                    // Can't expand non-reference expressions, use as-is
                    format_expression_with_context(signal_expr, parent_module)
                };

                // Recursively expand nested types
                expand_port_connection_field(
                    &port_field_name,
                    &signal_field_name,
                    &field.field_type,
                    &mut connections,
                );
            }
        }
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => {
            // Get the signal base name
            let signal_base_name = if let skalp_mir::Expression::Ref(lvalue) = signal_expr {
                Some(format_lvalue_with_context(lvalue, parent_module))
            } else {
                None
            };

            // Determine components
            let components = match port_type {
                DataType::Vec2(_) => vec!["x", "y"],
                DataType::Vec3(_) => vec!["x", "y", "z"],
                DataType::Vec4(_) => vec!["x", "y", "z", "w"],
                _ => unreachable!(),
            };

            // Expand each component
            for component in components {
                let port_comp_name = format!("{}_{}", port_name, component);
                let signal_comp_name = if let Some(ref signal_name) = signal_base_name {
                    format!("{}_{}", signal_name, component)
                } else {
                    format_expression_with_context(signal_expr, parent_module)
                };

                expand_port_connection_field(
                    &port_comp_name,
                    &signal_comp_name,
                    element_type,
                    &mut connections,
                );
            }
        }
        _ => {
            // Scalar type - single connection
            connections.push((
                port_name.to_string(),
                format_expression_with_context(signal_expr, parent_module),
            ));
        }
    }

    connections
}

/// Helper to recursively expand nested struct/vector fields in port connections
fn expand_port_connection_field(
    port_field_name: &str,
    signal_field_name: &str,
    field_type: &DataType,
    connections: &mut Vec<(String, String)>,
) {
    match field_type {
        DataType::Struct(struct_type) => {
            // Recursively expand nested struct
            for field in &struct_type.fields {
                let nested_port = format!("{}_{}", port_field_name, field.name);
                let nested_signal = format!("{}_{}", signal_field_name, field.name);
                expand_port_connection_field(
                    &nested_port,
                    &nested_signal,
                    &field.field_type,
                    connections,
                );
            }
        }
        DataType::Vec2(element_type)
        | DataType::Vec3(element_type)
        | DataType::Vec4(element_type) => {
            let components = match field_type {
                DataType::Vec2(_) => vec!["x", "y"],
                DataType::Vec3(_) => vec!["x", "y", "z"],
                DataType::Vec4(_) => vec!["x", "y", "z", "w"],
                _ => unreachable!(),
            };

            for component in components {
                let nested_port = format!("{}_{}", port_field_name, component);
                let nested_signal = format!("{}_{}", signal_field_name, component);
                expand_port_connection_field(
                    &nested_port,
                    &nested_signal,
                    element_type,
                    connections,
                );
            }
        }
        _ => {
            // Leaf field - add connection
            connections.push((port_field_name.to_string(), signal_field_name.to_string()));
        }
    }
}

/// Flatten a signal with struct type into individual declarations
/// For example: vertex: Vertex becomes vertex_position_x, vertex_position_y, etc.
fn flatten_signal_to_declarations(
    name: &str,
    signal_type: &DataType,
    reg_or_wire: &str,
    initial_value: &Option<skalp_mir::Value>,
    declarations: &mut Vec<String>,
) {
    match signal_type {
        DataType::Struct(struct_type) => {
            // Recursively flatten each field
            for field in &struct_type.fields {
                let field_name = format!("{}_{}", name, field.name);
                // For struct fields, we don't propagate the initial value
                // (would need to extract field values from struct literal)
                flatten_signal_to_declarations(
                    &field_name,
                    &field.field_type,
                    reg_or_wire,
                    &None,
                    declarations,
                );
            }
        }
        DataType::Vec2(element_type) => {
            // Flatten Vec2 into x, y components
            flatten_signal_to_declarations(
                &format!("{}_x", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_y", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
        }
        DataType::Vec3(element_type) => {
            // Flatten Vec3 into x, y, z components
            flatten_signal_to_declarations(
                &format!("{}_x", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_y", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_z", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
        }
        DataType::Vec4(element_type) => {
            // Flatten Vec4 into x, y, z, w components
            flatten_signal_to_declarations(
                &format!("{}_x", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_y", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_z", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
            flatten_signal_to_declarations(
                &format!("{}_w", name),
                element_type,
                reg_or_wire,
                &None,
                declarations,
            );
        }
        _ => {
            // Non-struct type - add as single declaration
            let (element_width, array_dim) = get_type_dimensions(signal_type);
            let mut decl = format!("    {} {}{}{}", reg_or_wire, element_width, name, array_dim);

            // Add initial value if present
            if let Some(init) = initial_value {
                decl.push_str(&format!(" = {}", format_value(init)));
            }

            declarations.push(decl);
        }
    }
}

/// Check if a signal is a register (assigned in sequential blocks)
fn is_register(signal: &skalp_mir::Signal, module: &Module) -> bool {
    // A signal is a register if it's assigned in any sequential process
    for process in &module.processes {
        if process.kind == ProcessKind::Sequential
            && is_signal_assigned_in_block(&signal.id, &process.body)
        {
            return true;
        }
    }
    false
}

/// Check if a signal is assigned in a block
fn is_signal_assigned_in_block(signal_id: &skalp_mir::SignalId, block: &skalp_mir::Block) -> bool {
    for stmt in &block.statements {
        match stmt {
            Statement::Assignment(assign) => {
                // Check if this assignment targets the signal (directly or through indexing/slicing)
                if lvalue_contains_signal(&assign.lhs, signal_id) {
                    return true;
                }
            }
            Statement::If(if_stmt) => {
                if is_signal_assigned_in_block(signal_id, &if_stmt.then_block) {
                    return true;
                }
                if let Some(else_block) = &if_stmt.else_block {
                    if is_signal_assigned_in_block(signal_id, else_block) {
                        return true;
                    }
                }
            }
            Statement::Case(case_stmt) => {
                // Check all case items
                for item in &case_stmt.items {
                    if is_signal_assigned_in_block(signal_id, &item.block) {
                        return true;
                    }
                }
                // Check default case
                if let Some(default_block) = &case_stmt.default {
                    if is_signal_assigned_in_block(signal_id, default_block) {
                        return true;
                    }
                }
            }
            Statement::Block(block) => {
                if is_signal_assigned_in_block(signal_id, block) {
                    return true;
                }
            }
            _ => {}
        }
    }
    false
}

/// Check if an LValue references a specific signal (directly or through indexing/slicing)
fn lvalue_contains_signal(lvalue: &skalp_mir::LValue, signal_id: &skalp_mir::SignalId) -> bool {
    match lvalue {
        skalp_mir::LValue::Signal(id) => id == signal_id,
        skalp_mir::LValue::BitSelect { base, .. } => lvalue_contains_signal(base, signal_id),
        skalp_mir::LValue::RangeSelect { base, .. } => lvalue_contains_signal(base, signal_id),
        skalp_mir::LValue::Concat(items) => items
            .iter()
            .any(|item| lvalue_contains_signal(item, signal_id)),
        _ => false,
    }
}

/// Collect all struct and enum types used in a module
fn collect_types_from_module(
    module: &Module,
    struct_types: &mut HashSet<String>,
    enum_types: &mut HashSet<String>,
) {
    // Collect from port types
    for port in &module.ports {
        collect_types_from_datatype(&port.port_type, struct_types, enum_types);
    }

    // Collect from signal types
    for signal in &module.signals {
        collect_types_from_datatype(&signal.signal_type, struct_types, enum_types);
    }
}

/// Recursively collect struct and enum types from a DataType
fn collect_types_from_datatype(
    data_type: &DataType,
    struct_types: &mut HashSet<String>,
    enum_types: &mut HashSet<String>,
) {
    match data_type {
        DataType::Struct(struct_type) => {
            struct_types.insert(struct_type.name.clone());
            // Collect types from struct fields
            for field in &struct_type.fields {
                collect_types_from_datatype(&field.field_type, struct_types, enum_types);
            }
        }
        DataType::Enum(enum_type) => {
            enum_types.insert(enum_type.name.clone());
            // Collect types from enum base type
            collect_types_from_datatype(&enum_type.base_type, struct_types, enum_types);
        }
        DataType::Array(element_type, _) => {
            collect_types_from_datatype(element_type, struct_types, enum_types);
        }
        DataType::Union(union_type) => {
            // For unions, collect field types (treat similar to structs for now)
            for field in &union_type.fields {
                collect_types_from_datatype(&field.field_type, struct_types, enum_types);
            }
        }
        _ => {} // Primitive types don't need typedef collection
    }
}

/// Generate SystemVerilog typedefs for collected struct and enum types
fn generate_typedefs(
    module: &Module,
    struct_type_names: &HashSet<String>,
    enum_type_names: &HashSet<String>,
) -> String {
    let mut typedefs = String::new();

    if struct_type_names.is_empty() && enum_type_names.is_empty() {
        return typedefs;
    }

    // Find the actual type definitions in the module's port/signal types
    let mut generated_structs: HashSet<String> = HashSet::new();
    let mut generated_enums: HashSet<String> = HashSet::new();

    // Generate struct typedefs
    for port in &module.ports {
        generate_typedefs_for_datatype(
            &port.port_type,
            &mut typedefs,
            &mut generated_structs,
            &mut generated_enums,
            struct_type_names,
            enum_type_names,
        );
    }

    for signal in &module.signals {
        generate_typedefs_for_datatype(
            &signal.signal_type,
            &mut typedefs,
            &mut generated_structs,
            &mut generated_enums,
            struct_type_names,
            enum_type_names,
        );
    }

    if !typedefs.is_empty() {
        typedefs.push('\n');
    }

    typedefs
}

/// Generate typedefs for a specific DataType
fn generate_typedefs_for_datatype(
    data_type: &DataType,
    typedefs: &mut String,
    generated_structs: &mut HashSet<String>,
    generated_enums: &mut HashSet<String>,
    target_structs: &HashSet<String>,
    target_enums: &HashSet<String>,
) {
    match data_type {
        DataType::Struct(struct_type) => {
            if target_structs.contains(&struct_type.name)
                && !generated_structs.contains(&struct_type.name)
            {
                // Generate struct fields first (in case they reference other types)
                for field in &struct_type.fields {
                    generate_typedefs_for_datatype(
                        &field.field_type,
                        typedefs,
                        generated_structs,
                        generated_enums,
                        target_structs,
                        target_enums,
                    );
                }

                // Generate the struct typedef
                typedefs.push_str("typedef struct {\n");
                for field in &struct_type.fields {
                    let field_width = get_width_spec(&field.field_type);
                    typedefs.push_str(&format!(
                        "    {}{} {};\n",
                        get_systemverilog_type(&field.field_type),
                        field_width,
                        field.name
                    ));
                }
                typedefs.push_str(&format!("}} {};\n\n", struct_type.name));

                generated_structs.insert(struct_type.name.clone());
            }
        }
        DataType::Enum(enum_type) => {
            if target_enums.contains(&enum_type.name) && !generated_enums.contains(&enum_type.name)
            {
                // Generate base type first
                generate_typedefs_for_datatype(
                    &enum_type.base_type,
                    typedefs,
                    generated_structs,
                    generated_enums,
                    target_structs,
                    target_enums,
                );

                // Generate the enum typedef
                let base_width = get_width_spec(&enum_type.base_type);
                typedefs.push_str(&format!(
                    "typedef enum {}{} {{\n",
                    get_systemverilog_type(&enum_type.base_type),
                    base_width
                ));

                for (i, variant) in enum_type.variants.iter().enumerate() {
                    if i > 0 {
                        typedefs.push_str(",\n");
                    }
                    if let Some(value) = &variant.value {
                        typedefs.push_str(&format!(
                            "    {} = {}",
                            variant.name,
                            format_value(value)
                        ));
                    } else {
                        typedefs.push_str(&format!("    {}", variant.name));
                    }
                }
                typedefs.push_str(&format!("\n}} {};\n\n", enum_type.name));

                generated_enums.insert(enum_type.name.clone());
            }
        }
        DataType::Array(element_type, _) => {
            generate_typedefs_for_datatype(
                element_type,
                typedefs,
                generated_structs,
                generated_enums,
                target_structs,
                target_enums,
            );
        }
        DataType::Union(union_type) => {
            // Handle unions similarly to structs for now
            for field in &union_type.fields {
                generate_typedefs_for_datatype(
                    &field.field_type,
                    typedefs,
                    generated_structs,
                    generated_enums,
                    target_structs,
                    target_enums,
                );
            }
        }
        _ => {} // Primitive types don't need typedef generation
    }
}

/// Get the SystemVerilog type name for a DataType (for typedef generation)
fn get_systemverilog_type(data_type: &DataType) -> &'static str {
    match data_type {
        DataType::Bit(_) | DataType::BitParam { .. } | DataType::BitExpr { .. } => "bit",
        DataType::Logic(_) | DataType::LogicParam { .. } | DataType::LogicExpr { .. } => "logic",
        DataType::Int(_) | DataType::IntParam { .. } | DataType::IntExpr { .. } => "int",
        DataType::Nat(_) | DataType::NatParam { .. } | DataType::NatExpr { .. } => "logic", // Use logic for unsigned naturals
        _ => "logic", // Default to logic for other types
    }
}

/// Convert a MIR expression to a SystemVerilog expression string
/// This is specifically for const expressions used in type positions (like clog2(SIZE))
fn convert_mir_expr_to_sv(expr: &skalp_mir::Expression) -> String {
    match expr {
        skalp_mir::Expression::Literal(val) => format_value(val),
        skalp_mir::Expression::Binary { op, left, right } => {
            format!(
                "({}{}{})",
                convert_mir_expr_to_sv(left),
                format_binary_op(op),
                convert_mir_expr_to_sv(right)
            )
        }
        skalp_mir::Expression::FunctionCall { name, args } => {
            // Handle built-in functions that map to SystemVerilog functions
            match name.as_str() {
                "clog2" => {
                    // clog2(x) → $clog2(x)
                    if args.len() == 1 {
                        format!("$clog2({})", convert_mir_expr_to_sv(&args[0]))
                    } else {
                        "$clog2(0)".to_string() // Fallback for invalid args
                    }
                }
                "pow2" => {
                    // pow2(x) → (1 << x)
                    if args.len() == 1 {
                        format!("(1 << {})", convert_mir_expr_to_sv(&args[0]))
                    } else {
                        "1".to_string() // Fallback
                    }
                }
                _ => {
                    // Generic parameter reference (stored as FunctionCall with no args)
                    // or unknown function
                    if args.is_empty() {
                        // This is a parameter reference like SIZE
                        name.clone()
                    } else {
                        // Unknown function - try to emit as-is
                        let arg_strs: Vec<_> = args.iter().map(convert_mir_expr_to_sv).collect();
                        format!("{}({})", name, arg_strs.join(", "))
                    }
                }
            }
        }
        _ => {
            // For other expression types (like Ref, Conditional, etc.), use the general formatter
            format_expression(expr)
        }
    }
}
