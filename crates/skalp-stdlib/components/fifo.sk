// Standard library FIFO component  
entity std_fifo<const WIDTH: usize, const DEPTH: usize> {
    in clk: clock;
    in rst: reset;
    
    // Write interface
    in write_data: bit<WIDTH>;
    in write_enable: bit;
    out full: bit;
    out almost_full: bit;
    
    // Read interface
    out read_data: bit<WIDTH>;
    in read_enable: bit;
    out empty: bit;
    out almost_empty: bit;
    
    // Status
    out fill_count: bit<log2(DEPTH+1)>;
}

impl std_fifo {
    signal memory: Array<bit<WIDTH>, DEPTH>;
    signal write_ptr: bit<log2(DEPTH)>;
    signal read_ptr: bit<log2(DEPTH)>;
    signal count: bit<log2(DEPTH+1)>;
    
    on(clk.rise) {
        if rst.active {
            write_ptr = 0;
            read_ptr = 0;
            count = 0;
        } else {
            match {write_enable && !full, read_enable && !empty} {
                {true, true} => {
                    memory[write_ptr] = write_data;
                    write_ptr <= (write_ptr + 1) % DEPTH;
                    read_ptr <= (read_ptr + 1) % DEPTH;
                },
                {true, false} => {
                    memory[write_ptr] = write_data;
                    write_ptr <= (write_ptr + 1) % DEPTH;
                    count = count + 1;
                },
                {false, true} => {
                    read_ptr <= (read_ptr + 1) % DEPTH;
                    count = count - 1;
                },
                {false, false} => {}
            }
        }
    }
    
    read_data = memory[read_ptr];
    full = (count == DEPTH);
    empty = (count == 0);
    almost_full = (count >= DEPTH - 1);
    almost_empty = (count = 1);
    fill_count = count;
    
    assert property (write_enable -> !full) @(posedge clk);
    assert property (read_enable -> !empty) @(posedge clk);
    assert property (count = DEPTH) @(posedge clk);
}
