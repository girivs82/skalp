// Parameterized FIFO (First-In-First-Out) Buffer
// Synchronous FIFO with configurable width and depth

@intent("buffering")
entity FIFO<const WIDTH: nat = 8, const DEPTH: nat = 16> {
    in clk: clock;
    in rst: reset(active_high);

    // Write interface
    in wr_en: bit;
    in wr_data: bit<WIDTH>;
    out full: bit;
    out almost_full: bit;

    // Read interface
    in rd_en: bit;
    out rd_data: bit<WIDTH>;
    out empty: bit;
    out almost_empty: bit;

    // Status
    out count: nat<$clog2(DEPTH+1)>;
}

impl FIFO<const WIDTH: nat, const DEPTH: nat> {
    // Internal memory
    signal memory: array<bit<WIDTH>, DEPTH>;
    signal wr_ptr: nat<$clog2(DEPTH)>;
    signal rd_ptr: nat<$clog2(DEPTH)>;
    signal elements: nat<$clog2(DEPTH+1)>;

    // Status flags
    signal is_full: bit;
    signal is_empty: bit;

    // Continuous assignments
    empty = (elements == 0);
    full = (elements == DEPTH);
    almost_empty = (elements == 1);
    almost_full = (elements == DEPTH - 1);
    count = elements;
    is_empty = empty;
    is_full = full;

    // Read data assignment
    rd_data = memory[rd_ptr];

    on(rst.active) {
        wr_ptr <= 0;
        rd_ptr <= 0;
        elements <= 0;
    }

    on(clk.rise) {
        // Write operation
        if wr_en && !is_full {
            memory[wr_ptr] <= wr_data;
            wr_ptr <= (wr_ptr + 1) % DEPTH;
        }

        // Read operation
        if rd_en && !is_empty {
            rd_ptr <= (rd_ptr + 1) % DEPTH;
        }

        // Update element count
        if wr_en && !rd_en && !is_full {
            elements <= elements + 1;
        } else if !wr_en && rd_en && !is_empty {
            elements <= elements - 1;
        }
        // Simultaneous read and write maintains count
    }

    // Assertions for verification
    assert property (elements <= DEPTH);
    assert property (wr_en && is_full |-> !memory_write);
    assert property (rd_en && is_empty |-> rd_data == prev(rd_data));
}