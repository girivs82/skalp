// Standard library AXI4-Lite protocol definitions
protocol AXI4Lite<const ADDR_WIDTH: usize, const DATA_WIDTH: usize> {
    // Write Address Channel
    out awaddr: bit<ADDR_WIDTH>;
    out awprot: bit<3>;
    out awvalid: bit;
    in awready: bit;
    
    // Write Data Channel
    out wdata: bit<DATA_WIDTH>;
    out wstrb: bit<DATA_WIDTH/8>;
    out wvalid: bit;
    in wready: bit;
    
    // Write Response Channel
    in bresp: bit<2>;
    in bvalid: bit;
    out bready: bit;
    
    // Read Address Channel
    out araddr: bit<ADDR_WIDTH>;
    out arprot: bit<3>;
    out arvalid: bit;
    in arready: bit;
    
    // Read Data Channel
    in rdata: bit<DATA_WIDTH>;
    in rresp: bit<2>;
    in rvalid: bit;
    out rready: bit;
}

// AXI4-Lite Master interface
entity axi4_lite_master<const ADDR_WIDTH: usize, const DATA_WIDTH: usize> {
    in clk: clock;
    in rst: reset;
    
    // User interface
    in write_req: bit;
    in read_req: bit;
    in addr: bit<ADDR_WIDTH>;
    in write_data: bit<DATA_WIDTH>;
    in write_strb: bit<DATA_WIDTH/8>;
    out read_data: bit<DATA_WIDTH>;
    out ready: bit;
    out resp: bit<2>;
    
    // AXI interface
    master axi: AXI4Lite<ADDR_WIDTH, DATA_WIDTH>;
}

impl axi4_lite_master {
    enum State {
        Idle,
        WriteAddr,
        WriteData,
        WriteResp,
        ReadAddr,
        ReadData
    }
    
    signal state: State;
    signal addr_reg: bit<ADDR_WIDTH>;
    signal write_data_reg: bit<DATA_WIDTH>;
    signal write_strb_reg: bit<DATA_WIDTH/8>;
    signal read_data_reg: bit<DATA_WIDTH>;
    signal resp_reg: bit<2>;
    
    on(clk.rise) {
        if rst.active {
            state <= State::Idle;
            axi.awvalid <= 0;
            axi.wvalid <= 0;
            axi.bready <= 0;
            axi.arvalid <= 0;
            axi.rready <= 0;
        } else {
            match state {
                State::Idle => {
                    if write_req {
                        state <= State::WriteAddr;
                        addr_reg <= addr;
                        write_data_reg <= write_data;
                        write_strb_reg <= write_strb;
                        axi.awaddr <= addr;
                        axi.awprot <= 3'b000;
                        axi.awvalid <= 1;
                    } else if read_req {
                        state <= State::ReadAddr;
                        addr_reg <= addr;
                        axi.araddr <= addr;
                        axi.arprot <= 3'b000;
                        axi.arvalid <= 1;
                    }
                },
                State::WriteAddr => {
                    if axi.awready {
                        axi.awvalid <= 0;
                        state <= State::WriteData;
                        axi.wdata <= write_data_reg;
                        axi.wstrb <= write_strb_reg;
                        axi.wvalid <= 1;
                    }
                },
                State::WriteData => {
                    if axi.wready {
                        axi.wvalid <= 0;
                        state <= State::WriteResp;
                        axi.bready <= 1;
                    }
                },
                State::WriteResp => {
                    if axi.bvalid {
                        axi.bready <= 0;
                        resp_reg <= axi.bresp;
                        state <= State::Idle;
                    }
                },
                State::ReadAddr => {
                    if axi.arready {
                        axi.arvalid <= 0;
                        state <= State::ReadData;
                        axi.rready <= 1;
                    }
                },
                State::ReadData => {
                    if axi.rvalid {
                        axi.rready <= 0;
                        read_data_reg <= axi.rdata;
                        resp_reg <= axi.rresp;
                        state <= State::Idle;
                    }
                }
            }
        }
    }
    
    read_data = read_data_reg;
    ready = (state == State::Idle);
    resp = resp_reg;
    
    // Verification properties
    assert property (write_req && ready |=> !ready) @(posedge clk);
    assert property (read_req && ready |=> !ready) @(posedge clk);
    assert property (axi.awvalid && axi.awready |=> !axi.awvalid) @(posedge clk);
}
