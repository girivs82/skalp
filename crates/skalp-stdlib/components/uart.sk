// Standard library UART component
entity std_uart<const CLK_FREQ: usize, const BAUD_RATE: usize> {
    in clk: clock;
    in rst: reset;
    
    // Transmit interface
    in tx_data: bit<8>;
    in tx_start: bit;
    out tx_busy: bit;
    out tx: bit;
    
    // Receive interface
    in rx: bit;
    out rx_data: bit<8>;
    out rx_ready: bit;
    out rx_error: bit;
}

impl std_uart {
    const BAUD_DIV: usize = CLK_FREQ / BAUD_RATE;
    
    // Transmitter
    enum TxState { Idle, StartBit, DataBits, StopBit }
    signal tx_state: TxState;
    signal tx_baud_counter: bit<log2(BAUD_DIV)>;
    signal tx_bit_counter: bit<3>;
    signal tx_shift_reg: bit<8>;
    signal tx_baud_tick: bit;
    
    // Receiver  
    enum RxState { Idle, StartBit, DataBits, StopBit }
    signal rx_state: RxState;
    signal rx_baud_counter: bit<log2(BAUD_DIV)>;
    signal rx_bit_counter: bit<3>;
    signal rx_shift_reg: bit<8>;
    signal rx_baud_tick: bit;
    signal rx_sync: bit<2>;
    
    on(clk.rise) {
        if rst.active {
            // Reset transmitter
            tx_state <= TxState::Idle;
            tx_baud_counter <= 0;
            tx_bit_counter <= 0;
            tx_shift_reg <= 0;
            
            // Reset receiver
            rx_state <= RxState::Idle;
            rx_baud_counter <= 0;
            rx_bit_counter <= 0;
            rx_shift_reg <= 0;
            rx_sync <= 2'b11;
        } else {
            // Synchronize RX input
            rx_sync <= {rx_sync[0], rx};
            
            // Transmitter baud rate generator
            if tx_baud_counter == BAUD_DIV - 1 {
                tx_baud_counter <= 0;
            } else {
                tx_baud_counter <= tx_baud_counter + 1;
            }
            
            // Receiver baud rate generator
            if rx_baud_counter == BAUD_DIV - 1 {
                rx_baud_counter <= 0;
            } else {
                rx_baud_counter <= rx_baud_counter + 1;
            }
            
            // Transmitter state machine
            if tx_baud_tick {
                match tx_state {
                    TxState::Idle => {
                        if tx_start {
                            tx_state <= TxState::StartBit;
                            tx_shift_reg <= tx_data;
                            tx_bit_counter <= 0;
                        }
                    },
                    TxState::StartBit => {
                        tx_state <= TxState::DataBits;
                    },
                    TxState::DataBits => {
                        tx_shift_reg <= {1'b0, tx_shift_reg[7:1]};
                        if tx_bit_counter == 7 {
                            tx_state <= TxState::StopBit;
                        } else {
                            tx_bit_counter <= tx_bit_counter + 1;
                        }
                    },
                    TxState::StopBit => {
                        tx_state <= TxState::Idle;
                    }
                }
            }
            
            // Receiver state machine
            match rx_state {
                RxState::Idle => {
                    if rx_sync == 2'b01 {  // Falling edge detected
                        rx_state <= RxState::StartBit;
                        rx_baud_counter <= BAUD_DIV / 2;  // Sample in middle
                    }
                },
                RxState::StartBit => {
                    if rx_baud_tick {
                        if rx_sync[1] == 0 {  // Valid start bit
                            rx_state <= RxState::DataBits;
                            rx_bit_counter <= 0;
                        } else {
                            rx_state <= RxState::Idle;  // False start
                        }
                    }
                },
                RxState::DataBits => {
                    if rx_baud_tick {
                        rx_shift_reg <= {rx_sync[1], rx_shift_reg[7:1]};
                        if rx_bit_counter == 7 {
                            rx_state <= RxState::StopBit;
                        } else {
                            rx_bit_counter <= rx_bit_counter + 1;
                        }
                    }
                },
                RxState::StopBit => {
                    if rx_baud_tick {
                        rx_state <= RxState::Idle;
                    }
                }
            }
        }
    }
    
    // Transmitter outputs
    tx_baud_tick = (tx_baud_counter == BAUD_DIV - 1);
    tx_busy = (tx_state != TxState::Idle);
    tx = match tx_state {
        TxState::Idle => 1,
        TxState::StartBit => 0,
        TxState::DataBits => tx_shift_reg[0],
        TxState::StopBit => 1
    };
    
    // Receiver outputs
    rx_baud_tick = (rx_baud_counter == BAUD_DIV - 1);
    rx_data = rx_shift_reg;
    rx_ready = (rx_state == RxState::StopBit) && rx_baud_tick && (rx_sync[1] == 1);
    rx_error = (rx_state == RxState::StopBit) && rx_baud_tick && (rx_sync[1] == 0);
    
    // Verification properties
    assert property (tx_start && !tx_busy |=> tx_busy) @(posedge clk);
    assert property (rx_ready -> !rx_error) @(posedge clk);
}
