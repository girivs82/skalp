// Vector Type Traits for SKALP
//
// This file demonstrates:
// - Generic traits with associated constants
// - Type-level programming with const generics
// - Default implementations for common operations
// - Trait composition and bounds

/// Core trait for vector types (vec2, vec3, vec4)
trait Vector<T> where T: Synthesizable {
    /// Number of components in this vector
    const DIM: nat

    /// Type of each component
    type Scalar = T

    /// Get component by index (0-based)
    fn get(self, index: nat) -> T

    /// Set component by index
    fn set(self, index: nat, value: T) -> Self

    // Component-wise operations with default implementations
    fn add(self, other: Self) -> Self
    fn sub(self, other: Self) -> Self
    fn mul(self, other: Self) -> Self  // Hadamard product
    fn div(self, other: Self) -> Self

    /// Scalar multiplication
    fn scale(self, scalar: T) -> Self

    /// Dot product (returns scalar)
    fn dot(self, other: Self) -> T

    /// Length squared (dot product with self)
    fn length_sq(self) -> T {
        self.dot(self)
    }

    /// Check if all components are zero
    fn is_zero(self) -> bit

    /// Component-wise equality
    fn equals(self, other: Self) -> bit

    /// Negate all components
    fn negate(self) -> Self

    /// Component-wise absolute value
    fn abs(self) -> Self

    /// Component-wise minimum
    fn min_components(self, other: Self) -> Self

    /// Component-wise maximum
    fn max_components(self, other: Self) -> Self

    /// Component-wise clamp
    fn clamp(self, min_val: Self, max_val: Self) -> Self {
        self.max_components(min_val).min_components(max_val)
    }

    /// Linear interpolation
    fn lerp(self, other: Self, t: T) -> Self where T: FloatingPoint {
        // lerp(a, b, t) = a + (b - a) * t
        let diff = other.sub(self);
        self.add(diff.scale(t))
    }

    /// Zero vector
    fn zero() -> Self

    /// Unit vector (all components = 1)
    fn one() -> Self
}

/// Trait for 2D vector specific operations
trait Vector2<T>: Vector<T> where T: Synthesizable {
    /// Access x component
    fn x(self) -> T

    /// Access y component
    fn y(self) -> T

    /// Create from components
    fn new(x: T, y: T) -> Self

    /// Perpendicular vector (rotate 90° counter-clockwise)
    fn perpendicular(self) -> Self {
        Self::new(self.y().negate(), self.x())
    }

    /// 2D cross product (returns scalar: x1*y2 - y1*x2)
    fn cross_scalar(self, other: Self) -> T
}

/// Trait for 3D vector specific operations
trait Vector3<T>: Vector<T> where T: Synthesizable {
    /// Access x component
    fn x(self) -> T

    /// Access y component
    fn y(self) -> T

    /// Access z component
    fn z(self) -> T

    /// Create from components
    fn new(x: T, y: T, z: T) -> Self

    /// 3D cross product (returns vector)
    fn cross(self, other: Self) -> Self
}

/// Trait for 4D vector specific operations
trait Vector4<T>: Vector<T> where T: Synthesizable {
    /// Access x component
    fn x(self) -> T

    /// Access y component
    fn y(self) -> T

    /// Access z component
    fn z(self) -> T

    /// Access w component
    fn w(self) -> T

    /// Create from components
    fn new(x: T, y: T, z: T, w: T) -> Self

    /// Create from vec3 and w
    fn from_vec3(xyz: impl Vector3<T>, w: T) -> Self {
        Self::new(xyz.x(), xyz.y(), xyz.z(), w)
    }

    /// Extract xyz as vec3
    fn xyz(self) -> impl Vector3<T>
}

/// Trait for floating-point vectors (enables length, normalize, etc.)
trait FloatVector<T>: Vector<T> where T: FloatingPoint {
    /// Vector length/magnitude (√(x² + y² + z²))
    fn length(self) -> T {
        self.length_sq().sqrt()
    }

    /// Distance to another vector
    fn distance(self, other: Self) -> T {
        self.sub(other).length()
    }

    /// Distance squared (avoids sqrt)
    fn distance_sq(self, other: Self) -> T {
        self.sub(other).length_sq()
    }

    /// Normalize to unit vector (length = 1)
    fn normalize(self) -> Self {
        let len = self.length();
        self.scale(T::one().div(len))
    }

    /// Reflect vector across normal
    fn reflect(self, normal: Self) -> Self {
        // reflect(v, n) = v - 2 * dot(v, n) * n
        let d = self.dot(normal);
        let two = T::one().add(T::one());
        let scale = two.mul(d);
        self.sub(normal.scale(scale))
    }

    /// Refract vector through surface
    fn refract(self, normal: Self, eta: T) -> Self where T: FloatMath {
        // Snell's law: eta_i * sin(theta_i) = eta_t * sin(theta_t)
        let n_dot_i = normal.dot(self);
        let k = T::one().sub(
            eta.mul(eta).mul(
                T::one().sub(n_dot_i.mul(n_dot_i))
            )
        );

        if k.less_than(T::zero()) {
            // Total internal reflection
            Self::zero()
        } else {
            let a = self.scale(eta);
            let b = normal.scale(eta.mul(n_dot_i).add(k.sqrt()));
            a.sub(b)
        }
    }

    /// Project this vector onto another
    fn project(self, onto: Self) -> Self {
        // proj_b(a) = (a·b / b·b) * b
        let dot_ab = self.dot(onto);
        let dot_bb = onto.dot(onto);
        onto.scale(dot_ab.div(dot_bb))
    }

    /// Angle between vectors (in radians)
    fn angle_between(self, other: Self) -> T where T: FloatMath {
        // θ = acos(dot(a,b) / (|a| * |b|))
        let dot = self.dot(other);
        let len_product = self.length().mul(other.length());
        dot.div(len_product).acos()
    }
}

/// Generic N-dimensional vector operations
trait VectorN<T, const N: nat>: Vector<T>
where
    T: Synthesizable,
    N: > 0
{
    /// Sum of all components
    fn sum(self) -> T

    /// Product of all components
    fn product(self) -> T

    /// Minimum component value
    fn min_component(self) -> T

    /// Maximum component value
    fn max_component(self) -> T

    /// Average of all components
    fn average(self) -> T where T: FloatingPoint {
        let n = T::from_int(N);
        self.sum().div(n)
    }
}

// Example implementation for vec2<fp32>
impl Vector<fp32> for vec2<fp32> {
    const DIM: nat = 2
    type Scalar = fp32

    fn get(self, index: nat) -> fp32 {
        match index {
            0 => self.x,
            1 => self.y,
            _ => fp32::zero()  // Out of bounds returns zero
        }
    }

    fn set(self, index: nat, value: fp32) -> Self {
        match index {
            0 => vec2::new(value, self.y),
            1 => vec2::new(self.x, value),
            _ => self  // Out of bounds returns unchanged
        }
    }

    fn add(self, other: Self) -> Self {
        vec2::new(self.x + other.x, self.y + other.y)
    }

    fn sub(self, other: Self) -> Self {
        vec2::new(self.x - other.x, self.y - other.y)
    }

    fn mul(self, other: Self) -> Self {
        vec2::new(self.x * other.x, self.y * other.y)
    }

    fn div(self, other: Self) -> Self {
        vec2::new(self.x / other.x, self.y / other.y)
    }

    fn scale(self, scalar: fp32) -> Self {
        vec2::new(self.x * scalar, self.y * scalar)
    }

    fn dot(self, other: Self) -> fp32 {
        (self.x * other.x) + (self.y * other.y)
    }

    fn is_zero(self) -> bit {
        self.x == fp32::zero() && self.y == fp32::zero()
    }

    fn equals(self, other: Self) -> bit {
        self.x == other.x && self.y == other.y
    }

    fn negate(self) -> Self {
        vec2::new(-self.x, -self.y)
    }

    fn abs(self) -> Self {
        vec2::new(self.x.abs(), self.y.abs())
    }

    fn min_components(self, other: Self) -> Self {
        vec2::new(self.x.min(other.x), self.y.min(other.y))
    }

    fn max_components(self, other: Self) -> Self {
        vec2::new(self.x.max(other.x), self.y.max(other.y))
    }

    fn zero() -> Self {
        vec2::new(fp32::zero(), fp32::zero())
    }

    fn one() -> Self {
        vec2::new(fp32::one(), fp32::one())
    }
}

impl Vector2<fp32> for vec2<fp32> {
    fn x(self) -> fp32 { self.x }
    fn y(self) -> fp32 { self.y }

    fn new(x: fp32, y: fp32) -> Self {
        // Hardware constructor - creates packed vector
        vec2 { x, y }
    }

    fn cross_scalar(self, other: Self) -> fp32 {
        (self.x * other.y) - (self.y * other.x)
    }
}

impl FloatVector<fp32> for vec2<fp32> where fp32: FloatingPoint {}
