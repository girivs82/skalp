// IEEE 754 Single-Precision Floating-Point Multiplier
//
// This entity demonstrates pipelined FP multiplication with SKALP.
// Can be instantiated as combinational or registered stages.
//
// Format: fp32 = [31] sign | [30:23] exponent | [22:0] mantissa
//
// Algorithm:
// 1. Unpack operands
// 2. Handle special cases (NaN, Inf, zero)
// 3. Multiply mantissas (24-bit × 24-bit = 48-bit)
// 4. Add exponents and subtract bias
// 5. Normalize product
// 6. Round result
// 7. Pack result

entity FP32Mul {
    in a: fp32
    in b: fp32
    out result: fp32
    out flags: bit<5>  // [4]=invalid [3]=div_by_zero [2]=overflow [1]=underflow [0]=inexact
}

impl FP32Mul {
    // Unpack operands
    signal a_sign: bit = a[31]
    signal a_exp: bit<8> = a[30:23]
    signal a_mant: bit<23> = a[22:0]

    signal b_sign: bit = b[31]
    signal b_exp: bit<8> = b[30:23]
    signal b_mant: bit<23> = b[22:0]

    // Special case detection
    signal a_is_zero: bit = (a_exp == 8'b00000000) && (a_mant == 23'b0)
    signal b_is_zero: bit = (b_exp == 8'b00000000) && (b_mant == 23'b0)

    signal a_is_inf: bit = (a_exp == 8'b11111111) && (a_mant == 23'b0)
    signal b_is_inf: bit = (b_exp == 8'b11111111) && (b_mant == 23'b0)

    signal a_is_nan: bit = (a_exp == 8'b11111111) && (a_mant != 23'b0)
    signal b_is_nan: bit = (b_exp == 8'b11111111) && (b_mant != 23'b0)

    signal a_is_denorm: bit = (a_exp == 8'b00000000) && (a_mant != 23'b0)
    signal b_is_denorm: bit = (b_exp == 8'b00000000) && (b_mant != 23'b0)

    // Result sign (XOR of input signs)
    signal result_sign: bit = a_sign ^ b_sign

    // Add implicit leading 1 for normalized numbers
    signal a_mant_full: bit<24> = if a_is_denorm {
        {1'b0, a_mant}
    } else {
        {1'b1, a_mant}
    }

    signal b_mant_full: bit<24> = if b_is_denorm {
        {1'b0, b_mant}
    } else {
        {1'b1, b_mant}
    }

    // Mantissa multiplication: 24-bit × 24-bit = 48-bit product
    // Format: 1.mantissa × 1.mantissa = XX.product
    // Result is in range [1.0, 4.0), so top bit may be 0 or 1
    signal mant_product: bit<48> = a_mant_full * b_mant_full

    // Exponent addition (subtract bias once since we added it twice)
    // Bias = 127, so we add exponents and subtract 127
    signal exp_sum: bit<9> = {1'b0, a_exp} + {1'b0, b_exp} - 9'd127

    // Normalize: check if product overflowed to 48th bit
    signal product_overflow: bit = mant_product[47]

    // Normalized mantissa: shift right if overflow
    signal norm_mant: bit<24> = if product_overflow {
        mant_product[47:24]
    } else {
        mant_product[46:23]
    }

    // Adjusted exponent: add 1 if we shifted right
    signal norm_exp: bit<9> = if product_overflow {
        exp_sum + 9'd1
    } else {
        exp_sum
    }

    // Guard, Round, Sticky bits for rounding
    signal guard_bit: bit = if product_overflow {
        mant_product[23]
    } else {
        mant_product[22]
    }

    signal round_bit: bit = if product_overflow {
        mant_product[22]
    } else {
        mant_product[21]
    }

    signal sticky_bit: bit = if product_overflow {
        |mant_product[21:0]  // OR reduction
    } else {
        |mant_product[20:0]
    }

    // Rounding (round to nearest, ties to even)
    signal round_up: bit = guard_bit && (round_bit || sticky_bit || norm_mant[0])

    signal final_mant: bit<23> = if round_up {
        norm_mant[23:1] + 23'd1
    } else {
        norm_mant[23:1]
    }

    // Check for exponent overflow/underflow
    signal exp_overflow: bit = norm_exp[8] || (norm_exp >= 9'd255)
    signal exp_underflow: bit = norm_exp[8] || (norm_exp < 9'd1)

    signal final_exp: bit<8> = if exp_overflow {
        8'b11111111  // Infinity
    } else if exp_underflow {
        8'b00000000  // Zero (flush denormals to zero for simplicity)
    } else {
        norm_exp[7:0]
    }

    // Special case results
    signal result_is_nan: bit = a_is_nan || b_is_nan ||
                                (a_is_zero && b_is_inf) ||
                                (a_is_inf && b_is_zero)

    signal result_is_inf: bit = ((a_is_inf || b_is_inf) &&
                                 !(a_is_zero || b_is_zero)) ||
                                exp_overflow

    signal result_is_zero: bit = a_is_zero || b_is_zero || exp_underflow

    // Pack result
    result = if result_is_nan {
        32'hFFC00000  // Canonical quiet NaN
    } else if result_is_inf {
        {result_sign, 8'b11111111, 23'b0}
    } else if result_is_zero {
        {result_sign, 8'b00000000, 23'b0}
    } else {
        {result_sign, final_exp, final_mant}
    }

    // Exception flags
    signal flag_invalid: bit = result_is_nan
    signal flag_overflow: bit = exp_overflow && !result_is_nan
    signal flag_underflow: bit = exp_underflow && !a_is_zero && !b_is_zero
    signal flag_inexact: bit = guard_bit || round_bit || sticky_bit

    flags = {flag_invalid, 1'b0, flag_overflow, flag_underflow, flag_inexact}
}
