// CORDIC (COordinate Rotation DIgital Computer) Core
//
// Hardware algorithm for computing transcendental functions:
// - sin/cos via rotation mode
// - sqrt via vectoring mode
// - arctan/arccos via vectoring mode
//
// All implementations are fully synthesizable.

use skalp::numeric::formats::{FloatFormat, IEEE754_32, fp32};

// ============================================================================
// Constants
// ============================================================================

/// CORDIC gain constant K = prod(1/sqrt(1 + 2^(-2i))) for 16 iterations
/// K ≈ 0.6072529350088812561694
/// We pre-multiply inputs or post-divide outputs by this factor
pub const CORDIC_GAIN_16: fp32 = 0.6072529350088813;

/// Inverse CORDIC gain (1/K) for normalization
pub const CORDIC_GAIN_INV_16: fp32 = 1.6467602581210656;

/// PI constant
pub const PI: fp32 = 3.14159265358979323846;

/// PI/2 constant
pub const PI_HALF: fp32 = 1.57079632679489661923;

/// Precomputed arctangent lookup table: atan(2^-i) for i = 0..15
/// These are the elementary angles for CORDIC rotation
pub const ATAN_TABLE: fp32[16] = [
    0.7853981633974483,   // atan(2^0)  = 45.0 degrees
    0.4636476090008061,   // atan(2^-1) = 26.565 degrees
    0.24497866312686414,  // atan(2^-2) = 14.036 degrees
    0.12435499454676144,  // atan(2^-3) = 7.125 degrees
    0.06241880999595735,  // atan(2^-4) = 3.576 degrees
    0.031239833430268277, // atan(2^-5) = 1.790 degrees
    0.015623728620476831, // atan(2^-6) = 0.895 degrees
    0.007812341060101111, // atan(2^-7) = 0.448 degrees
    0.0039062301319669718,// atan(2^-8) = 0.224 degrees
    0.0019531225164788188,// atan(2^-9) = 0.112 degrees
    0.0009765621895593195,// atan(2^-10) = 0.056 degrees
    0.0004882812111948983,// atan(2^-11) = 0.028 degrees
    0.00024414062014936177,// atan(2^-12) = 0.014 degrees
    0.00012207031189367021,// atan(2^-13) = 0.007 degrees
    0.00006103515617420877,// atan(2^-14) = 0.0035 degrees
    0.000030517578115526096 // atan(2^-15) = 0.00175 degrees
];

/// Power of two table: 2^-i for i = 0..15
/// Used for shift operations in CORDIC iterations
pub const POW2_NEG_TABLE: fp32[16] = [
    1.0,
    0.5,
    0.25,
    0.125,
    0.0625,
    0.03125,
    0.015625,
    0.0078125,
    0.00390625,
    0.001953125,
    0.0009765625,
    0.00048828125,
    0.000244140625,
    0.0001220703125,
    0.00006103515625,
    0.000030517578125
];

// ============================================================================
// CORDIC Rotation Mode - For sin/cos
// ============================================================================

/// Single CORDIC rotation iteration
///
/// Given (x, y, z), rotate by sigma * atan(2^-i) where sigma = sign(z)
/// x_new = x - sigma * y * 2^-i
/// y_new = y + sigma * x * 2^-i
/// z_new = z - sigma * atan(2^-i)
pub entity CordicRotateIteration {
    in x: fp32
    in y: fp32
    in z: fp32
    in shift_factor: fp32   // 2^-i
    in atan_val: fp32       // atan(2^-i)
    out x_out: fp32
    out y_out: fp32
    out z_out: fp32
}

impl CordicRotateIteration {
    // Determine rotation direction: rotate toward z=0
    signal sigma: bit = z >= 0.0fp32

    // Shifted values (multiply by 2^-i)
    signal x_shift: fp32 = x * shift_factor
    signal y_shift: fp32 = y * shift_factor

    // Conditional rotation based on sigma
    x_out = sigma ? (x - y_shift) : (x + y_shift)
    y_out = sigma ? (y + x_shift) : (y - x_shift)
    z_out = sigma ? (z - atan_val) : (z + atan_val)
}

/// CORDIC rotation mode: compute (cos(angle), sin(angle))
///
/// Start with (K, 0, angle) and iterate to drive z toward 0
/// Result: x ≈ cos(angle), y ≈ sin(angle)
///
/// Input angle must be in range [-PI/2, PI/2]
pub entity CordicRotate16 {
    in angle: fp32
    out cos_out: fp32
    out sin_out: fp32
}

impl CordicRotate16 {
    // Initialize: x = 1/K (pre-scaled), y = 0, z = angle
    // Using 1/K means output doesn't need post-scaling
    signal x0: fp32 = CORDIC_GAIN_INV_16
    signal y0: fp32 = 0.0fp32
    signal z0: fp32 = angle

    // Iteration 0
    signal x1: fp32
    signal y1: fp32
    signal z1: fp32
    let iter0 = CordicRotateIteration {
        x: x0, y: y0, z: z0,
        shift_factor: POW2_NEG_TABLE[0],
        atan_val: ATAN_TABLE[0],
        x_out: x1, y_out: y1, z_out: z1
    }

    // Iteration 1
    signal x2: fp32
    signal y2: fp32
    signal z2: fp32
    let iter1 = CordicRotateIteration {
        x: x1, y: y1, z: z1,
        shift_factor: POW2_NEG_TABLE[1],
        atan_val: ATAN_TABLE[1],
        x_out: x2, y_out: y2, z_out: z2
    }

    // Iteration 2
    signal x3: fp32
    signal y3: fp32
    signal z3: fp32
    let iter2 = CordicRotateIteration {
        x: x2, y: y2, z: z2,
        shift_factor: POW2_NEG_TABLE[2],
        atan_val: ATAN_TABLE[2],
        x_out: x3, y_out: y3, z_out: z3
    }

    // Iteration 3
    signal x4: fp32
    signal y4: fp32
    signal z4: fp32
    let iter3 = CordicRotateIteration {
        x: x3, y: y3, z: z3,
        shift_factor: POW2_NEG_TABLE[3],
        atan_val: ATAN_TABLE[3],
        x_out: x4, y_out: y4, z_out: z4
    }

    // Iteration 4
    signal x5: fp32
    signal y5: fp32
    signal z5: fp32
    let iter4 = CordicRotateIteration {
        x: x4, y: y4, z: z4,
        shift_factor: POW2_NEG_TABLE[4],
        atan_val: ATAN_TABLE[4],
        x_out: x5, y_out: y5, z_out: z5
    }

    // Iteration 5
    signal x6: fp32
    signal y6: fp32
    signal z6: fp32
    let iter5 = CordicRotateIteration {
        x: x5, y: y5, z: z5,
        shift_factor: POW2_NEG_TABLE[5],
        atan_val: ATAN_TABLE[5],
        x_out: x6, y_out: y6, z_out: z6
    }

    // Iteration 6
    signal x7: fp32
    signal y7: fp32
    signal z7: fp32
    let iter6 = CordicRotateIteration {
        x: x6, y: y6, z: z6,
        shift_factor: POW2_NEG_TABLE[6],
        atan_val: ATAN_TABLE[6],
        x_out: x7, y_out: y7, z_out: z7
    }

    // Iteration 7
    signal x8: fp32
    signal y8: fp32
    signal z8: fp32
    let iter7 = CordicRotateIteration {
        x: x7, y: y7, z: z7,
        shift_factor: POW2_NEG_TABLE[7],
        atan_val: ATAN_TABLE[7],
        x_out: x8, y_out: y8, z_out: z8
    }

    // Iteration 8
    signal x9: fp32
    signal y9: fp32
    signal z9: fp32
    let iter8 = CordicRotateIteration {
        x: x8, y: y8, z: z8,
        shift_factor: POW2_NEG_TABLE[8],
        atan_val: ATAN_TABLE[8],
        x_out: x9, y_out: y9, z_out: z9
    }

    // Iteration 9
    signal x10: fp32
    signal y10: fp32
    signal z10: fp32
    let iter9 = CordicRotateIteration {
        x: x9, y: y9, z: z9,
        shift_factor: POW2_NEG_TABLE[9],
        atan_val: ATAN_TABLE[9],
        x_out: x10, y_out: y10, z_out: z10
    }

    // Iteration 10
    signal x11: fp32
    signal y11: fp32
    signal z11: fp32
    let iter10 = CordicRotateIteration {
        x: x10, y: y10, z: z10,
        shift_factor: POW2_NEG_TABLE[10],
        atan_val: ATAN_TABLE[10],
        x_out: x11, y_out: y11, z_out: z11
    }

    // Iteration 11
    signal x12: fp32
    signal y12: fp32
    signal z12: fp32
    let iter11 = CordicRotateIteration {
        x: x11, y: y11, z: z11,
        shift_factor: POW2_NEG_TABLE[11],
        atan_val: ATAN_TABLE[11],
        x_out: x12, y_out: y12, z_out: z12
    }

    // Iteration 12
    signal x13: fp32
    signal y13: fp32
    signal z13: fp32
    let iter12 = CordicRotateIteration {
        x: x12, y: y12, z: z12,
        shift_factor: POW2_NEG_TABLE[12],
        atan_val: ATAN_TABLE[12],
        x_out: x13, y_out: y13, z_out: z13
    }

    // Iteration 13
    signal x14: fp32
    signal y14: fp32
    signal z14: fp32
    let iter13 = CordicRotateIteration {
        x: x13, y: y13, z: z13,
        shift_factor: POW2_NEG_TABLE[13],
        atan_val: ATAN_TABLE[13],
        x_out: x14, y_out: y14, z_out: z14
    }

    // Iteration 14
    signal x15: fp32
    signal y15: fp32
    signal z15: fp32
    let iter14 = CordicRotateIteration {
        x: x14, y: y14, z: z14,
        shift_factor: POW2_NEG_TABLE[14],
        atan_val: ATAN_TABLE[14],
        x_out: x15, y_out: y15, z_out: z15
    }

    // Iteration 15 (final)
    signal x16: fp32
    signal y16: fp32
    signal z16: fp32
    let iter15 = CordicRotateIteration {
        x: x15, y: y15, z: z15,
        shift_factor: POW2_NEG_TABLE[15],
        atan_val: ATAN_TABLE[15],
        x_out: x16, y_out: y16, z_out: z16
    }

    // Final results
    cos_out = x16
    sin_out = y16
}

// ============================================================================
// CORDIC Vectoring Mode - For sqrt, atan
// ============================================================================

/// Single CORDIC vectoring iteration
///
/// Given (x, y, z), rotate by sigma * atan(2^-i) where sigma = -sign(y)
/// This drives y toward 0, accumulating angle in z
pub entity CordicVectorIteration {
    in x: fp32
    in y: fp32
    in z: fp32
    in shift_factor: fp32
    in atan_val: fp32
    out x_out: fp32
    out y_out: fp32
    out z_out: fp32
}

impl CordicVectorIteration {
    // Determine rotation direction: rotate to drive y toward 0
    signal sigma: bit = y < 0.0fp32

    // Shifted values
    signal x_shift: fp32 = x * shift_factor
    signal y_shift: fp32 = y * shift_factor

    // Conditional rotation based on sigma
    x_out = sigma ? (x - y_shift) : (x + y_shift)
    y_out = sigma ? (y + x_shift) : (y - x_shift)
    z_out = sigma ? (z - atan_val) : (z + atan_val)
}

/// CORDIC vectoring mode: compute atan2(y, x) and magnitude
///
/// Start with (x, y, 0) and iterate to drive y toward 0
/// Result: x ≈ K * sqrt(x^2 + y^2), z ≈ atan2(y, x)
pub entity CordicVector16 {
    in x_in: fp32
    in y_in: fp32
    out magnitude: fp32  // K * sqrt(x^2 + y^2)
    out angle: fp32      // atan2(y, x)
}

impl CordicVector16 {
    signal x0: fp32 = x_in
    signal y0: fp32 = y_in
    signal z0: fp32 = 0.0fp32

    // Unroll 16 iterations
    signal x1: fp32
    signal y1: fp32
    signal z1: fp32
    let iter0 = CordicVectorIteration {
        x: x0, y: y0, z: z0,
        shift_factor: POW2_NEG_TABLE[0],
        atan_val: ATAN_TABLE[0],
        x_out: x1, y_out: y1, z_out: z1
    }

    signal x2: fp32
    signal y2: fp32
    signal z2: fp32
    let iter1 = CordicVectorIteration {
        x: x1, y: y1, z: z1,
        shift_factor: POW2_NEG_TABLE[1],
        atan_val: ATAN_TABLE[1],
        x_out: x2, y_out: y2, z_out: z2
    }

    signal x3: fp32
    signal y3: fp32
    signal z3: fp32
    let iter2 = CordicVectorIteration {
        x: x2, y: y2, z: z2,
        shift_factor: POW2_NEG_TABLE[2],
        atan_val: ATAN_TABLE[2],
        x_out: x3, y_out: y3, z_out: z3
    }

    signal x4: fp32
    signal y4: fp32
    signal z4: fp32
    let iter3 = CordicVectorIteration {
        x: x3, y: y3, z: z3,
        shift_factor: POW2_NEG_TABLE[3],
        atan_val: ATAN_TABLE[3],
        x_out: x4, y_out: y4, z_out: z4
    }

    signal x5: fp32
    signal y5: fp32
    signal z5: fp32
    let iter4 = CordicVectorIteration {
        x: x4, y: y4, z: z4,
        shift_factor: POW2_NEG_TABLE[4],
        atan_val: ATAN_TABLE[4],
        x_out: x5, y_out: y5, z_out: z5
    }

    signal x6: fp32
    signal y6: fp32
    signal z6: fp32
    let iter5 = CordicVectorIteration {
        x: x5, y: y5, z: z5,
        shift_factor: POW2_NEG_TABLE[5],
        atan_val: ATAN_TABLE[5],
        x_out: x6, y_out: y6, z_out: z6
    }

    signal x7: fp32
    signal y7: fp32
    signal z7: fp32
    let iter6 = CordicVectorIteration {
        x: x6, y: y6, z: z6,
        shift_factor: POW2_NEG_TABLE[6],
        atan_val: ATAN_TABLE[6],
        x_out: x7, y_out: y7, z_out: z7
    }

    signal x8: fp32
    signal y8: fp32
    signal z8: fp32
    let iter7 = CordicVectorIteration {
        x: x7, y: y7, z: z7,
        shift_factor: POW2_NEG_TABLE[7],
        atan_val: ATAN_TABLE[7],
        x_out: x8, y_out: y8, z_out: z8
    }

    signal x9: fp32
    signal y9: fp32
    signal z9: fp32
    let iter8 = CordicVectorIteration {
        x: x8, y: y8, z: z8,
        shift_factor: POW2_NEG_TABLE[8],
        atan_val: ATAN_TABLE[8],
        x_out: x9, y_out: y9, z_out: z9
    }

    signal x10: fp32
    signal y10: fp32
    signal z10: fp32
    let iter9 = CordicVectorIteration {
        x: x9, y: y9, z: z9,
        shift_factor: POW2_NEG_TABLE[9],
        atan_val: ATAN_TABLE[9],
        x_out: x10, y_out: y10, z_out: z10
    }

    signal x11: fp32
    signal y11: fp32
    signal z11: fp32
    let iter10 = CordicVectorIteration {
        x: x10, y: y10, z: z10,
        shift_factor: POW2_NEG_TABLE[10],
        atan_val: ATAN_TABLE[10],
        x_out: x11, y_out: y11, z_out: z11
    }

    signal x12: fp32
    signal y12: fp32
    signal z12: fp32
    let iter11 = CordicVectorIteration {
        x: x11, y: y11, z: z11,
        shift_factor: POW2_NEG_TABLE[11],
        atan_val: ATAN_TABLE[11],
        x_out: x12, y_out: y12, z_out: z12
    }

    signal x13: fp32
    signal y13: fp32
    signal z13: fp32
    let iter12 = CordicVectorIteration {
        x: x12, y: y12, z: z12,
        shift_factor: POW2_NEG_TABLE[12],
        atan_val: ATAN_TABLE[12],
        x_out: x13, y_out: y13, z_out: z13
    }

    signal x14: fp32
    signal y14: fp32
    signal z14: fp32
    let iter13 = CordicVectorIteration {
        x: x13, y: y13, z: z13,
        shift_factor: POW2_NEG_TABLE[13],
        atan_val: ATAN_TABLE[13],
        x_out: x14, y_out: y14, z_out: z14
    }

    signal x15: fp32
    signal y15: fp32
    signal z15: fp32
    let iter14 = CordicVectorIteration {
        x: x14, y: y14, z: z14,
        shift_factor: POW2_NEG_TABLE[14],
        atan_val: ATAN_TABLE[14],
        x_out: x15, y_out: y15, z_out: z15
    }

    signal x16: fp32
    signal y16: fp32
    signal z16: fp32
    let iter15 = CordicVectorIteration {
        x: x15, y: y15, z: z15,
        shift_factor: POW2_NEG_TABLE[15],
        atan_val: ATAN_TABLE[15],
        x_out: x16, y_out: y16, z_out: z16
    }

    magnitude = x16
    angle = z16
}

// ============================================================================
// CORDIC Hyperbolic Mode - For sqrt
// ============================================================================

/// CORDIC hyperbolic iteration for sqrt computation
///
/// Uses the identity: sqrt(x) can be computed via hyperbolic CORDIC
/// Starting with (x+1, x-1) and iterating gives sqrt(x)
pub entity CordicHyperbolicIteration {
    in x: fp32
    in y: fp32
    in shift_factor: fp32
    out x_out: fp32
    out y_out: fp32
}

impl CordicHyperbolicIteration {
    // Determine direction based on y sign
    signal sigma: bit = y >= 0.0fp32

    // Shifted values
    signal x_shift: fp32 = x * shift_factor
    signal y_shift: fp32 = y * shift_factor

    // Hyperbolic rotation (note: + for both unlike circular)
    x_out = sigma ? (x + y_shift) : (x - y_shift)
    y_out = sigma ? (y + x_shift) : (y - x_shift)
}

/// Square root using CORDIC hyperbolic mode
///
/// sqrt(a) is computed by starting with x = a + 0.25, y = a - 0.25
/// After n iterations: x converges to sqrt(a) * K_h
/// where K_h is the hyperbolic CORDIC gain
pub entity CordicSqrt {
    in value: fp32
    out result: fp32
}

impl CordicSqrt {
    // Hyperbolic CORDIC gain for sqrt (approximately 1.2075)
    const K_H_INV: fp32 = 0.8281593609602095;

    // Initialize for sqrt computation
    // x = (a + 0.25), y = (a - 0.25)
    signal x0: fp32 = value + 0.25fp32
    signal y0: fp32 = value - 0.25fp32

    // Hyperbolic CORDIC iterations
    // Note: iterations 4, 13, 40, ... must be repeated for convergence
    signal x1: fp32
    signal y1: fp32
    let iter1 = CordicHyperbolicIteration {
        x: x0, y: y0,
        shift_factor: 0.5fp32,  // 2^-1
        x_out: x1, y_out: y1
    }

    signal x2: fp32
    signal y2: fp32
    let iter2 = CordicHyperbolicIteration {
        x: x1, y: y1,
        shift_factor: 0.25fp32,  // 2^-2
        x_out: x2, y_out: y2
    }

    signal x3: fp32
    signal y3: fp32
    let iter3 = CordicHyperbolicIteration {
        x: x2, y: y2,
        shift_factor: 0.125fp32,  // 2^-3
        x_out: x3, y_out: y3
    }

    // Iteration 4 (first repeat)
    signal x4: fp32
    signal y4: fp32
    let iter4 = CordicHyperbolicIteration {
        x: x3, y: y3,
        shift_factor: 0.0625fp32,  // 2^-4
        x_out: x4, y_out: y4
    }

    // Repeat iteration 4
    signal x4r: fp32
    signal y4r: fp32
    let iter4r = CordicHyperbolicIteration {
        x: x4, y: y4,
        shift_factor: 0.0625fp32,
        x_out: x4r, y_out: y4r
    }

    signal x5: fp32
    signal y5: fp32
    let iter5 = CordicHyperbolicIteration {
        x: x4r, y: y4r,
        shift_factor: 0.03125fp32,  // 2^-5
        x_out: x5, y_out: y5
    }

    signal x6: fp32
    signal y6: fp32
    let iter6 = CordicHyperbolicIteration {
        x: x5, y: y5,
        shift_factor: 0.015625fp32,  // 2^-6
        x_out: x6, y_out: y6
    }

    signal x7: fp32
    signal y7: fp32
    let iter7 = CordicHyperbolicIteration {
        x: x6, y: y6,
        shift_factor: 0.0078125fp32,  // 2^-7
        x_out: x7, y_out: y7
    }

    signal x8: fp32
    signal y8: fp32
    let iter8 = CordicHyperbolicIteration {
        x: x7, y: y7,
        shift_factor: 0.00390625fp32,  // 2^-8
        x_out: x8, y_out: y8
    }

    signal x9: fp32
    signal y9: fp32
    let iter9 = CordicHyperbolicIteration {
        x: x8, y: y8,
        shift_factor: 0.001953125fp32,  // 2^-9
        x_out: x9, y_out: y9
    }

    signal x10: fp32
    signal y10: fp32
    let iter10 = CordicHyperbolicIteration {
        x: x9, y: y9,
        shift_factor: 0.0009765625fp32,  // 2^-10
        x_out: x10, y_out: y10
    }

    signal x11: fp32
    signal y11: fp32
    let iter11 = CordicHyperbolicIteration {
        x: x10, y: y10,
        shift_factor: 0.00048828125fp32,  // 2^-11
        x_out: x11, y_out: y11
    }

    signal x12: fp32
    signal y12: fp32
    let iter12 = CordicHyperbolicIteration {
        x: x11, y: y11,
        shift_factor: 0.000244140625fp32,  // 2^-12
        x_out: x12, y_out: y12
    }

    // Apply gain correction
    result = x12 * K_H_INV
}

// ============================================================================
// Convenience Functions
// ============================================================================

/// Compute sin and cos simultaneously (more efficient than separate calls)
pub fn sincos(angle: fp32) -> (fp32, fp32) {
    signal cos_val: fp32
    signal sin_val: fp32

    let cordic = CordicRotate16 {
        angle: angle,
        cos_out: cos_val,
        sin_out: sin_val
    }

    (sin_val, cos_val)
}

/// Compute atan2(y, x)
pub fn atan2(y: fp32, x: fp32) -> fp32 {
    signal mag: fp32
    signal ang: fp32

    let cordic = CordicVector16 {
        x_in: x,
        y_in: y,
        magnitude: mag,
        angle: ang
    }

    ang
}

/// Compute sqrt using CORDIC
pub fn cordic_sqrt(x: fp32) -> fp32 {
    signal res: fp32

    let sqrt = CordicSqrt {
        value: x,
        result: res
    }

    res
}
