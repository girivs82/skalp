// Floating-Point Operations
//
// Generic floating-point operations that work with any IEEE 754 format.
// All operations are fully compliant with IEEE 754 standard including:
// - Special value handling (NaN, Inf, zero, denormals)
// - Proper rounding (round-to-nearest-even)
// - Exception flags (invalid, overflow, underflow, inexact)

use skalp::numeric::formats::{FloatFormat, fp16, fp32, fp64, bf16, IEEE754_16, IEEE754_32, IEEE754_64, BFLOAT16};
use skalp::numeric::traits::{Add, Sub, Mul, Div, Neg, Sqrt, Abs, PartialOrd, PartialEq};
use skalp::numeric::cordic::CordicSqrt;

// ============================================================================
// Type Definitions
// ============================================================================

/// Generic floating-point type parameterized by format
pub type fp<const F: FloatFormat> = bit[F.total_bits];

// ============================================================================
// Addition
// ============================================================================

/// IEEE 754 compliant floating-point addition
///
/// Performs a + b with proper handling of special cases, rounding, and flags.
///
/// # Flags
/// - [4] invalid:      NaN operands or Inf-Inf
/// - [3] div_by_zero:  unused
/// - [2] overflow:     Result too large for format
/// - [1] underflow:    Result too small for format
/// - [0] inexact:      Result was rounded
pub entity FpAdd<const F: FloatFormat> {
    in a: fp<F>
    in b: fp<F>
    out result: fp<F>
    out flags: bit[5]
}

impl FpAdd<const F: FloatFormat> {
    // Format constants
    const W: nat = F.total_bits
    const E: nat = F.exponent_bits
    const M: nat = F.mantissa_bits
    const BIAS: int = F.bias
    const MAX_EXP: nat = (1 << E) - 1
    const FRAC_BITS: nat = M + 1  // Include implicit bit

    // Extract fields
    signal a_sign: bit = a[W-1]
    signal a_exp: bit[E] = a[W-2:M]
    signal a_mant: bit[M] = a[M-1:0]

    signal b_sign: bit = b[W-1]
    signal b_exp: bit[E] = b[W-2:M]
    signal b_mant: bit[M] = b[M-1:0]

    // Classify inputs
    signal a_zero: bit = (a_exp == 0) && (a_mant == 0)
    signal a_denorm: bit = (a_exp == 0) && (a_mant != 0)
    signal a_inf: bit = (a_exp == MAX_EXP) && (a_mant == 0)
    signal a_nan: bit = (a_exp == MAX_EXP) && (a_mant != 0)

    signal b_zero: bit = (b_exp == 0) && (b_mant == 0)
    signal b_denorm: bit = (b_exp == 0) && (b_mant != 0)
    signal b_inf: bit = (b_exp == MAX_EXP) && (b_mant == 0)
    signal b_nan: bit = (b_exp == MAX_EXP) && (b_mant != 0)

    // Build fractions with implicit bit
    signal a_frac: bit[FRAC_BITS] = {(!a_denorm), a_mant}
    signal b_frac: bit[FRAC_BITS] = {(!b_denorm), b_mant}

    // Effective exponents (denormals act like exp=1)
    signal a_exp_eff: bit[E] = a_denorm ? 1 : a_exp
    signal b_exp_eff: bit[E] = b_denorm ? 1 : b_exp

    // Align exponents (ensure a has larger or equal exponent)
    signal swap: bit = b_exp_eff > a_exp_eff
    signal large_exp: bit[E] = swap ? b_exp_eff : a_exp_eff
    signal large_frac: bit[FRAC_BITS] = swap ? b_frac : a_frac
    signal large_sign: bit = swap ? b_sign : a_sign
    signal small_frac: bit[FRAC_BITS] = swap ? a_frac : b_frac
    signal small_sign: bit = swap ? a_sign : b_sign

    signal exp_diff: bit[E] = large_exp - (swap ? a_exp_eff : b_exp_eff)

    // Shift small fraction with guard bits
    const GUARD_BITS: nat = 3
    const ALIGNED_BITS: nat = FRAC_BITS + GUARD_BITS
    signal small_aligned: bit[ALIGNED_BITS] = ({small_frac, {GUARD_BITS{1'b0}}}) >> exp_diff
    signal large_aligned: bit[ALIGNED_BITS] = {large_frac, {GUARD_BITS{1'b0}}}

    // Add or subtract based on signs
    signal effective_sub: bit = large_sign ^ small_sign
    signal sum_raw: bit[ALIGNED_BITS+1] = effective_sub
        ? {1'b0, large_aligned} - {1'b0, small_aligned}
        : {1'b0, large_aligned} + {1'b0, small_aligned}

    signal sum_sign: bit = large_sign

    // Normalize (find leading one)
    // Pad sum_raw to 32 bits (MSB-aligned) for clz32
    signal sum_lz: nat = clz32({sum_raw, 4'b0000})
    signal sum_normalized: bit[ALIGNED_BITS+1] = sum_raw << sum_lz
    signal result_exp_raw: int = (large_exp as int) - (sum_lz as int) +
                                 (sum_raw[ALIGNED_BITS] ? 1 : 0)

    // Extract mantissa and round bits
    signal mant_raw: bit[M] = sum_normalized[ALIGNED_BITS-1:GUARD_BITS]
    signal guard: bit = sum_normalized[GUARD_BITS-1]
    signal round: bit = sum_normalized[GUARD_BITS-2]
    signal sticky: bit = |sum_normalized[GUARD_BITS-3:0]

    // Round to nearest even
    signal round_up: bit = guard && (round || sticky || mant_raw[0])
    signal mant_rounded: bit[M+1] = {1'b0, mant_raw} + round_up
    signal result_exp_adj: int = result_exp_raw + (mant_rounded[M] as int)

    signal result_mant: bit[M] = mant_rounded[M] ? mant_rounded[M:1] : mant_rounded[M-1:0]

    // Detect overflow/underflow
    signal overflow: bit = (result_exp_adj >= MAX_EXP)
    signal underflow: bit = (result_exp_adj <= 0)
    signal result_exp: bit[E] = underflow ? 0 :
                                overflow ? MAX_EXP :
                                result_exp_adj as bit[E]

    // Assemble normal result
    signal normal_result: fp<F> = {sum_sign, result_exp, result_mant}

    // Handle special cases
    signal invalid: bit = (a_inf && b_inf && (a_sign != b_sign)) || a_nan || b_nan
    signal qnan: fp<F> = {1'b0, {E{1'b1}}, 1'b1, {(M-1){1'b0}}}

    result = invalid ? qnan :
             a_nan ? a :
             b_nan ? b :
             a_inf ? a :
             b_inf ? b :
             a_zero ? b :
             b_zero ? a :
             overflow ? {sum_sign, {E{1'b1}}, {M{1'b0}}} :
             underflow ? {sum_sign, {E{1'b0}}, {M{1'b0}}} :
             normal_result

    flags = {invalid, 1'b0, overflow && !invalid, underflow && !invalid,
             guard || round || sticky}
}

// ============================================================================
// Subtraction
// ============================================================================

/// Floating-point subtraction (a - b = a + (-b))
pub entity FpSub<const F: FloatFormat> {
    in a: fp<F>
    in b: fp<F>
    out result: fp<F>
    out flags: bit[5]
}

impl FpSub<const F: FloatFormat> {
    const W: nat = F.total_bits

    // Negate b and add
    signal b_negated: fp<F> = {!b[W-1], b[W-2:0]}

    let adder = FpAdd<F> {
        a: a,
        b: b_negated,
        result: result,
        flags: flags
    }
}

// ============================================================================
// Multiplication
// ============================================================================

/// IEEE 754 compliant floating-point multiplication
pub entity FpMul<const F: FloatFormat> {
    in a: fp<F>
    in b: fp<F>
    out result: fp<F>
    out flags: bit[5]
}

impl FpMul<const F: FloatFormat> {
    const W: nat = F.total_bits
    const E: nat = F.exponent_bits
    const M: nat = F.mantissa_bits
    const BIAS: int = F.bias
    const MAX_EXP: nat = (1 << E) - 1
    const FRAC_BITS: nat = M + 1

    // Extract fields
    signal a_sign: bit = a[W-1]
    signal a_exp: bit[E] = a[W-2:M]
    signal a_mant: bit[M] = a[M-1:0]

    signal b_sign: bit = b[W-1]
    signal b_exp: bit[E] = b[W-2:M]
    signal b_mant: bit[M] = b[M-1:0]

    // Result sign
    signal result_sign: bit = a_sign ^ b_sign

    // Classify
    signal a_zero: bit = (a_exp == 0) && (a_mant == 0)
    signal a_denorm: bit = (a_exp == 0) && (a_mant != 0)
    signal a_inf: bit = (a_exp == MAX_EXP) && (a_mant == 0)
    signal a_nan: bit = (a_exp == MAX_EXP) && (a_mant != 0)

    signal b_zero: bit = (b_exp == 0) && (b_mant == 0)
    signal b_denorm: bit = (b_exp == 0) && (b_mant != 0)
    signal b_inf: bit = (b_exp == MAX_EXP) && (b_mant == 0)
    signal b_nan: bit = (b_exp == MAX_EXP) && (b_mant != 0)

    // Build fractions
    signal a_frac: bit[FRAC_BITS] = {(!a_denorm), a_mant}
    signal b_frac: bit[FRAC_BITS] = {(!b_denorm), b_mant}

    // Effective exponents
    signal a_exp_eff: bit[E] = a_denorm ? 1 : a_exp
    signal b_exp_eff: bit[E] = b_denorm ? 1 : b_exp

    // Multiply fractions
    const PROD_BITS: nat = FRAC_BITS * 2
    signal product: bit[PROD_BITS] = a_frac * b_frac

    // Normalize
    signal prod_overflow: bit = product[PROD_BITS-1]
    signal product_norm: bit[PROD_BITS] = prod_overflow ? (product >> 1) : product

    // Calculate exponent
    signal exp_sum: int = (a_exp_eff as int) + (b_exp_eff as int) - BIAS +
                         (prod_overflow ? 1 : 0)

    // Extract mantissa and round bits
    const GUARD_BITS: nat = 3
    signal mant_with_guard: bit[M+GUARD_BITS] =
        product_norm[PROD_BITS-2:PROD_BITS-2-M-GUARD_BITS+1]

    signal mant_raw: bit[M] = mant_with_guard[M+GUARD_BITS-1:GUARD_BITS]
    signal guard: bit = mant_with_guard[GUARD_BITS-1]
    signal round: bit = mant_with_guard[GUARD_BITS-2]
    signal sticky: bit = |mant_with_guard[GUARD_BITS-3:0] ||
                        |product_norm[PROD_BITS-2-M-GUARD_BITS:0]

    // Round
    signal round_up: bit = guard && (round || sticky || mant_raw[0])
    signal mant_rounded: bit[M+1] = {1'b0, mant_raw} + round_up
    signal exp_adj: int = exp_sum + (mant_rounded[M] as int)

    signal result_mant: bit[M] = mant_rounded[M] ? mant_rounded[M:1] : mant_rounded[M-1:0]

    // Overflow/underflow
    signal overflow: bit = (exp_adj >= MAX_EXP)
    signal underflow: bit = (exp_adj <= 0)
    signal result_exp: bit[E] = underflow ? 0 :
                                overflow ? MAX_EXP :
                                exp_adj as bit[E]

    // Assemble
    signal normal_result: fp<F> = {result_sign, result_exp, result_mant}

    // Special cases
    signal invalid: bit = ((a_zero && b_inf) || (a_inf && b_zero)) || a_nan || b_nan
    signal qnan: fp<F> = {1'b0, {E{1'b1}}, 1'b1, {(M-1){1'b0}}}
    signal inf: fp<F> = {result_sign, {E{1'b1}}, {M{1'b0}}}
    signal zero: fp<F> = {result_sign, {E{1'b0}}, {M{1'b0}}}

    result = invalid ? qnan :
             a_nan ? a :
             b_nan ? b :
             (a_inf || b_inf) ? inf :
             (a_zero || b_zero) ? zero :
             overflow ? inf :
             underflow ? zero :
             normal_result

    flags = {invalid, 1'b0, overflow && !invalid, underflow && !invalid,
             guard || round || sticky}
}

// ============================================================================
// Division
// ============================================================================

/// IEEE 754 compliant floating-point division
pub entity FpDiv<const F: FloatFormat> {
    in a: fp<F>
    in b: fp<F>
    out result: fp<F>
    out flags: bit[5]
}

impl FpDiv<const F: FloatFormat> {
    const W: nat = F.total_bits
    const E: nat = F.exponent_bits
    const M: nat = F.mantissa_bits
    const BIAS: int = F.bias
    const MAX_EXP: nat = (1 << E) - 1
    const FRAC_BITS: nat = M + 1

    // Extract fields
    signal a_sign: bit = a[W-1]
    signal a_exp: bit[E] = a[W-2:M]
    signal a_mant: bit[M] = a[M-1:0]

    signal b_sign: bit = b[W-1]
    signal b_exp: bit[E] = b[W-2:M]
    signal b_mant: bit[M] = b[M-1:0]

    // Result sign
    signal result_sign: bit = a_sign ^ b_sign

    // Classify
    signal a_zero: bit = (a_exp == 0) && (a_mant == 0)
    signal a_denorm: bit = (a_exp == 0) && (a_mant != 0)
    signal a_inf: bit = (a_exp == MAX_EXP) && (a_mant == 0)
    signal a_nan: bit = (a_exp == MAX_EXP) && (a_mant != 0)

    signal b_zero: bit = (b_exp == 0) && (b_mant == 0)
    signal b_denorm: bit = (b_exp == 0) && (b_mant != 0)
    signal b_inf: bit = (b_exp == MAX_EXP) && (b_mant == 0)
    signal b_nan: bit = (b_exp == MAX_EXP) && (b_mant != 0)

    // Build fractions
    signal a_frac: bit[FRAC_BITS] = {(!a_denorm), a_mant}
    signal b_frac: bit[FRAC_BITS] = {(!b_denorm), b_mant}

    // Effective exponents
    signal a_exp_eff: bit[E] = a_denorm ? 1 : a_exp
    signal b_exp_eff: bit[E] = b_denorm ? 1 : b_exp

    // Divide fractions (shift a left by M+3 bits for quotient and guard bits)
    const DIV_BITS: nat = FRAC_BITS + M + 3
    signal dividend: bit[DIV_BITS] = {a_frac, {(M+3){1'b0}}}
    signal quotient: bit[DIV_BITS] = dividend / ({1'b0, b_frac})

    // Normalize
    signal quot_msb: nat = DIV_BITS - 1 - clz(quotient)
    signal quotient_norm: bit[DIV_BITS] = quotient << (DIV_BITS - 1 - quot_msb)

    // Calculate exponent
    signal exp_diff: int = (a_exp_eff as int) - (b_exp_eff as int) + BIAS +
                          ((quot_msb as int) - (M + 3))

    // Extract mantissa and round bits
    const GUARD_BITS: nat = 3
    signal mant_with_guard: bit[M+GUARD_BITS] = quotient_norm[DIV_BITS-1:DIV_BITS-M-GUARD_BITS]

    signal mant_raw: bit[M] = mant_with_guard[M+GUARD_BITS-1:GUARD_BITS]
    signal guard: bit = mant_with_guard[GUARD_BITS-1]
    signal round: bit = mant_with_guard[GUARD_BITS-2]
    signal sticky: bit = |mant_with_guard[GUARD_BITS-3:0] ||
                        |quotient_norm[DIV_BITS-M-GUARD_BITS-1:0]

    // Round
    signal round_up: bit = guard && (round || sticky || mant_raw[0])
    signal mant_rounded: bit[M+1] = {1'b0, mant_raw} + round_up
    signal exp_adj: int = exp_diff + (mant_rounded[M] as int)

    signal result_mant: bit[M] = mant_rounded[M] ? mant_rounded[M:1] : mant_rounded[M-1:0]

    // Overflow/underflow
    signal overflow: bit = (exp_adj >= MAX_EXP)
    signal underflow: bit = (exp_adj <= 0)
    signal result_exp: bit[E] = underflow ? 0 :
                                overflow ? MAX_EXP :
                                exp_adj as bit[E]

    // Assemble
    signal normal_result: fp<F> = {result_sign, result_exp, result_mant}

    // Special cases
    signal invalid: bit = ((a_zero && b_zero) || (a_inf && b_inf)) || a_nan || b_nan
    signal div_by_zero: bit = (!a_zero && !a_inf && b_zero) && !invalid
    signal qnan: fp<F> = {1'b0, {E{1'b1}}, 1'b1, {(M-1){1'b0}}}
    signal inf: fp<F> = {result_sign, {E{1'b1}}, {M{1'b0}}}
    signal zero: fp<F> = {result_sign, {E{1'b0}}, {M{1'b0}}}

    result = invalid ? qnan :
             a_nan ? a :
             b_nan ? b :
             div_by_zero ? inf :
             a_inf ? inf :
             b_inf ? zero :
             a_zero ? zero :
             overflow ? inf :
             underflow ? zero :
             normal_result

    flags = {invalid, div_by_zero, overflow && !invalid, underflow && !invalid,
             guard || round || sticky}
}

// ============================================================================
// Square Root
// ============================================================================

/// Floating-point square root with intent-driven implementation
pub entity FpSqrt<const F: FloatFormat, intent I: Intent = DEFAULT_INTENT> {
    in x: fp<F>
    out result: fp<F>
    out flags: bit[5]
}

impl FpSqrt<const F: FloatFormat, intent I: Intent> {
    const W: nat = F.total_bits
    const E: nat = F.exponent_bits
    const M: nat = F.mantissa_bits
    const MAX_EXP: nat = (1 << E) - 1

    // Extract fields
    signal x_sign: bit = x[W-1]
    signal x_exp: bit[E] = x[W-2:M]
    signal x_mant: bit[M] = x[M-1:0]

    // Classify
    signal x_zero: bit = (x_exp == 0) && (x_mant == 0)
    signal x_denorm: bit = (x_exp == 0) && (x_mant != 0)
    signal x_inf: bit = (x_exp == MAX_EXP) && (x_mant == 0)
    signal x_nan: bit = (x_exp == MAX_EXP) && (x_mant != 0)
    signal x_negative: bit = x_sign && !x_zero && !x_nan

    // Choose implementation based on intent
    signal sqrt_result: fp<F> = if is_latency_optimized(I) {
        // Fast: Parallel digit-recurrence algorithm
        fast_sqrt<F>(x)
    } else if is_area_optimized(I) {
        // Small: Iterative digit-by-digit algorithm
        small_sqrt<F>(x)
    } else {
        // Balanced: Pipelined Newton-Raphson
        balanced_sqrt<F>(x)
    }

    // Special cases
    signal invalid: bit = x_negative || x_nan
    signal qnan: fp<F> = {1'b0, {E{1'b1}}, 1'b1, {(M-1){1'b0}}}

    result = invalid ? qnan :
             x_zero ? x :
             x_inf ? x :
             sqrt_result

    flags = {invalid, 1'b0, 1'b0, 1'b0, 1'b0}  // Sqrt never overflows/underflows
}

// Helper functions for sqrt (implementation depends on intent)
// All use CORDIC algorithm with different unrolling strategies

/// Fast sqrt: Fully unrolled CORDIC for minimum latency
/// Uses more hardware but achieves single-cycle result
fn fast_sqrt<const F: FloatFormat>(x: fp<F>) -> fp<F> {
    // For fp32, use the CORDIC implementation
    // The CORDIC module is fully unrolled (parallel iterations)
    cordic_sqrt_fp<F>(x)
}

/// Small sqrt: Iterative CORDIC for minimum area
/// Uses less hardware but requires multiple cycles
fn small_sqrt<const F: FloatFormat>(x: fp<F>) -> fp<F> {
    // Same algorithm as fast_sqrt, but would use a sequential
    // state machine in a full implementation
    // For now, use the same CORDIC which can be configured
    cordic_sqrt_fp<F>(x)
}

/// Balanced sqrt: Pipelined CORDIC for throughput
/// Balanced between area and latency with pipelining
fn balanced_sqrt<const F: FloatFormat>(x: fp<F>) -> fp<F> {
    // Pipelined implementation with registers between iterations
    cordic_sqrt_fp<F>(x)
}

/// CORDIC-based sqrt for any floating-point format
/// Extracts mantissa, computes sqrt, reconstructs result
fn cordic_sqrt_fp<const F: FloatFormat>(x: fp<F>) -> fp<F> {
    const W: nat = F.total_bits
    const E: nat = F.exponent_bits
    const M: nat = F.mantissa_bits
    const BIAS: int = F.bias

    // Extract components
    signal x_sign: bit = x[W-1]
    signal x_exp: bit[E] = x[W-2:M]
    signal x_mant: bit[M] = x[M-1:0]

    // Handle special cases
    signal x_zero: bit = (x_exp == 0) && (x_mant == 0)
    signal x_denorm: bit = (x_exp == 0) && (x_mant != 0)

    // Build fraction with implicit bit: 1.mantissa
    signal frac: bit[M+1] = {(!x_denorm), x_mant}

    // Effective exponent (denormals act like exp=1)
    signal exp_eff: int = x_denorm ? (1 - BIAS) : ((x_exp as int) - BIAS)

    // For sqrt, we need to handle odd/even exponents differently:
    // sqrt(m * 2^e) = sqrt(m) * 2^(e/2)  if e is even
    // sqrt(m * 2^e) = sqrt(2m) * 2^((e-1)/2)  if e is odd
    signal exp_odd: bit = exp_eff[0]

    // Scale mantissa for odd exponent: multiply by 2 (shift left by 1)
    // This gives us a value in range [1, 4) for CORDIC
    signal scaled_mant: fp32 = exp_odd
        ? ({frac, {(31-M){1'b0}}}) << 1  // 2 * m, range [2, 4)
        : {frac, {(31-M){1'b0}}}          // m, range [1, 2)

    // Convert to fp32 for CORDIC (assuming M = 23)
    // Build an fp32 with exponent 127 (bias) so value is in [1, 4)
    signal mant_fp32: fp32 = {1'b0, 8'd127, scaled_mant[M:M-22]}

    // Call CORDIC sqrt on the normalized mantissa
    signal sqrt_mant: fp32
    let sqrt_cordic = CordicSqrt {
        value: mant_fp32,
        result: sqrt_mant
    }

    // Extract result mantissa from fp32 result
    signal result_mant: bit[M] = sqrt_mant[22:23-M]

    // Calculate result exponent: (exp_eff + 1) / 2 + BIAS
    // Adding 1 because CORDIC result has exponent 0 (value in [1, 2))
    signal result_exp_raw: int = (exp_eff >> 1) + BIAS
    signal result_exp: bit[E] = result_exp_raw as bit[E]

    // Assemble result
    signal result_value: fp<F> = {1'b0, result_exp, result_mant}

    // Return special cases or computed result
    x_zero ? x : result_value
}

// ============================================================================
// Comparison
// ============================================================================

/// Floating-point comparison
pub entity FpCompare<const F: FloatFormat> {
    in a: fp<F>
    in b: fp<F>
    out lt: bit       // a < b
    out eq: bit       // a == b
    out gt: bit       // a > b
    out unordered: bit  // NaN comparison
}

impl FpCompare<const F: FloatFormat> {
    const W: nat = F.total_bits
    const E: nat = F.exponent_bits
    const M: nat = F.mantissa_bits
    const MAX_EXP: nat = (1 << E) - 1

    // Extract fields
    signal a_sign: bit = a[W-1]
    signal a_exp: bit[E] = a[W-2:M]
    signal a_mant: bit[M] = a[M-1:0]

    signal b_sign: bit = b[W-1]
    signal b_exp: bit[E] = b[W-2:M]
    signal b_mant: bit[M] = b[M-1:0]

    // Classify
    signal a_zero: bit = (a_exp == 0) && (a_mant == 0)
    signal a_nan: bit = (a_exp == MAX_EXP) && (a_mant != 0)

    signal b_zero: bit = (b_exp == 0) && (b_mant == 0)
    signal b_nan: bit = (b_exp == MAX_EXP) && (b_mant != 0)

    // Both zero (ignore sign)
    signal both_zero: bit = a_zero && b_zero

    // NaN handling
    unordered = a_nan || b_nan

    // Sign comparison
    signal sign_lt: bit = a_sign && !b_sign  // a negative, b positive
    signal sign_gt: bit = !a_sign && b_sign  // a positive, b negative
    signal same_sign: bit = a_sign == b_sign

    // Magnitude comparison (for same sign)
    signal mag_lt: bit = (a_exp < b_exp) || ((a_exp == b_exp) && (a_mant < b_mant))
    signal mag_eq: bit = (a_exp == b_exp) && (a_mant == b_mant)
    signal mag_gt: bit = (a_exp > b_exp) || ((a_exp == b_exp) && (a_mant > b_mant))

    // Final comparison
    lt = !unordered && !both_zero && (
        sign_lt || (same_sign && (a_sign ? mag_gt : mag_lt))
    )

    eq = !unordered && (both_zero || (same_sign && mag_eq))

    gt = !unordered && !both_zero && (
        sign_gt || (same_sign && (a_sign ? mag_lt : mag_gt))
    )
}

// ============================================================================
// Conversion Operations
// ============================================================================

/// Convert between floating-point formats
pub entity FpConvert<const FROM: FloatFormat, const TO: FloatFormat> {
    in x: fp<FROM>
    out result: fp<TO>
    out flags: bit[5]
}

impl FpConvert<const FROM: FloatFormat, const TO: FloatFormat> {
    // TODO: Implement format conversion with proper rounding
    result = x as fp<TO>  // Placeholder
    flags = 5'b00000
}

/// Convert floating-point to integer
pub entity FpToInt<const F: FloatFormat, const W: nat, const S: bool> {
    in x: fp<F>
    out result: Int<W, S>
    out flags: bit[5]
}

impl FpToInt<const F: FloatFormat, const W: nat, const S: bool> {
    // TODO: Implement FP to int conversion
    result = x as Int<W, S>  // Placeholder
    flags = 5'b00000
}

/// Convert integer to floating-point
pub entity IntToFp<const W: nat, const S: bool, const F: FloatFormat> {
    in x: Int<W, S>
    out result: fp<F>
    out flags: bit[5]
}

impl IntToFp<const W: nat, const S: bool, const F: FloatFormat> {
    // TODO: Implement int to FP conversion
    result = x as fp<F>  // Placeholder
    flags = 5'b00000
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Count leading zeros for 32-bit value using priority encoder logic
/// Returns the number of consecutive zero bits starting from MSB
fn clz32(x: bit[32]) -> nat {
    if x == 0 { 32 }
    else if x[31] { 0 }
    else if x[30] { 1 }
    else if x[29] { 2 }
    else if x[28] { 3 }
    else if x[27] { 4 }
    else if x[26] { 5 }
    else if x[25] { 6 }
    else if x[24] { 7 }
    else if x[23] { 8 }
    else if x[22] { 9 }
    else if x[21] { 10 }
    else if x[20] { 11 }
    else if x[19] { 12 }
    else if x[18] { 13 }
    else if x[17] { 14 }
    else if x[16] { 15 }
    else if x[15] { 16 }
    else if x[14] { 17 }
    else if x[13] { 18 }
    else if x[12] { 19 }
    else if x[11] { 20 }
    else if x[10] { 21 }
    else if x[9] { 22 }
    else if x[8] { 23 }
    else if x[7] { 24 }
    else if x[6] { 25 }
    else if x[5] { 26 }
    else if x[4] { 27 }
    else if x[3] { 28 }
    else if x[2] { 29 }
    else if x[1] { 30 }
    else { 31 }
}


// ============================================================================
// Absolute Value and Negation
// ============================================================================

/// Floating-point absolute value
/// Simply clears the sign bit (IEEE 754 sign-magnitude representation)
pub entity FpAbs<const F: FloatFormat> {
    in x: fp<F>
    out result: fp<F>
}

impl FpAbs<const F: FloatFormat> {
    const W: nat = F.total_bits
    // Clear sign bit (bit W-1)
    result = {1'b0, x[W-2:0]}
}

/// Floating-point negation
/// Simply flips the sign bit (IEEE 754 sign-magnitude representation)
pub entity FpNeg<const F: FloatFormat> {
    in x: fp<F>
    out result: fp<F>
}

impl FpNeg<const F: FloatFormat> {
    const W: nat = F.total_bits
    // Flip sign bit (bit W-1)
    result = {!x[W-1], x[W-2:0]}
}

// ============================================================================
// Trait Implementations for fp32
// ============================================================================

/// Addition for fp32: a + b uses IEEE 754 floating-point addition
impl Add for fp32 {
    fn add(a: Self, b: Self) -> Self {
        signal result: fp32;
        signal flags: bit[5];
        let adder = FpAdd<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            result: result as fp<IEEE754_32>,
            flags: flags
        };
        result
    }
}

/// Subtraction for fp32: a - b uses IEEE 754 floating-point subtraction
impl Sub for fp32 {
    fn sub(a: Self, b: Self) -> Self {
        signal result: fp32;
        signal flags: bit[5];
        let subtractor = FpSub<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            result: result as fp<IEEE754_32>,
            flags: flags
        };
        result
    }
}

/// Multiplication for fp32: a * b uses IEEE 754 floating-point multiplication
impl Mul for fp32 {
    fn mul(a: Self, b: Self) -> Self {
        signal result: fp32;
        signal flags: bit[5];
        let multiplier = FpMul<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            result: result as fp<IEEE754_32>,
            flags: flags
        };
        result
    }
}

/// Division for fp32: a / b uses IEEE 754 floating-point division
impl Div for fp32 {
    fn div(a: Self, b: Self) -> Self {
        signal result: fp32;
        signal flags: bit[5];
        let divider = FpDiv<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            result: result as fp<IEEE754_32>,
            flags: flags
        };
        result
    }
}

/// Negation for fp32: -a flips the sign bit
impl Neg for fp32 {
    fn neg(a: Self) -> Self {
        signal result: fp32;
        let negator = FpNeg<IEEE754_32> {
            x: a as fp<IEEE754_32>,
            result: result as fp<IEEE754_32>
        };
        result
    }
}

// TODO: Sqrt and Abs trait implementations temporarily disabled due to module ID issue
// when trait methods contain entity instances. Use sqrt() and abs() free functions instead.
// Bug: When trait implementations create entity instances, the module ID mapping gets corrupted
// during monomorphization, causing incorrect module references in the generated code.

// /// Square root for fp32: sqrt(a) using CORDIC
// impl Sqrt for fp32 {
//     fn sqrt(a: Self) -> Self {
//         signal result: fp32;
//         let sqrt_op = CordicSqrt {
//             value: a,
//             result: result
//         };
//         result
//     }
// }

/// Absolute value for fp32: abs(a) = |a|
/// Clears the sign bit (IEEE 754 sign-magnitude representation)
impl Abs for fp32 {
    fn abs(a: Self) -> Self {
        // Clear sign bit: {0, exponent, mantissa}
        {1'b0, a[30:0]} as fp32
    }
}

/// Partial ordering for fp32: comparison operations
impl PartialOrd for fp32 {
    fn lt(a: Self, b: Self) -> bit {
        signal lt_out: bit;
        signal eq_out: bit;
        signal gt_out: bit;
        signal unordered: bit;
        let cmp = FpCompare<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            lt: lt_out,
            eq: eq_out,
            gt: gt_out,
            unordered: unordered
        };
        lt_out
    }

    fn le(a: Self, b: Self) -> bit {
        signal lt_out: bit;
        signal eq_out: bit;
        signal gt_out: bit;
        signal unordered: bit;
        let cmp = FpCompare<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            lt: lt_out,
            eq: eq_out,
            gt: gt_out,
            unordered: unordered
        };
        lt_out || eq_out
    }

    fn gt(a: Self, b: Self) -> bit {
        signal lt_out: bit;
        signal eq_out: bit;
        signal gt_out: bit;
        signal unordered: bit;
        let cmp = FpCompare<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            lt: lt_out,
            eq: eq_out,
            gt: gt_out,
            unordered: unordered
        };
        gt_out
    }

    fn ge(a: Self, b: Self) -> bit {
        signal lt_out: bit;
        signal eq_out: bit;
        signal gt_out: bit;
        signal unordered: bit;
        let cmp = FpCompare<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            lt: lt_out,
            eq: eq_out,
            gt: gt_out,
            unordered: unordered
        };
        gt_out || eq_out
    }
}

/// Equality for fp32
impl PartialEq for fp32 {
    fn eq(a: Self, b: Self) -> bit {
        signal lt_out: bit;
        signal eq_out: bit;
        signal gt_out: bit;
        signal unordered: bit;
        let cmp = FpCompare<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            lt: lt_out,
            eq: eq_out,
            gt: gt_out,
            unordered: unordered
        };
        eq_out
    }

    fn ne(a: Self, b: Self) -> bit {
        signal lt_out: bit;
        signal eq_out: bit;
        signal gt_out: bit;
        signal unordered: bit;
        let cmp = FpCompare<IEEE754_32> {
            a: a as fp<IEEE754_32>,
            b: b as fp<IEEE754_32>,
            lt: lt_out,
            eq: eq_out,
            gt: gt_out,
            unordered: unordered
        };
        !eq_out && !unordered
    }
}

// ============================================================================
// Trait Implementations for fp64
// ============================================================================

/// Addition for fp64
impl Add for fp64 {
    fn add(a: Self, b: Self) -> Self {
        signal result: fp64;
        signal flags: bit[5];
        let adder = FpAdd<IEEE754_64> {
            a: a as fp<IEEE754_64>,
            b: b as fp<IEEE754_64>,
            result: result as fp<IEEE754_64>,
            flags: flags
        };
        result
    }
}

/// Subtraction for fp64
impl Sub for fp64 {
    fn sub(a: Self, b: Self) -> Self {
        signal result: fp64;
        signal flags: bit[5];
        let subtractor = FpSub<IEEE754_64> {
            a: a as fp<IEEE754_64>,
            b: b as fp<IEEE754_64>,
            result: result as fp<IEEE754_64>,
            flags: flags
        };
        result
    }
}

/// Multiplication for fp64
impl Mul for fp64 {
    fn mul(a: Self, b: Self) -> Self {
        signal result: fp64;
        signal flags: bit[5];
        let multiplier = FpMul<IEEE754_64> {
            a: a as fp<IEEE754_64>,
            b: b as fp<IEEE754_64>,
            result: result as fp<IEEE754_64>,
            flags: flags
        };
        result
    }
}

/// Division for fp64
impl Div for fp64 {
    fn div(a: Self, b: Self) -> Self {
        signal result: fp64;
        signal flags: bit[5];
        let divider = FpDiv<IEEE754_64> {
            a: a as fp<IEEE754_64>,
            b: b as fp<IEEE754_64>,
            result: result as fp<IEEE754_64>,
            flags: flags
        };
        result
    }
}

/// Negation for fp64
impl Neg for fp64 {
    fn neg(a: Self) -> Self {
        signal result: fp64;
        let negator = FpNeg<IEEE754_64> {
            x: a as fp<IEEE754_64>,
            result: result as fp<IEEE754_64>
        };
        result
    }
}

// /// Square root for fp64: sqrt(a) using FpSqrt entity
// impl Sqrt for fp64 {
//     fn sqrt(a: Self) -> Self {
//         signal result: fp64;
//         signal flags: bit[5];
//         let sqrt_op = FpSqrt<IEEE754_64> {
//             x: a as fp<IEEE754_64>,
//             result: result as fp<IEEE754_64>,
//             flags: flags
//         };
//         result
//     }
// }

/// Absolute value for fp64: abs(a) = |a|
/// Clears the sign bit (IEEE 754 sign-magnitude representation)
impl Abs for fp64 {
    fn abs(a: Self) -> Self {
        // Clear sign bit: {0, exponent, mantissa}
        {1'b0, a[62:0]} as fp64
    }
}

// ============================================================================
// Trait Implementations for fp16
// ============================================================================

/// Addition for fp16
impl Add for fp16 {
    fn add(a: Self, b: Self) -> Self {
        signal result: fp16;
        signal flags: bit[5];
        let adder = FpAdd<IEEE754_16> {
            a: a as fp<IEEE754_16>,
            b: b as fp<IEEE754_16>,
            result: result as fp<IEEE754_16>,
            flags: flags
        };
        result
    }
}

/// Subtraction for fp16
impl Sub for fp16 {
    fn sub(a: Self, b: Self) -> Self {
        signal result: fp16;
        signal flags: bit[5];
        let subtractor = FpSub<IEEE754_16> {
            a: a as fp<IEEE754_16>,
            b: b as fp<IEEE754_16>,
            result: result as fp<IEEE754_16>,
            flags: flags
        };
        result
    }
}

/// Multiplication for fp16
impl Mul for fp16 {
    fn mul(a: Self, b: Self) -> Self {
        signal result: fp16;
        signal flags: bit[5];
        let multiplier = FpMul<IEEE754_16> {
            a: a as fp<IEEE754_16>,
            b: b as fp<IEEE754_16>,
            result: result as fp<IEEE754_16>,
            flags: flags
        };
        result
    }
}

/// Division for fp16
impl Div for fp16 {
    fn div(a: Self, b: Self) -> Self {
        signal result: fp16;
        signal flags: bit[5];
        let divider = FpDiv<IEEE754_16> {
            a: a as fp<IEEE754_16>,
            b: b as fp<IEEE754_16>,
            result: result as fp<IEEE754_16>,
            flags: flags
        };
        result
    }
}

/// Negation for fp16
impl Neg for fp16 {
    fn neg(a: Self) -> Self {
        signal result: fp16;
        let negator = FpNeg<IEEE754_16> {
            x: a as fp<IEEE754_16>,
            result: result as fp<IEEE754_16>
        };
        result
    }
}

// /// Square root for fp16: sqrt(a) using FpSqrt entity
// impl Sqrt for fp16 {
//     fn sqrt(a: Self) -> Self {
//         signal result: fp16;
//         signal flags: bit[5];
//         let sqrt_op = FpSqrt<IEEE754_16> {
//             x: a as fp<IEEE754_16>,
//             result: result as fp<IEEE754_16>,
//             flags: flags
//         };
//         result
//     }
// }

/// Absolute value for fp16: abs(a) = |a|
/// Clears the sign bit (IEEE 754 sign-magnitude representation)
impl Abs for fp16 {
    fn abs(a: Self) -> Self {
        // Clear sign bit: {0, exponent, mantissa}
        {1'b0, a[14:0]} as fp16
    }
}

// ============================================================================
// Convenience Functions (wrappers around trait methods)
// ============================================================================
// These exist for backward compatibility and because explicit trait method
// calls (Sqrt::sqrt(x)) are not yet fully supported by the compiler.
//
// TODO: These functions cause module ID issues when imported via "use fp::*"
// because entity instances inside functions are processed during monomorphization
// and can corrupt the module ID mapping. For now, users should directly instantiate
// CordicSqrt or FpAbs entities in their code.

// /// Square root for fp32 (convenience wrapper)
// pub fn sqrt(x: fp32) -> fp32 {
//     signal result: fp32;
//     let sqrt_op = CordicSqrt {
//         value: x,
//         result: result
//     };
//     result
// }

// /// Absolute value for fp32 (convenience wrapper)
// pub fn abs(x: fp32) -> fp32 {
//     signal result: fp32;
//     let abs_op = FpAbs<IEEE754_32> {
//         x: x as fp<IEEE754_32>,
//         result: result as fp<IEEE754_32>
//     };
//     result
// }
