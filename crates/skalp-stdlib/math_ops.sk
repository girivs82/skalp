// Mathematical Operations for Hardware
// Hardware-efficient approximations for common math functions

// ============================================================================
// Square Root
// ============================================================================

/// FP32 square root using Newton-Raphson iteration
///
/// Converges in ~3-4 iterations for single precision
///
/// Examples:
///   sqrt_fp32(4.0) = 2.0
///   sqrt_fp32(9.0) = 3.0
///   sqrt_fp32(2.0) = 1.414...
pub fn sqrt_fp32(x: fp32) -> fp32 {
    // Handle special cases
    return match x {
        0.0 => 0.0,
        _ => {
            // Initial guess using bit manipulation trick
            // x_bits >> 1 gives approximate sqrt
            let x_bits = x as bit[32];
            let guess_bits = (x_bits >> 1) + 0x1F800000;  // Adjust exponent
            let mut guess = guess_bits as fp32;

            // Newton-Raphson: x_new = 0.5 * (x_old + N/x_old)
            // Iteration 1
            guess = 0.5 * (guess + x / guess);

            // Iteration 2
            guess = 0.5 * (guess + x / guess);

            // Iteration 3
            guess = 0.5 * (guess + x / guess);

            // Iteration 4 for better precision
            guess = 0.5 * (guess + x / guess);

            guess
        }
    }
}

/// FP32 inverse square root (1/sqrt(x))
///
/// More efficient than sqrt then divide
///
/// Examples:
///   rsqrt_fp32(4.0) = 0.5
///   rsqrt_fp32(9.0) = 0.333...
pub fn rsqrt_fp32(x: fp32) -> fp32 {
    // Fast inverse square root (Quake III method)
    let x_bits = x as bit[32];
    let half_x = 0.5 * x;

    // Magic number for initial approximation
    let i = 0x5f3759df - (x_bits >> 1);
    let mut y = i as fp32;

    // Newton-Raphson refinement: y = y * (1.5 - half*x*y*y)
    y = y * (1.5 - half_x * y * y);
    y = y * (1.5 - half_x * y * y);

    return y
}

// ============================================================================
// Trigonometric Functions
// ============================================================================

/// FP32 sine using polynomial approximation
///
/// Range reduction to [-π, π] then polynomial evaluation
/// Accurate to ~6 decimal places
///
/// Examples:
///   sin_fp32(0.0) = 0.0
///   sin_fp32(π/2) = 1.0
///   sin_fp32(π) = 0.0
pub fn sin_fp32(x: fp32) -> fp32 {
    // Constants
    let pi = 3.14159265;
    let two_pi = 6.28318531;

    // Range reduction: reduce x to [-π, π]
    let mut x_mod = x;

    // Remove multiples of 2π
    let cycles = (x / two_pi) as int[32];
    x_mod = x - (cycles as fp32) * two_pi;

    // Reduce to [-π, π]
    x_mod = match (x_mod > pi) {
        1 => x_mod - two_pi,
        _ => match (x_mod < -pi) {
            1 => x_mod + two_pi,
            _ => x_mod
        }
    };

    // Taylor series approximation: sin(x) ≈ x - x³/6 + x⁵/120 - x⁷/5040
    let x2 = x_mod * x_mod;
    let x3 = x2 * x_mod;
    let x5 = x3 * x2;
    let x7 = x5 * x2;

    return x_mod - x3 / 6.0 + x5 / 120.0 - x7 / 5040.0
}

/// FP32 cosine using polynomial approximation
///
/// cos(x) = sin(x + π/2)
///
/// Examples:
///   cos_fp32(0.0) = 1.0
///   cos_fp32(π/2) = 0.0
///   cos_fp32(π) = -1.0
pub fn cos_fp32(x: fp32) -> fp32 {
    let half_pi = 1.57079633;
    return sin_fp32(x + half_pi)
}

/// FP32 tangent
///
/// tan(x) = sin(x) / cos(x)
///
/// Examples:
///   tan_fp32(0.0) = 0.0
///   tan_fp32(π/4) = 1.0
pub fn tan_fp32(x: fp32) -> fp32 {
    let s = sin_fp32(x);
    let c = cos_fp32(x);
    return s / c
}

/// FP32 arctangent (single argument)
///
/// Range: [-π/2, π/2]
/// Polynomial approximation
///
/// Examples:
///   atan_fp32(0.0) = 0.0
///   atan_fp32(1.0) = π/4 = 0.785...
pub fn atan_fp32(x: fp32) -> fp32 {
    // For |x| > 1, use atan(x) = π/2 - atan(1/x)
    let abs_x = match (x < 0.0) {
        1 => -x,
        _ => x
    };

    let use_reciprocal = abs_x > 1.0;
    let z = match use_reciprocal {
        1 => 1.0 / abs_x,
        _ => abs_x
    };

    // Polynomial approximation for |x| <= 1
    // atan(z) ≈ z - z³/3 + z⁵/5 - z⁷/7 + z⁹/9
    let z2 = z * z;
    let z3 = z2 * z;
    let z5 = z3 * z2;
    let z7 = z5 * z2;
    let z9 = z7 * z2;

    let mut result = z - z3 / 3.0 + z5 / 5.0 - z7 / 7.0 + z9 / 9.0;

    // Adjust for reciprocal case
    result = match use_reciprocal {
        1 => 1.57079633 - result,  // π/2 - result
        _ => result
    };

    // Apply sign
    return match (x < 0.0) {
        1 => -result,
        _ => result
    }
}

/// FP32 arctangent (two arguments) - atan2
///
/// Returns angle in radians between [-π, π]
/// Handles all quadrants correctly
///
/// Examples:
///   atan2_fp32(1.0, 0.0) = π/2
///   atan2_fp32(0.0, 1.0) = 0.0
///   atan2_fp32(-1.0, 0.0) = -π/2
///   atan2_fp32(0.0, -1.0) = π
pub fn atan2_fp32(y: fp32, x: fp32) -> fp32 {
    let pi = 3.14159265;

    // Handle special cases
    return match x {
        0.0 => match y {
            0.0 => 0.0,
            _ => match (y > 0.0) {
                1 => 1.57079633,   // π/2
                _ => -1.57079633   // -π/2
            }
        },
        _ => {
            let angle = atan_fp32(y / x);

            // Adjust for quadrant
            match (x < 0.0) {
                1 => match (y >= 0.0) {
                    1 => angle + pi,
                    _ => angle - pi
                },
                _ => angle
            }
        }
    }
}

/// FP32 arcsine
///
/// Range: [-π/2, π/2]
/// Uses atan2 for better accuracy
///
/// Examples:
///   asin_fp32(0.0) = 0.0
///   asin_fp32(1.0) = π/2
///   asin_fp32(0.5) = π/6
pub fn asin_fp32(x: fp32) -> fp32 {
    // asin(x) = atan2(x, sqrt(1 - x²))
    let one_minus_x2 = 1.0 - x * x;
    let sqrt_term = sqrt_fp32(one_minus_x2);
    return atan2_fp32(x, sqrt_term)
}

/// FP32 arccosine
///
/// Range: [0, π]
/// Uses asin: acos(x) = π/2 - asin(x)
///
/// Examples:
///   acos_fp32(1.0) = 0.0
///   acos_fp32(0.0) = π/2
///   acos_fp32(-1.0) = π
pub fn acos_fp32(x: fp32) -> fp32 {
    let half_pi = 1.57079633;
    return half_pi - asin_fp32(x)
}

// ============================================================================
// Exponential and Logarithm
// ============================================================================

/// FP32 natural logarithm (base e)
///
/// Uses bit manipulation and polynomial approximation
///
/// Examples:
///   ln_fp32(1.0) = 0.0
///   ln_fp32(e) = 1.0
///   ln_fp32(10.0) = 2.302...
pub fn ln_fp32(x: fp32) -> fp32 {
    // Handle special cases
    return match x {
        0.0 => -1000000.0,  // -infinity approximation
        1.0 => 0.0,
        _ => {
            // Extract exponent and mantissa
            let x_bits = x as bit[32];
            let exponent_bits = x_bits[30:23];
            let mantissa_bits = x_bits[22:0];

            // Exponent (biased by 127)
            let exp = (exponent_bits as int[32]) - 127;

            // Normalized mantissa in [1, 2)
            let mantissa_normalized = {0, 0x3F, mantissa_bits} as fp32;

            // Reduce to [1, sqrt(2)) or [sqrt(2), 2)
            let sqrt2 = 1.41421356;
            let use_high = mantissa_normalized >= sqrt2;
            let m = match use_high {
                1 => mantissa_normalized / 2.0,
                _ => mantissa_normalized
            };
            let exp_adj = match use_high {
                1 => exp + 1,
                _ => exp
            };

            // Polynomial approximation for ln(m) where m in [0.707, 1.414]
            // ln(m) ≈ (m-1) - (m-1)²/2 + (m-1)³/3 - (m-1)⁴/4
            let z = m - 1.0;
            let z2 = z * z;
            let z3 = z2 * z;
            let z4 = z2 * z2;

            let ln_m = z - z2 / 2.0 + z3 / 3.0 - z4 / 4.0;

            // Combine: ln(x) = exp_adj * ln(2) + ln(m)
            let ln2 = 0.69314718;
            (exp_adj as fp32) * ln2 + ln_m
        }
    }
}

/// FP32 logarithm base 2
///
/// log2(x) = ln(x) / ln(2)
///
/// Examples:
///   log2_fp32(2.0) = 1.0
///   log2_fp32(8.0) = 3.0
pub fn log2_fp32(x: fp32) -> fp32 {
    let ln2 = 0.69314718;
    return ln_fp32(x) / ln2
}

/// FP32 logarithm base 10
///
/// log10(x) = ln(x) / ln(10)
///
/// Examples:
///   log10_fp32(10.0) = 1.0
///   log10_fp32(100.0) = 2.0
pub fn log10_fp32(x: fp32) -> fp32 {
    let ln10 = 2.30258509;
    return ln_fp32(x) / ln10
}

/// FP32 exponential (e^x)
///
/// Uses series expansion and range reduction
///
/// Examples:
///   exp_fp32(0.0) = 1.0
///   exp_fp32(1.0) = e = 2.718...
///   exp_fp32(2.0) = e² = 7.389...
pub fn exp_fp32(x: fp32) -> fp32 {
    // Range reduction: e^x = e^(n*ln(2) + r) = 2^n * e^r
    // where r in [-ln(2)/2, ln(2)/2]
    let ln2 = 0.69314718;

    let n = (x / ln2) as int[32];
    let r = x - (n as fp32) * ln2;

    // Taylor series for e^r: 1 + r + r²/2! + r³/3! + r⁴/4! + r⁵/5!
    let r2 = r * r;
    let r3 = r2 * r;
    let r4 = r2 * r2;
    let r5 = r4 * r;

    let exp_r = 1.0 + r + r2 / 2.0 + r3 / 6.0 + r4 / 24.0 + r5 / 120.0;

    // Multiply by 2^n using bit manipulation
    let exp_r_bits = exp_r as bit[32];
    let exponent_bits = exp_r_bits[30:23];
    let new_exp = ((exponent_bits as int[32]) + n) as bit[8];
    let result_bits = {exp_r_bits[31:31], new_exp, exp_r_bits[22:0]};

    return result_bits as fp32
}

/// FP32 power function (x^y)
///
/// pow(x, y) = exp(y * ln(x))
///
/// Examples:
///   pow_fp32(2.0, 3.0) = 8.0
///   pow_fp32(10.0, 2.0) = 100.0
///   pow_fp32(4.0, 0.5) = 2.0
pub fn pow_fp32(x: fp32, y: fp32) -> fp32 {
    // Handle special cases
    return match x {
        0.0 => 0.0,
        1.0 => 1.0,
        _ => match y {
            0.0 => 1.0,
            1.0 => x,
            _ => exp_fp32(y * ln_fp32(x))
        }
    }
}

// ============================================================================
// Hyperbolic Functions
// ============================================================================

/// FP32 hyperbolic sine
///
/// sinh(x) = (e^x - e^(-x)) / 2
///
/// Examples:
///   sinh_fp32(0.0) = 0.0
///   sinh_fp32(1.0) = 1.175...
pub fn sinh_fp32(x: fp32) -> fp32 {
    let exp_x = exp_fp32(x);
    let exp_neg_x = exp_fp32(-x);
    return (exp_x - exp_neg_x) / 2.0
}

/// FP32 hyperbolic cosine
///
/// cosh(x) = (e^x + e^(-x)) / 2
///
/// Examples:
///   cosh_fp32(0.0) = 1.0
///   cosh_fp32(1.0) = 1.543...
pub fn cosh_fp32(x: fp32) -> fp32 {
    let exp_x = exp_fp32(x);
    let exp_neg_x = exp_fp32(-x);
    return (exp_x + exp_neg_x) / 2.0
}

/// FP32 hyperbolic tangent
///
/// tanh(x) = sinh(x) / cosh(x) = (e^(2x) - 1) / (e^(2x) + 1)
///
/// Examples:
///   tanh_fp32(0.0) = 0.0
///   tanh_fp32(1.0) = 0.761...
pub fn tanh_fp32(x: fp32) -> fp32 {
    let exp_2x = exp_fp32(2.0 * x);
    return (exp_2x - 1.0) / (exp_2x + 1.0)
}

// ============================================================================
// Utility Functions
// ============================================================================

/// FP32 absolute value
pub fn abs_fp32(x: fp32) -> fp32 {
    return match (x < 0.0) {
        1 => -x,
        _ => x
    }
}

/// FP32 sign function (-1, 0, or 1)
pub fn sign_fp32(x: fp32) -> fp32 {
    return match x {
        0.0 => 0.0,
        _ => match (x < 0.0) {
            1 => -1.0,
            _ => 1.0
        }
    }
}

/// FP32 floor (round down to integer)
pub fn floor_fp32(x: fp32) -> fp32 {
    let x_int = x as int[32];
    let x_float = x_int as fp32;

    return match (x < 0.0 && x_float != x) {
        1 => x_float - 1.0,
        _ => x_float
    }
}

/// FP32 ceiling (round up to integer)
pub fn ceil_fp32(x: fp32) -> fp32 {
    let x_int = x as int[32];
    let x_float = x_int as fp32;

    return match (x > 0.0 && x_float != x) {
        1 => x_float + 1.0,
        _ => x_float
    }
}

/// FP32 round to nearest integer
pub fn round_fp32(x: fp32) -> fp32 {
    let x_floor = floor_fp32(x);
    let frac = x - x_floor;

    return match (frac >= 0.5) {
        1 => x_floor + 1.0,
        _ => x_floor
    }
}

/// FP32 fractional part
pub fn fract_fp32(x: fp32) -> fp32 {
    return x - floor_fp32(x)
}

/// FP32 modulo
pub fn mod_fp32(x: fp32, y: fp32) -> fp32 {
    let quot = floor_fp32(x / y);
    return x - quot * y
}

/// FP32 minimum
pub fn min_fp32(a: fp32, b: fp32) -> fp32 {
    return match (a < b) {
        1 => a,
        _ => b
    }
}

/// FP32 maximum
pub fn max_fp32(a: fp32, b: fp32) -> fp32 {
    return match (a > b) {
        1 => a,
        _ => b
    }
}

/// FP32 clamp to range [min_val, max_val]
pub fn clamp_fp32(x: fp32, min_val: fp32, max_val: fp32) -> fp32 {
    let clamped_min = max_fp32(x, min_val);
    return min_fp32(clamped_min, max_val)
}

/// FP32 linear interpolation
///
/// lerp(a, b, t) = a + t * (b - a) = (1-t)*a + t*b
///
/// Examples:
///   lerp_fp32(0.0, 10.0, 0.5) = 5.0
///   lerp_fp32(0.0, 10.0, 0.0) = 0.0
///   lerp_fp32(0.0, 10.0, 1.0) = 10.0
pub fn lerp_fp32(a: fp32, b: fp32, t: fp32) -> fp32 {
    return a + t * (b - a)
}

/// FP32 smoothstep (smooth Hermite interpolation)
///
/// Smoothly interpolates between 0 and 1 as x goes from edge0 to edge1
///
/// Examples:
///   smoothstep_fp32(0.0, 1.0, 0.5) = 0.5
///   smoothstep_fp32(0.0, 1.0, 0.0) = 0.0
///   smoothstep_fp32(0.0, 1.0, 1.0) = 1.0
pub fn smoothstep_fp32(edge0: fp32, edge1: fp32, x: fp32) -> fp32 {
    // Clamp x to [edge0, edge1]
    let t = clamp_fp32((x - edge0) / (edge1 - edge0), 0.0, 1.0);

    // Hermite interpolation: 3t² - 2t³
    return t * t * (3.0 - 2.0 * t)
}
