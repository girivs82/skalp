// Phong Shading Example
//
// This example demonstrates advanced vector and FP operations by implementing
// a simplified Phong shading model used in 3D graphics.
//
// Phong shading combines:
// - Ambient lighting (constant)
// - Diffuse lighting (based on surface normal and light direction)
// - Specular lighting (based on reflection and view direction)
//
// This showcases:
// - Vector normalization
// - Dot products
// - Reflection
// - FP clamping and power operations
// - Component-wise vector multiplication

/// Phong shading computation for a single light source
entity PhongShading {
    // Surface properties
    in position: vec3<fp32>          // Surface position (world space)
    in normal: vec3<fp32>            // Surface normal (should be normalized)
    in view_dir: vec3<fp32>          // Direction to camera (should be normalized)

    // Light properties
    in light_pos: vec3<fp32>         // Light position (world space)
    in light_color: vec3<fp32>       // Light color (RGB)
    in light_intensity: fp32         // Light intensity

    // Material properties
    in ambient_color: vec3<fp32>     // Material ambient color
    in diffuse_color: vec3<fp32>     // Material diffuse color
    in specular_color: vec3<fp32>    // Material specular color
    in shininess: fp32               // Specular shininess exponent

    // Lighting coefficients
    in k_ambient: fp32               // Ambient coefficient
    in k_diffuse: fp32               // Diffuse coefficient
    in k_specular: fp32              // Specular coefficient

    // Output
    out color: vec3<fp32>            // Final shaded color
}

impl PhongShading {
    //=========================================================================
    // 1. Compute Light Direction
    //=========================================================================

    // Vector from surface to light
    inst light_dir_unnorm: Vec3Sub<fp32> {
        a = light_pos,
        b = position
    }

    // Normalize light direction
    inst light_dir: Vec3Normalize {
        v = light_dir_unnorm.result
    }

    //=========================================================================
    // 2. Ambient Component
    //=========================================================================

    // Ambient = k_ambient * ambient_color * light_intensity
    signal ambient_scaled: vec3<fp32> = ambient_color  // Simplified

    inst ambient_intensity: Vec3Scale<fp32> {
        v = ambient_scaled,
        s = k_ambient
    }

    inst ambient_light: Vec3Scale<fp32> {
        v = ambient_intensity.result,
        s = light_intensity
    }

    //=========================================================================
    // 3. Diffuse Component (Lambertian Reflectance)
    //=========================================================================

    // Compute dot(normal, light_dir)
    inst n_dot_l: Vec3Dot<fp32> {
        a = normal,
        b = light_dir.normalized
    }

    // Clamp to [0, 1] (no negative lighting)
    signal zero: fp32 = 32'h00000000
    signal one: fp32 = 32'h3F800000

    inst diffuse_factor: FP32Clamp {
        value = n_dot_l.result,
        min_val = zero,
        max_val = one
    }

    // Diffuse = k_diffuse * diffuse_color * max(0, dot(N, L)) * light_intensity
    inst diffuse_scaled: Vec3Scale<fp32> {
        v = diffuse_color,
        s = k_diffuse
    }

    inst diffuse_factor_vec: Vec3Scale<fp32> {
        v = diffuse_scaled.result,
        s = diffuse_factor.result
    }

    inst diffuse_light: Vec3Scale<fp32> {
        v = diffuse_factor_vec.result,
        s = light_intensity
    }

    //=========================================================================
    // 4. Specular Component (Phong Reflection)
    //=========================================================================

    // Reflect light direction across normal
    // Need to negate light_dir first (we want direction from light to surface)
    signal zero_vec: vec3<fp32> = vec3::<fp32> {
        x: zero,
        y: zero,
        z: zero
    }

    inst neg_light_dir: Vec3Sub<fp32> {
        a = zero_vec,
        b = light_dir.normalized
    }

    inst reflect_dir: Vec3Reflect {
        v = neg_light_dir.result,
        n = normal
    }

    // Compute dot(reflect_dir, view_dir)
    inst r_dot_v: Vec3Dot<fp32> {
        a = reflect_dir.reflected,
        b = view_dir
    }

    // Clamp to [0, 1]
    inst spec_base: FP32Clamp {
        value = r_dot_v.result,
        min_val = zero,
        max_val = one
    }

    // Raise to shininess power: spec_base^shininess
    // For simplicity, we'll approximate with multiplication
    // Real implementation would use: pow(spec_base, shininess)
    // For now: spec^2 for demonstration
    inst spec_squared: FP32Mul {
        a = spec_base.result,
        b = spec_base.result
    }

    // Specular = k_specular * specular_color * spec_factor * light_intensity
    inst spec_scaled: Vec3Scale<fp32> {
        v = specular_color,
        s = k_specular
    }

    inst spec_factor_vec: Vec3Scale<fp32> {
        v = spec_scaled.result,
        s = spec_squared.result
    }

    inst specular_light: Vec3Scale<fp32> {
        v = spec_factor_vec.result,
        s = light_intensity
    }

    //=========================================================================
    // 5. Combine Components
    //=========================================================================

    // Combine ambient + diffuse
    inst ambient_plus_diffuse: Vec3Add<fp32> {
        a = ambient_light.result,
        b = diffuse_light.result
    }

    // Add specular
    inst total_light: Vec3Add<fp32> {
        a = ambient_plus_diffuse.result,
        b = specular_light.result
    }

    // Multiply by light color (component-wise)
    inst colored: Vec3Mul<fp32> {
        a = total_light.result,
        b = light_color
    }

    // Clamp final color to [0, 1] range
    signal one_vec: vec3<fp32> = vec3::<fp32> {
        x: one,
        y: one,
        z: one
    }

    inst final_color: Vec3Clamp {
        v = colored.result,
        min_val = zero_vec,
        max_val = one_vec,
        result => color
    }
}

//=============================================================================
// Simplified Phong Shading (Blinn-Phong Variant)
//=============================================================================

/// Blinn-Phong shading is a faster approximation of Phong shading
/// Uses halfway vector instead of reflection
entity BlinnPhongShading {
    in position: vec3<fp32>
    in normal: vec3<fp32>
    in view_dir: vec3<fp32>
    in light_pos: vec3<fp32>
    in light_color: vec3<fp32>
    in light_intensity: fp32
    in material_color: vec3<fp32>
    in shininess: fp32

    out color: vec3<fp32>
}

impl BlinnPhongShading {
    // Compute light direction
    inst light_vec: Vec3Sub<fp32> {
        a = light_pos,
        b = position
    }

    inst light_dir: Vec3Normalize {
        v = light_vec.result
    }

    // Compute halfway vector: H = normalize(L + V)
    inst half_vec_unnorm: Vec3Add<fp32> {
        a = light_dir.normalized,
        b = view_dir
    }

    inst half_vec: Vec3Normalize {
        v = half_vec_unnorm.result
    }

    // Diffuse component
    inst n_dot_l: Vec3Dot<fp32> {
        a = normal,
        b = light_dir.normalized
    }

    signal zero: fp32 = 32'h00000000
    signal one: fp32 = 32'h3F800000

    inst diffuse: FP32Clamp {
        value = n_dot_l.result,
        min_val = zero,
        max_val = one
    }

    // Specular component using halfway vector
    inst n_dot_h: Vec3Dot<fp32> {
        a = normal,
        b = half_vec.normalized
    }

    inst spec_base: FP32Clamp {
        value = n_dot_h.result,
        min_val = zero,
        max_val = one
    }

    // Approximate power with multiplication (spec^2)
    inst specular: FP32Mul {
        a = spec_base.result,
        b = spec_base.result
    }

    // Combine diffuse and specular
    inst combined_factor: FP32Add {
        a = diffuse.result,
        b = specular.result
    }

    // Scale material color
    inst scaled_material: Vec3Scale<fp32> {
        v = material_color,
        s = combined_factor.result
    }

    // Multiply by light color
    inst lit_color: Vec3Mul<fp32> {
        a = scaled_material.result,
        b = light_color
    }

    // Scale by intensity
    inst final_scaled: Vec3Scale<fp32> {
        v = lit_color.result,
        s = light_intensity
    }

    // Saturate (clamp to [0, 1])
    signal zero_vec: vec3<fp32> = vec3::<fp32> {
        x: zero,
        y: zero,
        z: zero
    }

    signal one_vec: vec3<fp32> = vec3::<fp32> {
        x: one,
        y: one,
        z: one
    }

    inst saturated: Vec3Clamp {
        v = final_scaled.result,
        min_val = zero_vec,
        max_val = one_vec,
        result => color
    }
}
