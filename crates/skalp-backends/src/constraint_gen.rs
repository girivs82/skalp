//! Physical constraint file generation from LIR
//!
//! Generates vendor-specific constraint files (PCF, XDC, LPF) from LIR netlists
//! with physical constraints attached to ports.

use skalp_lir::Netlist;
use std::fmt::Write as FmtWrite;

/// Generate PCF (Physical Constraints File) for iCE40 FPGAs
///
/// PCF format is used by nextpnr-ice40 and icepack tools.
/// Format: `set_io <signal_name> <pin_location>`
///
/// # Example Output
/// ```text
/// # PCF generated by SKALP
/// set_io clk A1
/// set_io rst B2
/// set_io data[0] C1
/// set_io data[1] C2
/// ```
pub fn generate_pcf_from_lir(netlist: &Netlist) -> String {
    let mut pcf = String::new();
    pcf.push_str("# PCF (Physical Constraints File) generated by SKALP\n");
    pcf.push_str("# Format: set_io <signal_name> <pin_location>\n\n");

    for module in &netlist.modules {
        for port in &module.ports {
            if let Some(ref constraints) = port.physical_constraints {
                if let Some(ref pin_loc) = constraints.pin_location {
                    match pin_loc {
                        skalp_frontend::hir::PinLocation::Single(pin) => {
                            writeln!(pcf, "set_io {} {}", port.name, pin).unwrap();
                        }
                        skalp_frontend::hir::PinLocation::Multiple(pins) => {
                            // Handle multi-bit buses
                            for (idx, pin) in pins.iter().enumerate() {
                                writeln!(pcf, "set_io {}[{}] {}", port.name, idx, pin).unwrap();
                            }
                        }
                        skalp_frontend::hir::PinLocation::Differential { positive, negative } => {
                            // Handle differential pairs
                            writeln!(pcf, "set_io {}_p {}", port.name, positive).unwrap();
                            writeln!(pcf, "set_io {}_n {}", port.name, negative).unwrap();
                        }
                    }
                }
            }
        }
    }

    pcf
}

/// Generate XDC (Xilinx Design Constraints) for Xilinx FPGAs
///
/// XDC format is used by Vivado and other Xilinx tools.
/// Uses Tcl-based syntax with `set_property` commands.
///
/// # Example Output
/// ```text
/// # XDC generated by SKALP
/// set_property PACKAGE_PIN A1 [get_ports {clk}]
/// set_property IOSTANDARD LVCMOS33 [get_ports {clk}]
/// set_property PACKAGE_PIN B2 [get_ports {data[0]}]
/// set_property IOSTANDARD LVCMOS33 [get_ports {data[0]}]
/// ```
pub fn generate_xdc_from_lir(netlist: &Netlist) -> String {
    let mut xdc = String::new();
    xdc.push_str("# XDC (Xilinx Design Constraints) generated by SKALP\n\n");

    for module in &netlist.modules {
        for port in &module.ports {
            if let Some(ref constraints) = port.physical_constraints {
                if let Some(ref pin_loc) = constraints.pin_location {
                    match pin_loc {
                        skalp_frontend::hir::PinLocation::Single(pin) => {
                            // Pin location
                            writeln!(
                                xdc,
                                "set_property PACKAGE_PIN {} [get_ports {{{}}}]",
                                pin, port.name
                            )
                            .unwrap();

                            // I/O standard
                            if let Some(ref io_std) = constraints.io_standard {
                                writeln!(
                                    xdc,
                                    "set_property IOSTANDARD {} [get_ports {{{}}}]",
                                    io_std, port.name
                                )
                                .unwrap();
                            }

                            // Drive strength
                            if let Some(ref drive) = constraints.drive_strength {
                                let drive_value = match drive {
                                    skalp_frontend::hir::DriveStrength::Ma4 => 4,
                                    skalp_frontend::hir::DriveStrength::Ma8 => 8,
                                    skalp_frontend::hir::DriveStrength::Ma12 => 12,
                                    skalp_frontend::hir::DriveStrength::Ma16 => 16,
                                };
                                writeln!(
                                    xdc,
                                    "set_property DRIVE {} [get_ports {{{}}}]",
                                    drive_value, port.name
                                )
                                .unwrap();
                            }

                            // Slew rate
                            if let Some(ref slew) = constraints.slew_rate {
                                let slew_value = match slew {
                                    skalp_frontend::hir::SlewRate::Fast => "FAST",
                                    skalp_frontend::hir::SlewRate::Slow => "SLOW",
                                    skalp_frontend::hir::SlewRate::Medium => "MEDIUM",
                                };
                                writeln!(
                                    xdc,
                                    "set_property SLEW {} [get_ports {{{}}}]",
                                    slew_value, port.name
                                )
                                .unwrap();
                            }

                            // Termination
                            if let Some(ref term) = constraints.termination {
                                let term_value = match term {
                                    skalp_frontend::hir::Termination::PullUp => "PULLUP",
                                    skalp_frontend::hir::Termination::PullDown => "PULLDOWN",
                                    skalp_frontend::hir::Termination::Keeper => "KEEPER",
                                    skalp_frontend::hir::Termination::None => {
                                        continue; // Skip if no termination
                                    }
                                };
                                writeln!(
                                    xdc,
                                    "set_property PULLTYPE {} [get_ports {{{}}}]",
                                    term_value, port.name
                                )
                                .unwrap();
                            }

                            xdc.push('\n');
                        }
                        skalp_frontend::hir::PinLocation::Multiple(pins) => {
                            // Handle multi-bit buses
                            for (idx, pin) in pins.iter().enumerate() {
                                let port_name = format!("{}[{}]", port.name, idx);

                                writeln!(
                                    xdc,
                                    "set_property PACKAGE_PIN {} [get_ports {{{}}}]",
                                    pin, port_name
                                )
                                .unwrap();

                                if let Some(ref io_std) = constraints.io_standard {
                                    writeln!(
                                        xdc,
                                        "set_property IOSTANDARD {} [get_ports {{{}}}]",
                                        io_std, port_name
                                    )
                                    .unwrap();
                                }

                                // Drive strength
                                if let Some(ref drive) = constraints.drive_strength {
                                    let drive_value = match drive {
                                        skalp_frontend::hir::DriveStrength::Ma4 => 4,
                                        skalp_frontend::hir::DriveStrength::Ma8 => 8,
                                        skalp_frontend::hir::DriveStrength::Ma12 => 12,
                                        skalp_frontend::hir::DriveStrength::Ma16 => 16,
                                    };
                                    writeln!(
                                        xdc,
                                        "set_property DRIVE {} [get_ports {{{}}}]",
                                        drive_value, port_name
                                    )
                                    .unwrap();
                                }

                                // Slew rate
                                if let Some(ref slew) = constraints.slew_rate {
                                    let slew_value = match slew {
                                        skalp_frontend::hir::SlewRate::Fast => "FAST",
                                        skalp_frontend::hir::SlewRate::Slow => "SLOW",
                                        skalp_frontend::hir::SlewRate::Medium => "MEDIUM",
                                    };
                                    writeln!(
                                        xdc,
                                        "set_property SLEW {} [get_ports {{{}}}]",
                                        slew_value, port_name
                                    )
                                    .unwrap();
                                }

                                // Termination
                                if let Some(ref term) = constraints.termination {
                                    let term_value = match term {
                                        skalp_frontend::hir::Termination::PullUp => "PULLUP",
                                        skalp_frontend::hir::Termination::PullDown => "PULLDOWN",
                                        skalp_frontend::hir::Termination::Keeper => "KEEPER",
                                        skalp_frontend::hir::Termination::None => {
                                            continue; // Skip if no termination
                                        }
                                    };
                                    writeln!(
                                        xdc,
                                        "set_property PULLTYPE {} [get_ports {{{}}}]",
                                        term_value, port_name
                                    )
                                    .unwrap();
                                }
                            }
                            xdc.push('\n');
                        }
                        skalp_frontend::hir::PinLocation::Differential { positive, negative } => {
                            // Handle differential pairs
                            writeln!(
                                xdc,
                                "set_property PACKAGE_PIN {} [get_ports {{{}_p}}]",
                                positive, port.name
                            )
                            .unwrap();
                            writeln!(
                                xdc,
                                "set_property PACKAGE_PIN {} [get_ports {{{}_n}}]",
                                negative, port.name
                            )
                            .unwrap();

                            if let Some(ref io_std) = constraints.io_standard {
                                writeln!(
                                    xdc,
                                    "set_property IOSTANDARD {} [get_ports {{{}_p}}]",
                                    io_std, port.name
                                )
                                .unwrap();
                                writeln!(
                                    xdc,
                                    "set_property IOSTANDARD {} [get_ports {{{}_n}}]",
                                    io_std, port.name
                                )
                                .unwrap();
                            }

                            xdc.push('\n');
                        }
                    }
                }
            }
        }
    }

    xdc
}

/// Generate LPF (Lattice Preference File) for ECP5 FPGAs
///
/// LPF format is used by nextpnr-ecp5 and Lattice Diamond tools.
/// Format: `LOCATE COMP "<signal_name>" SITE "<pin_location>";`
///
/// # Example Output
/// ```text
/// # LPF generated by SKALP
/// LOCATE COMP "clk" SITE "A1";
/// IOBUF PORT "clk" IO_TYPE=LVCMOS33;
/// LOCATE COMP "data[0]" SITE "B2";
/// IOBUF PORT "data[0]" IO_TYPE=LVCMOS33;
/// ```
pub fn generate_lpf_from_lir(netlist: &Netlist) -> String {
    let mut lpf = String::new();
    lpf.push_str("# LPF (Lattice Preference File) generated by SKALP\n\n");

    for module in &netlist.modules {
        for port in &module.ports {
            if let Some(ref constraints) = port.physical_constraints {
                if let Some(ref pin_loc) = constraints.pin_location {
                    match pin_loc {
                        skalp_frontend::hir::PinLocation::Single(pin) => {
                            // Pin location
                            writeln!(lpf, "LOCATE COMP \"{}\" SITE \"{}\";", port.name, pin)
                                .unwrap();

                            // I/O buffer configuration
                            if let Some(ref io_std) = constraints.io_standard {
                                writeln!(lpf, "IOBUF PORT \"{}\" IO_TYPE={};", port.name, io_std)
                                    .unwrap();
                            }

                            // Drive strength (ECP5 uses DRIVE parameter)
                            if let Some(ref drive) = constraints.drive_strength {
                                let drive_value = match drive {
                                    skalp_frontend::hir::DriveStrength::Ma4 => 4,
                                    skalp_frontend::hir::DriveStrength::Ma8 => 8,
                                    skalp_frontend::hir::DriveStrength::Ma12 => 12,
                                    skalp_frontend::hir::DriveStrength::Ma16 => 16,
                                };
                                writeln!(
                                    lpf,
                                    "IOBUF PORT \"{}\" DRIVE={};",
                                    port.name, drive_value
                                )
                                .unwrap();
                            }

                            // Slew rate
                            if let Some(ref slew) = constraints.slew_rate {
                                let slew_value = match slew {
                                    skalp_frontend::hir::SlewRate::Fast => "FAST",
                                    skalp_frontend::hir::SlewRate::Slow => "SLOW",
                                    skalp_frontend::hir::SlewRate::Medium => "MEDIUM",
                                };
                                writeln!(
                                    lpf,
                                    "IOBUF PORT \"{}\" SLEWRATE={};",
                                    port.name, slew_value
                                )
                                .unwrap();
                            }

                            // Termination
                            if let Some(ref term) = constraints.termination {
                                let term_value = match term {
                                    skalp_frontend::hir::Termination::PullUp => "UP",
                                    skalp_frontend::hir::Termination::PullDown => "DOWN",
                                    skalp_frontend::hir::Termination::Keeper => "KEEPER",
                                    skalp_frontend::hir::Termination::None => {
                                        continue; // Skip if no termination
                                    }
                                };
                                writeln!(
                                    lpf,
                                    "IOBUF PORT \"{}\" PULLMODE={};",
                                    port.name, term_value
                                )
                                .unwrap();
                            }

                            lpf.push('\n');
                        }
                        skalp_frontend::hir::PinLocation::Multiple(pins) => {
                            // Handle multi-bit buses
                            for (idx, pin) in pins.iter().enumerate() {
                                let port_name = format!("{}[{}]", port.name, idx);

                                writeln!(lpf, "LOCATE COMP \"{}\" SITE \"{}\";", port_name, pin)
                                    .unwrap();

                                if let Some(ref io_std) = constraints.io_standard {
                                    writeln!(
                                        lpf,
                                        "IOBUF PORT \"{}\" IO_TYPE={};",
                                        port_name, io_std
                                    )
                                    .unwrap();
                                }

                                // Drive strength (ECP5 uses DRIVE parameter)
                                if let Some(ref drive) = constraints.drive_strength {
                                    let drive_value = match drive {
                                        skalp_frontend::hir::DriveStrength::Ma4 => 4,
                                        skalp_frontend::hir::DriveStrength::Ma8 => 8,
                                        skalp_frontend::hir::DriveStrength::Ma12 => 12,
                                        skalp_frontend::hir::DriveStrength::Ma16 => 16,
                                    };
                                    writeln!(
                                        lpf,
                                        "IOBUF PORT \"{}\" DRIVE={};",
                                        port_name, drive_value
                                    )
                                    .unwrap();
                                }

                                // Slew rate
                                if let Some(ref slew) = constraints.slew_rate {
                                    let slew_value = match slew {
                                        skalp_frontend::hir::SlewRate::Fast => "FAST",
                                        skalp_frontend::hir::SlewRate::Slow => "SLOW",
                                        skalp_frontend::hir::SlewRate::Medium => "MEDIUM",
                                    };
                                    writeln!(
                                        lpf,
                                        "IOBUF PORT \"{}\" SLEWRATE={};",
                                        port_name, slew_value
                                    )
                                    .unwrap();
                                }

                                // Termination
                                if let Some(ref term) = constraints.termination {
                                    let term_value = match term {
                                        skalp_frontend::hir::Termination::PullUp => "UP",
                                        skalp_frontend::hir::Termination::PullDown => "DOWN",
                                        skalp_frontend::hir::Termination::Keeper => "KEEPER",
                                        skalp_frontend::hir::Termination::None => {
                                            continue; // Skip if no termination
                                        }
                                    };
                                    writeln!(
                                        lpf,
                                        "IOBUF PORT \"{}\" PULLMODE={};",
                                        port_name, term_value
                                    )
                                    .unwrap();
                                }
                            }
                            lpf.push('\n');
                        }
                        skalp_frontend::hir::PinLocation::Differential { positive, negative } => {
                            // Handle differential pairs
                            writeln!(
                                lpf,
                                "LOCATE COMP \"{}_p\" SITE \"{}\";",
                                port.name, positive
                            )
                            .unwrap();
                            writeln!(
                                lpf,
                                "LOCATE COMP \"{}_n\" SITE \"{}\";",
                                port.name, negative
                            )
                            .unwrap();

                            if let Some(ref io_std) = constraints.io_standard {
                                writeln!(lpf, "IOBUF PORT \"{}_p\" IO_TYPE={};", port.name, io_std)
                                    .unwrap();
                                writeln!(lpf, "IOBUF PORT \"{}_n\" IO_TYPE={};", port.name, io_std)
                                    .unwrap();
                            }

                            lpf.push('\n');
                        }
                    }
                }
            }
        }
    }

    lpf
}

/// Generate SDC (Synopsys Design Constraints) timing constraints
///
/// SDC format is widely used across FPGA and ASIC tools for timing constraints.
/// This generates basic timing constraints from LIR clock information.
///
/// # Example Output
/// ```text
/// # SDC generated by SKALP
/// create_clock -name clk -period 10.000 [get_ports {clk}]
/// set_input_delay -clock clk -max 2.000 [get_ports {data_in}]
/// set_output_delay -clock clk -max 3.000 [get_ports {data_out}]
/// ```
pub fn generate_sdc_from_lir(netlist: &Netlist) -> String {
    let mut sdc = String::new();
    sdc.push_str("# SDC (Synopsys Design Constraints) generated by SKALP\n\n");

    // For now, this is a placeholder since timing constraints are not yet
    // fully integrated into the LIR. This would be extended when timing
    // constraint support is added to the frontend.
    for module in &netlist.modules {
        for port in &module.ports {
            // Check if this is a clock port (by naming convention)
            if port.name.contains("clk") || port.name.contains("clock") {
                // Default 100MHz clock (10ns period) if not specified
                writeln!(
                    sdc,
                    "create_clock -name {} -period 10.000 [get_ports {{{}}}]",
                    port.name, port.name
                )
                .unwrap();
            }
        }
    }

    sdc
}

#[cfg(test)]
mod tests {
    use super::*;
    use skalp_frontend::hir::{
        DriveStrength, PhysicalConstraints, PinLocation, SlewRate, Termination,
    };
    use skalp_lir::netlist::{Module, Port, PortDirection};

    fn create_test_netlist_with_constraints() -> Netlist {
        let mut netlist = Netlist::new("test_top".to_string());

        let mut module_ports = Vec::new();

        // Add port with single pin constraint
        let clk_port = Port {
            name: "clk".to_string(),
            direction: PortDirection::Input,
            width: 1,
            physical_constraints: Some(PhysicalConstraints {
                pin_location: Some(PinLocation::Single("A1".to_string())),
                io_standard: Some("LVCMOS33".to_string()),
                drive_strength: None,
                slew_rate: None,
                termination: None,
                schmitt_trigger: None,
                bank: None,
                diff_term: None,
            }),
        };
        module_ports.push(clk_port);

        // Add port with multi-pin constraint (bus)
        let data_port = Port {
            name: "data".to_string(),
            direction: PortDirection::Input,
            width: 4,
            physical_constraints: Some(PhysicalConstraints {
                pin_location: Some(PinLocation::Multiple(vec![
                    "B1".to_string(),
                    "B2".to_string(),
                    "C1".to_string(),
                    "C2".to_string(),
                ])),
                io_standard: Some("LVCMOS33".to_string()),
                drive_strength: Some(DriveStrength::Ma8),
                slew_rate: Some(SlewRate::Fast),
                termination: Some(Termination::PullUp),
                schmitt_trigger: None,
                bank: None,
                diff_term: None,
            }),
        };
        module_ports.push(data_port);

        // Add port with differential pair constraint
        let diff_port = Port {
            name: "diff_clk".to_string(),
            direction: PortDirection::Input,
            width: 1,
            physical_constraints: Some(PhysicalConstraints {
                pin_location: Some(PinLocation::Differential {
                    positive: "D1".to_string(),
                    negative: "D2".to_string(),
                }),
                io_standard: Some("LVDS".to_string()),
                drive_strength: None,
                slew_rate: None,
                termination: None,
                schmitt_trigger: None,
                bank: None,
                diff_term: None,
            }),
        };
        module_ports.push(diff_port);

        let module = Module {
            name: "test_module".to_string(),
            ports: module_ports,
            instances: Vec::new(),
            nets: Vec::new(),
        };

        netlist.modules.push(module);
        netlist
    }

    #[test]
    fn test_pcf_generation() {
        let netlist = create_test_netlist_with_constraints();
        let pcf = generate_pcf_from_lir(&netlist);

        println!("Generated PCF:\n{}", pcf);

        assert!(pcf.contains("set_io clk A1"));
        assert!(pcf.contains("set_io data[0] B1"));
        assert!(pcf.contains("set_io data[1] B2"));
        assert!(pcf.contains("set_io data[2] C1"));
        assert!(pcf.contains("set_io data[3] C2"));
        assert!(pcf.contains("set_io diff_clk_p D1"));
        assert!(pcf.contains("set_io diff_clk_n D2"));
    }

    #[test]
    fn test_xdc_generation() {
        let netlist = create_test_netlist_with_constraints();
        let xdc = generate_xdc_from_lir(&netlist);

        println!("Generated XDC:\n{}", xdc);

        assert!(xdc.contains("set_property PACKAGE_PIN A1 [get_ports {clk}]"));
        assert!(xdc.contains("set_property IOSTANDARD LVCMOS33 [get_ports {clk}]"));
        assert!(xdc.contains("set_property PACKAGE_PIN B1 [get_ports {data[0]}]"));
        assert!(xdc.contains("set_property PACKAGE_PIN B2 [get_ports {data[1]}]"));
        assert!(xdc.contains("set_property DRIVE 8 [get_ports {data[0]}]"));
        assert!(xdc.contains("set_property SLEW FAST [get_ports {data[0]}]"));
        assert!(xdc.contains("set_property PULLTYPE PULLUP [get_ports {data[0]}]"));
        assert!(xdc.contains("set_property PACKAGE_PIN D1 [get_ports {diff_clk_p}]"));
        assert!(xdc.contains("set_property PACKAGE_PIN D2 [get_ports {diff_clk_n}]"));
    }

    #[test]
    fn test_lpf_generation() {
        let netlist = create_test_netlist_with_constraints();
        let lpf = generate_lpf_from_lir(&netlist);

        println!("Generated LPF:\n{}", lpf);

        assert!(lpf.contains("LOCATE COMP \"clk\" SITE \"A1\";"));
        assert!(lpf.contains("IOBUF PORT \"clk\" IO_TYPE=LVCMOS33;"));
        assert!(lpf.contains("LOCATE COMP \"data[0]\" SITE \"B1\";"));
        assert!(lpf.contains("LOCATE COMP \"data[1]\" SITE \"B2\";"));
        assert!(lpf.contains("IOBUF PORT \"data[0]\" DRIVE=8;"));
        assert!(lpf.contains("IOBUF PORT \"data[0]\" SLEWRATE=FAST;"));
        assert!(lpf.contains("IOBUF PORT \"data[0]\" PULLMODE=UP;"));
        assert!(lpf.contains("LOCATE COMP \"diff_clk_p\" SITE \"D1\";"));
        assert!(lpf.contains("LOCATE COMP \"diff_clk_n\" SITE \"D2\";"));
    }

    #[test]
    fn test_sdc_generation() {
        let netlist = create_test_netlist_with_constraints();
        let sdc = generate_sdc_from_lir(&netlist);

        println!("Generated SDC:\n{}", sdc);

        assert!(sdc.contains("create_clock -name clk"));
        assert!(sdc.contains("create_clock -name diff_clk"));
    }

    #[test]
    fn test_empty_netlist() {
        let netlist = Netlist::new("empty".to_string());
        let pcf = generate_pcf_from_lir(&netlist);
        let xdc = generate_xdc_from_lir(&netlist);
        let lpf = generate_lpf_from_lir(&netlist);

        assert!(pcf.contains("# PCF"));
        assert!(xdc.contains("# XDC"));
        assert!(lpf.contains("# LPF"));
    }

    #[test]
    fn test_port_without_constraints() {
        let mut netlist = Netlist::new("test".to_string());
        let port = Port {
            name: "unconstrained".to_string(),
            direction: PortDirection::Input,
            width: 1,
            physical_constraints: None,
        };
        let module = Module {
            name: "test".to_string(),
            ports: vec![port],
            instances: Vec::new(),
            nets: Vec::new(),
        };
        netlist.modules.push(module);

        let pcf = generate_pcf_from_lir(&netlist);
        let xdc = generate_xdc_from_lir(&netlist);
        let lpf = generate_lpf_from_lir(&netlist);

        // Should not contain the unconstrained port
        assert!(!pcf.contains("unconstrained"));
        assert!(!xdc.contains("unconstrained"));
        assert!(!lpf.contains("unconstrained"));
    }
}
