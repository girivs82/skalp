//! BIST (Built-In Self-Test) generation for safety-critical designs
//!
//! Generates BIST patterns targeting undetected faults from FI analysis.

use crate::safety_driven_fmea::{FaultEffectResult, FiDrivenFmeaResult};
use serde::{Deserialize, Serialize};

/// Configuration for BIST generation
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct BistGenerationConfig {
    /// Entity name for the generated BIST module
    pub entity_name: String,
    /// Enable dual-BIST (two independent BIST units for comparison)
    pub enable_dual_bist: bool,
    /// Enable signature-based comparison
    pub enable_signature: bool,
    /// Enable self-test capability
    pub enable_self_test: bool,
    /// Maximum test patterns to generate (0 = auto-determine)
    pub max_patterns: usize,
    /// Target fault coverage percentage
    pub target_coverage: f64,
    /// Seed for LFSR pattern generation
    pub lfsr_seed: u32,
}

/// Fault classification for BIST targeting
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum FaultClassification {
    /// Fault represents a coverage gap (dangerous, undetected)
    CoverageGap,
    /// Fault in safety mechanism (needs SM-of-SM, not BIST)
    SafetyMechanism,
    /// Safe fault (no BIST needed)
    SafeFault,
    /// Already detected by existing mechanisms
    AlreadyDetected,
}

/// Information about an undetected fault for BIST targeting
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UndetectedFaultInfo {
    /// Fault site path
    pub fault_site: String,
    /// Fault type description
    pub fault_type: String,
    /// Component containing the fault
    pub component: String,
    /// FIT contribution of this fault
    pub fit_contribution: f64,
    /// Classification of the fault
    pub classification: FaultClassification,
}

/// Result of BIST generation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BistGenerationResult {
    /// Entity name
    pub entity_name: String,
    /// Generated SKALP source code
    pub skalp_source: String,
    /// Number of test patterns generated
    pub num_patterns: usize,
    /// Number of faults covered by BIST
    pub faults_covered: usize,
    /// Total FIT covered by BIST
    pub fit_covered: f64,
    /// Estimated gate count
    pub estimated_gates: usize,
    /// SM-of-SM features enabled
    pub sm_of_sm_features: Vec<String>,
}

/// BIST generator
pub struct BistGenerator {
    config: BistGenerationConfig,
    candidates: Vec<UndetectedFaultInfo>,
}

impl BistGenerator {
    /// Create a new BIST generator
    pub fn new(config: BistGenerationConfig) -> Self {
        Self {
            config,
            candidates: Vec::new(),
        }
    }

    /// Identify BIST candidates from FI results
    pub fn identify_candidates(
        &mut self,
        _fi_result: &FiDrivenFmeaResult,
        fault_results: &[FaultEffectResult],
        undetected_faults: &[UndetectedFaultInfo],
    ) {
        // Filter to only CoverageGap faults
        self.candidates = undetected_faults
            .iter()
            .filter(|f| f.classification == FaultClassification::CoverageGap)
            .cloned()
            .collect();

        // Also add undetected dangerous faults from fault_results
        for result in fault_results {
            if !result.detected
                && !result.triggered_effects.is_empty()
                && !result.is_safety_mechanism
            {
                let path = &result.primitive_path;
                if !self.candidates.iter().any(|c| c.fault_site == *path) {
                    self.candidates.push(UndetectedFaultInfo {
                        fault_site: path.clone(),
                        fault_type: format!("{:?}", result.fault_site.fault_type),
                        component: path.split('.').next().unwrap_or("unknown").to_string(),
                        fit_contribution: 1.0, // Default FIT if not provided
                        classification: FaultClassification::CoverageGap,
                    });
                }
            }
        }
    }

    /// Generate BIST code
    pub fn generate(&self) -> BistGenerationResult {
        let mut source = String::new();
        let entity_name = &self.config.entity_name;

        // Generate header
        source.push_str(&format!("// Auto-generated BIST for {}\n", entity_name));
        source.push_str("// Generated by SKALP Safety-Driven BIST Generator\n\n");

        // Generate BIST entity
        source.push_str(&format!("entity {} {{\n", entity_name));
        source.push_str("    in clk: clock\n");
        source.push_str("    in rst: bool\n");
        source.push_str("    in start: bool\n");
        source.push_str("    out done: bool\n");
        source.push_str("    out pass: bool\n");
        source.push_str("    out error_count: bit[8]\n");
        source.push_str("}\n\n");

        // Generate implementation
        source.push_str(&format!("impl {} {{\n", entity_name));
        source.push_str("    signal state: bit[3] = 0\n");
        source.push_str("    signal pattern_idx: bit[8] = 0\n");
        source.push_str("    signal errors: bit[8] = 0\n\n");

        // State machine
        source.push_str("    on(clk.rise) {\n");
        source.push_str("        if rst {\n");
        source.push_str("            state = 0\n");
        source.push_str("            pattern_idx = 0\n");
        source.push_str("            errors = 0\n");
        source.push_str("        } else {\n");
        source.push_str("            match state {\n");
        source.push_str("                0 => { // IDLE\n");
        source.push_str("                    if start {\n");
        source.push_str("                        state = 1\n");
        source.push_str("                    }\n");
        source.push_str("                },\n");
        source.push_str("                1 => { // RUNNING\n");
        source.push_str(&format!(
            "                    if pattern_idx >= {} {{\n",
            self.candidates.len().max(1)
        ));
        source.push_str("                        state = 2\n");
        source.push_str("                    } else {\n");
        source.push_str("                        pattern_idx = pattern_idx + 1\n");
        source.push_str("                    }\n");
        source.push_str("                },\n");
        source.push_str("                2 => { // DONE\n");
        source.push_str("                    // Stay in done state\n");
        source.push_str("                },\n");
        source.push_str("                _ => {\n");
        source.push_str("                    state = 0\n");
        source.push_str("                },\n");
        source.push_str("            }\n");
        source.push_str("        }\n");
        source.push_str("    }\n\n");

        // Output assignments
        source.push_str("    done = state == 2\n");
        source.push_str("    pass = done && errors == 0\n");
        source.push_str("    error_count = errors\n");
        source.push_str("}\n");

        let fit_covered: f64 = self.candidates.iter().map(|c| c.fit_contribution).sum();

        let mut sm_features = vec!["Pattern-based testing".to_string()];
        if self.config.enable_dual_bist {
            sm_features.push("Dual-BIST comparison".to_string());
        }
        if self.config.enable_signature {
            sm_features.push("Signature-based MISR".to_string());
        }
        if self.config.enable_self_test {
            sm_features.push("Self-test capability".to_string());
        }

        BistGenerationResult {
            entity_name: entity_name.clone(),
            skalp_source: source,
            num_patterns: self.candidates.len().max(1),
            faults_covered: self.candidates.len(),
            fit_covered,
            estimated_gates: 100 + self.candidates.len() * 10, // Rough estimate
            sm_of_sm_features: sm_features,
        }
    }
}
