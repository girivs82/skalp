# Automated Safety Analysis Framework

## Executive Summary

Skalp introduces a novel approach to ISO 26262 functional safety analysis that inverts the traditional FMEA workflow. Instead of manual, bottom-up failure analysis with estimated diagnostic coverage, Skalp provides **compile-time, simulation-driven safety analysis** with measured DC and automatically generated FMEA/FMEDA.

## The Problem with Traditional Safety Analysis

### Traditional Flow (Bottom-Up, Manual, Late)

```
Manual FMEA → Estimated DC → Design Complete → Fault Injection → Verify DC
    ↓              ↓                                    ↓
 Weeks of      From tables                      "DC is 87%, need 99%"
 manual work   (IEC 61508)                       Too late to fix cheaply
```

**Problems:**
1. **Manual FMEA doesn't scale** - Modern ICs have trillions of primitives
2. **DC is estimated, not measured** - Based on tables, not actual implementation
3. **Safety analysis happens too late** - After design complete, changes are expensive
4. **Gap identification is vague** - "DC too low" but WHERE exactly?
5. **Error-prone** - Human judgment about failure propagation

### Novel Flow (Top-Down, Automated, Design-Time)

```
Safety Goal → Compile → Fault Simulation → Measured DC → Auto-Generated FMEA
     ↑                                           ↓
     └──────────── Add mechanism ←───── Specific gap report

Iterate at compile time until ASIL target met
```

**Benefits:**
1. **Scales to any design size** - Same effort for 1K or 1T primitives
2. **DC is measured** - From actual fault simulation, not tables
3. **Design-time iteration** - Fast feedback loop, cheap to fix
4. **Specific gap identification** - "These 47 primitives are undetected"
5. **Evidence-based** - Simulation logs prove DC claims

## Key Innovations

### 1. Safety Goals Define Observable Effects

Instead of manually classifying every primitive's failure effect, the designer defines **what matters at the entity level**:

```skalp
safety_goal BrakingSafety: ASIL_D {
    ftti: 50_ms,

    // What outputs to monitor
    monitor {
        top.brake_main::valve_cmd,
        top.brake_main::fault,
        top.brake_main::safe_state,
    }

    // Failure effects we care about (entity-level)
    failure_effects {
        valve_stuck_high: valve_cmd == 0xFFFF for > 10_cycles,
        valve_stuck_low:  valve_cmd == 0x0000 for > 10_cycles,
        valve_corrupted:  valve_cmd != golden && fault == 0,
        silent_failure:   internal_error && fault == 0 && safe_state == 0,
    }

    // Severity classification per effect
    severity {
        valve_stuck_high: S3,
        valve_stuck_low:  S2,
        valve_corrupted:  S3,
        silent_failure:   S3,
    }
}
```

The safety goal provides **context** for interpreting primitive failures.

### 2. Automated Fault Simulation

The compiler automatically:

1. **Injects faults** at every primitive (stuck-at-0, stuck-at-1, transient)
2. **Simulates** with safety-relevant test vectors
3. **Observes** which `failure_effects` occur
4. **Classifies** each primitive by its observed effect
5. **Measures** actual DC per effect and per mechanism

```
For each primitive P in design:
    For each fault type F in {stuck_at_0, stuck_at_1, transient}:
        Inject fault F at P
        Run simulation with test vectors
        Observe monitored outputs
        Classify: Which failure_effect occurred?
        Record: Was fault detected by safety mechanism?
```

### 3. Measured DC (Not Estimated)

**Traditional:** "TMR has 99% DC" (from IEC 61508 table)

**Ours:**
```
Injected 10,000 faults at datapath primitives
Detected by TMR voter: 9,847
Measured DC: 98.47%

Undetected faults (153):
  - top.brake.datapath.alu.carry_chain[7:4] - 12 primitives
  - top.brake.datapath.reg_file.shadow_reg - 41 primitives
  ...
```

The DC is **evidence**, not a claim.

### 4. Auto-Generated FMEA/FMEDA

From simulation results, the compiler generates:

```skalp
// AUTO-GENERATED by skalp safety analysis
fmeda BrakingFmeda {
    analysis_date: "2024-01-15",
    faults_injected: 1_247_000,
    simulation_time: "4h 23m",

    failure_mode valve_corrupted {
        severity: S3,
        class: single_point,
        total_fit: 623.5,
        measured_dc: 99.2%,

        // Auto-discovered from simulation
        contributors {
            top.brake.datapath.alu.*: 0.45,       // 562 primitives
            top.brake.datapath.reg_file.*: 0.35,  // 489 primitives
            top.brake.voter.*: 0.20,              // 196 primitives
        }

        detected_by {
            psm::TmrVoter: 98.7%,     // Measured
            psm::CrcChecker: 99.1%,   // Measured
        }
    }

    failure_mode silent_failure {
        severity: S3,
        class: single_point,
        total_fit: 0.5,
        measured_dc: 0.0%,  // CRITICAL - undetected!

        contributors {
            top.brake.ctrl.state_reg[2]: 1.0,  // Single SPF!
        }

        detected_by: none,  // GAP IDENTIFIED
    }
}
```

### 5. Design-Time Iteration

Safety analysis becomes part of the compile loop:

```
$ skalp build --safety

Safety Analysis: BrakingSafety (ASIL-D)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Primitives analyzed:  1,247,000
Faults injected:      3,741,000
Simulation time:      4m 23s
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Failure Effect       Target DC    Measured DC    Status
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
valve_stuck_high     99.0%        99.7%          ✓ PASS
valve_stuck_low      99.0%        99.4%          ✓ PASS
valve_corrupted      99.0%        87.3%          ✗ FAIL
silent_failure       99.0%        0.0%           ✗ FAIL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Gap Analysis for 'valve_corrupted' (DC: 87.3%, need 99.0%):
┌─────────────────────────────────────┬────────┬─────────────┐
│ Undetected Fault Location           │ Count  │ Suggestion  │
├─────────────────────────────────────┼────────┼─────────────┤
│ top.brake.datapath.alu.*            │ 312    │ Add TMR     │
│ top.brake.datapath.reg_file.*       │ 89     │ Add ECC     │
│ top.brake.datapath.shifter.*        │ 47     │ Add TMR     │
└─────────────────────────────────────┴────────┴─────────────┘

Gap Analysis for 'silent_failure' (DC: 0.0%, need 99.0%):
┌─────────────────────────────────────┬────────┬─────────────┐
│ Undetected Fault Location           │ Count  │ Suggestion  │
├─────────────────────────────────────┼────────┼─────────────┤
│ top.brake.ctrl.state_reg[2]         │ 1      │ Add lockstep│
└─────────────────────────────────────┴────────┴─────────────┘

error[SAFETY]: ASIL-D requirements not met
  --> src/brake_controller.sk:15:1
   |
15 | safety_goal BrakingSafety: ASIL_D {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: Add safety mechanisms to cover identified gaps
   = help: Run 'skalp safety --explain valve_corrupted' for details
```

Designer adds mechanisms and recompiles - **fast iteration until ASIL target met**.

## Comparison: Traditional vs. Skalp

| Aspect | Traditional | Skalp |
|--------|-------------|-------|
| FMEA creation | Manual (weeks) | Automatic (minutes) |
| DC values | Estimated from tables | Measured from simulation |
| When analysis happens | After design complete | During design (compile time) |
| Cost to fix gaps | High (respin, schedule) | Low (edit, recompile) |
| Gap specificity | "DC too low" | "These 47 primitives need coverage" |
| Scalability | Manual doesn't scale | Scales to any design size |
| Evidence for audit | Claims and assumptions | Simulation logs and reports |
| Iteration speed | Weeks/months | Minutes |

## How It Works (Technical)

### Phase 1: Safety Goal Analysis

1. Parse `safety_goal` to extract:
   - Monitored signals
   - Failure effect definitions (conditions)
   - Severity classifications
   - ASIL requirements

2. Generate monitoring logic for each `failure_effect`

### Phase 2: Design Elaboration

1. Lower design to primitive level (gates, flops)
2. Build fault injection points at each primitive
3. Identify safety mechanisms in design

### Phase 3: Fault Simulation Campaign

1. **Fault Universe**: All (primitive, fault_type) combinations
2. **Test Vectors**: Safety-relevant scenarios (from `safety_goal`)
3. **Simulation**:
   - Inject fault
   - Run vectors
   - Observe monitored outputs
   - Check if safety mechanism detected fault
   - Classify by failure effect
4. **Fault Collapsing**: Equivalent faults share simulation (optimization)

### Phase 4: Analysis & Reporting

1. **Per-Effect DC**: Faults causing effect X that were detected / total faults causing X
2. **Per-Mechanism DC**: Faults detected by mechanism M / faults coverable by M
3. **Contributor Analysis**: Group primitives by failure effect
4. **Gap Analysis**: Identify undetected fault paths with suggestions

### Phase 5: FMEA/FMEDA Generation

1. Generate `fmeda` with measured values
2. Auto-populate contributors from simulation
3. Auto-populate DC from measurements
4. Generate work products (reports, ReqIF, etc.)

## Syntax Design

### Safety Goal with Observable Effects

```skalp
safety_goal <Name>: <ASIL> {
    ftti: <duration>,

    // Signals to monitor for failure effects
    monitor {
        <design_ref>,
        ...
    }

    // Golden model for comparison (optional)
    golden {
        <signal>: <expression>,
        ...
    }

    // Failure effect definitions
    failure_effects {
        <effect_name>: <condition>,
        ...
    }

    // Severity per effect
    severity {
        <effect_name>: <S1|S2|S3>,
        ...
    }

    // Test scenarios for simulation
    test_scenarios {
        <scenario_name>: <test_vector_source>,
        ...
    }
}
```

### Failure Effect Conditions

```skalp
failure_effects {
    // Simple comparison
    output_stuck_high: output == 0xFFFF,

    // Temporal (持続)
    output_stuck: output == prev(output) for > 100_cycles,

    // Deviation from golden
    output_corrupted: output != golden.output,

    // Compound condition
    silent_failure: error_internal && !fault_output && !safe_state,

    // Threshold-based
    value_drift: abs(output - golden.output) > 10,
}
```

### Safety Mechanism Annotation

```skalp
entity BrakeController {
    // Mark safety mechanisms for DC measurement
    #[safety_mechanism(type: tmr, covers: datapath)]
    let voter = TmrVoter { ... }

    #[safety_mechanism(type: ecc, covers: memory)]
    let ecc = EccChecker { ... }

    #[safety_mechanism(type: watchdog, covers: cpu)]
    let wdog = Watchdog { ... }
}
```

### Compiler Output (Auto-Generated FMEDA)

```skalp
// AUTO-GENERATED - DO NOT EDIT
// Generated by: skalp build --safety
// Date: 2024-01-15T14:32:00Z
// Design: top.brake_main
// Safety Goal: BrakingSafety

fmeda BrakingSafety_Analysis {
    metadata {
        primitives_analyzed: 1_247_000,
        faults_injected: 3_741_000,
        simulation_cycles: 847_000_000,
        wall_time: "4h 23m",
        tool_version: "skalp 0.1.0",
    }

    summary {
        total_fit: 623.5,
        spfm: 99.2%,
        lfm: 91.4%,
        pmhf: 8.3,
        asil_achieved: ASIL_D,
    }

    failure_mode valve_corrupted {
        effect_condition: "valve_cmd != golden.valve_cmd && fault == 0",
        severity: S3,
        class: single_point,

        measured {
            faults_causing_effect: 12_847,
            faults_detected: 12_744,
            dc: 99.2%,
        }

        contributors {
            "top.brake.datapath.alu.*": {
                primitives: 562,
                fit: 281.0,
                weight: 0.45,
            },
            "top.brake.datapath.reg_file.*": {
                primitives: 489,
                fit: 218.6,
                weight: 0.35,
            },
            "top.brake.voter.*": {
                primitives: 196,
                fit: 124.9,
                weight: 0.20,
            },
        }

        detection {
            "TmrVoter": { covered: 11_200, dc: 98.7% },
            "CrcChecker": { covered: 1_544, dc: 99.1% },
        }

        undetected {
            count: 103,
            locations: [
                "top.brake.datapath.alu.carry[7]",
                "top.brake.datapath.alu.carry[6]",
                // ... (truncated, full list in detailed report)
            ],
        }
    }

    // ... more failure modes ...
}
```

## Implementation Phases

### Phase 1: Core Data Structures
- `FaultType` enum (stuck_at_0, stuck_at_1, transient, bit_flip)
- `FaultSite` (primitive reference + fault type)
- `FailureEffect` (condition + severity)
- `SimulationResult` (fault → observed effect → detected?)
- `MeasuredDC` (per effect, per mechanism)

### Phase 2: Safety Goal Extensions
- `monitor` block parsing
- `failure_effects` condition parsing
- `golden` model specification
- `test_scenarios` integration

### Phase 3: Fault Simulation Engine
- Fault injection at primitive level
- Simulation orchestration
- Effect observation and classification
- Detection tracking per safety mechanism

### Phase 4: Analysis & Reporting
- DC calculation per effect/mechanism
- Contributor analysis (primitive → effect mapping)
- Gap identification with suggestions
- Work product generation

### Phase 5: Optimization
- Fault collapsing (equivalent faults)
- Parallel simulation
- Incremental analysis (changed portions only)
- Statistical sampling for large designs

## Value Proposition

### For Designers
- Fast feedback on safety gaps during design
- Specific guidance on where to add mechanisms
- No manual FMEA spreadsheet maintenance

### For Safety Engineers
- Evidence-based DC (not assumptions)
- Automatic FMEA generation
- Complete primitive coverage

### For Certification
- Simulation logs prove DC claims
- Traceable from safety goal to evidence
- Automatically generated work products

### For Schedule
- Find and fix issues early (design phase)
- Iterate quickly (compile-time analysis)
- No surprises at verification phase

## Conclusion

Skalp's automated safety analysis transforms functional safety from a manual, late-stage verification activity into an integrated, design-time, iterative process. By measuring DC through simulation rather than estimating from tables, and by automatically generating FMEA from observed failure effects, Skalp makes safety engineering:

1. **Scalable** - Handles trillions of primitives
2. **Accurate** - Measured DC, not estimated
3. **Actionable** - Specific gaps, not vague percentages
4. **Iterative** - Fast compile-time feedback
5. **Evidence-based** - Simulation logs for certification

This is not incremental improvement - it's a fundamental shift in how safety analysis is done.
