
        /// Non-generic FP32 multiplication entity
        async entity FpMul32 {
            in a: bit[32]
            in b: bit[32]
            out result: bit[32]
            out flags: bit[5]
        }
        impl FpMul32 {
            // Hardcoded constants for fp32
            const W: nat = 32
            const E: nat = 8
            const M: nat = 23
            const BIAS: int = 127
            const MAX_EXP: nat = 255
            const FRAC_BITS: nat = 24  // M + 1
            const PROD_BITS: nat = 48  // FRAC_BITS * 2
            const GUARD_BITS: nat = 3

            // Extract fields
            signal a_sign: bit = a[31]
            signal a_exp: bit[8] = a[30:23]
            signal a_mant: bit[23] = a[22:0]

            signal b_sign: bit = b[31]
            signal b_exp: bit[8] = b[30:23]
            signal b_mant: bit[23] = b[22:0]

            // Result sign
            signal result_sign: bit = a_sign ^ b_sign

            // Classify
            signal a_zero: bit = (a_exp == 0) && (a_mant == 0)
            signal a_denorm: bit = (a_exp == 0) && (a_mant != 0)
            signal a_inf: bit = (a_exp == 255) && (a_mant == 0)
            signal a_nan: bit = (a_exp == 255) && (a_mant != 0)

            signal b_zero: bit = (b_exp == 0) && (b_mant == 0)
            signal b_denorm: bit = (b_exp == 0) && (b_mant != 0)
            signal b_inf: bit = (b_exp == 255) && (b_mant == 0)
            signal b_nan: bit = (b_exp == 255) && (b_mant != 0)

            // Build fractions with implicit 1
            signal a_frac: bit[24] = {(!a_denorm), a_mant}
            signal b_frac: bit[24] = {(!b_denorm), b_mant}

            // Effective exponents
            signal a_exp_eff: bit[8] = a_denorm ? 1 : a_exp
            signal b_exp_eff: bit[8] = b_denorm ? 1 : b_exp

            // Multiply fractions
            signal product: bit[48] = a_frac * b_frac

            // Normalize
            signal prod_overflow: bit = product[47]
            signal product_norm: bit[48] = prod_overflow ? (product >> 1) : product

            // Calculate exponent
            signal a_exp_masked: nat = (a_exp_eff as nat) & 255
            signal b_exp_masked: nat = (b_exp_eff as nat) & 255
            signal exp_sum: int = (a_exp_masked as int) + (b_exp_masked as int) - 127 +
                                 (prod_overflow ? 1 : 0)

            // Extract mantissa and round bits
            // After normalization, the implicit 1 is at bit 46
            // Extract from bit 45 down (skipping implicit 1)
            signal mant_with_guard: bit[26] = product_norm[45:20]

            signal mant_raw: bit[23] = mant_with_guard[25:3]
            signal guard: bit = mant_with_guard[2]
            signal round: bit = mant_with_guard[1]
            signal sticky: bit = |mant_with_guard[0:0] || |product_norm[19:0]

            // Round
            signal round_up: bit = guard && (round || sticky || mant_raw[0])
            signal mant_rounded: bit[24] = {1'b0, mant_raw} + round_up
            signal exp_adj: int = exp_sum + (mant_rounded[23] as int)

            signal result_mant: bit[23] = mant_rounded[23] ? mant_rounded[23:1] : mant_rounded[22:0]

            // Overflow/underflow
            signal overflow: bit = (exp_adj >= 255)
            signal underflow: bit = (exp_adj <= 0)
            signal result_exp: bit[8] = underflow ? 0 :
                                        overflow ? 255 :
                                        exp_adj as bit[8]

            // Assemble
            signal normal_result: bit[32] = {result_sign, result_exp, result_mant}

            // Special cases
            signal invalid: bit = ((a_zero && b_inf) || (a_inf && b_zero)) || a_nan || b_nan
            signal qnan: bit[32] = 0x7FC00000
            signal inf_val: bit[32] = {result_sign, 8'hFF, 23'h0}
            signal zero_val: bit[32] = {result_sign, 8'h0, 23'h0}

            result = invalid ? qnan :
                     a_nan ? a :
                     b_nan ? b :
                     (a_inf || b_inf) ? inf_val :
                     (a_zero || b_zero) ? zero_val :
                     overflow ? inf_val :
                     underflow ? zero_val :
                     normal_result

            flags = {invalid, 1'b0, overflow && !invalid, underflow && !invalid,
                    guard || round || sticky}
        }

        async entity TestFpMul32 {
            in a: bit[32]
            in b: bit[32]
            out result: bit[32]
        }
        impl TestFpMul32 {
            signal mul: FpMul32
            mul.a = a
            mul.b = b
            result = mul.result
        }
