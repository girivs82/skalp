// TMR Counter v4 - Redundant Output Checking (E2E Protection)
// Strategy for ASIL-D:
// 1. TMR counters with diverse implementations
// 2. TMR voter with built-in detection
// 3. REDUNDANT OUTPUTS: count and count_inv (inverted)
// 4. External comparator verifies count == ~count_inv
// This catches point-of-convergence faults on output paths

// =============================================================================
// Counter Channel A: Standard binary up-counter
// =============================================================================
entity CounterChannelA {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelA {
    signal counter: bit[8] = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
        } else if (enable) {
            counter = counter + 1
        }
    }

    count = counter
}

// =============================================================================
// Counter Channel B: Inverted logic diversity
// =============================================================================
entity CounterChannelB {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelB {
    signal counter: bit[8] = 0
    signal inverted: bit[8] = 0xFF

    on(clk.rise) {
        if (rst) {
            counter = 0
            inverted = 0xFF
        } else if (enable) {
            inverted = inverted - 1
            counter = ~inverted
        }
    }

    count = counter
}

// =============================================================================
// Counter Channel C: Up-down diversity
// =============================================================================
entity CounterChannelC {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelC {
    signal down_cnt: bit[8] = 0xFF
    signal up_cnt: bit[8] = 0

    on(clk.rise) {
        if (rst) {
            down_cnt = 0xFF
            up_cnt = 0
        } else if (enable) {
            down_cnt = down_cnt - 1
            up_cnt = up_cnt + 1
        }
    }

    count = up_cnt
}

// =============================================================================
// TMR Voter with Detection
// =============================================================================
#[safety_mechanism(type=tmr)]
entity TmrVoter {
    in a: bit[8]
    in b: bit[8]
    in c: bit[8]
    out voted: bit[8]
    #[detection_signal]
    out channel_fault: bit
}

impl TmrVoter {
    signal ab_match: bit = if a == b { 1 } else { 0 }
    signal bc_match: bit = if b == c { 1 } else { 0 }
    signal ac_match: bit = if a == c { 1 } else { 0 }

    voted = if ab_match { a } else if bc_match { b } else if ac_match { a } else { a }

    signal all_match: bit = ab_match & bc_match & ac_match
    channel_fault = if all_match { 0 } else { 1 }
}

// =============================================================================
// Top-Level v4: Dual TMR with Cross-Check
// Two independent TMR voters, each output compared to detect path faults
// =============================================================================
entity TmrCounterV4 {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
    #[detection_signal]
    out fault: bit
}

impl TmrCounterV4 {
    signal count_a: bit[8]
    signal count_b: bit[8]
    signal count_c: bit[8]
    signal voted1: bit[8]
    signal voted2: bit[8]
    signal fault1: bit
    signal fault2: bit

    let ch_a = CounterChannelA {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_a
    }

    let ch_b = CounterChannelB {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_b
    }

    let ch_c = CounterChannelC {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_c
    }

    // First TMR voter
    let voter1 = TmrVoter {
        a: count_a,
        b: count_b,
        c: count_c,
        voted: voted1,
        channel_fault: fault1
    }

    // Second TMR voter (redundant, for SM-of-SM)
    let voter2 = TmrVoter {
        a: count_a,
        b: count_b,
        c: count_c,
        voted: voted2,
        channel_fault: fault2
    }

    // Primary output from voter1
    count = voted1

    // Cross-check: if voters disagree, voter path fault
    signal voter_mismatch: bit = if voted1 == voted2 { 0 } else { 1 }

    fault = fault1 | fault2 | voter_mismatch
}
