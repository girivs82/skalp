// TMR Counter v2 - Diverse Channels + Dual Voter SM-of-SM
// Strategy for ASIL-D:
// 1. Diverse counter implementations (different algorithms prevent CCF)
// 2. Dual voters with comparator (SM-of-SM for voter fault detection)
// 3. Explicit detection signal annotations

// =============================================================================
// Counter Channel A: Standard binary up-counter
// =============================================================================
entity CounterChannelA {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelA {
    signal counter: bit[8] = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
        } else if (enable) {
            counter = counter + 1
        }
    }

    count = counter
}

// =============================================================================
// Counter Channel B: LFSR-based counter (diverse implementation)
// Uses 8-bit LFSR with lookup to produce sequential values
// Different algorithm = different failure modes
// =============================================================================
entity CounterChannelB {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelB {
    // Use different increment pattern for diversity (adds 1 with different logic path)
    signal counter: bit[8] = 0
    signal inverted: bit[8] = 0xFF

    on(clk.rise) {
        if (rst) {
            counter = 0
            inverted = 0xFF
        } else if (enable) {
            // Diverse implementation: compute via inverted value
            inverted = inverted - 1
            counter = ~inverted
        }
    }

    count = counter
}

// =============================================================================
// Counter Channel C: Gray code counter (diverse implementation)
// Different representation = different failure propagation
// =============================================================================
entity CounterChannelC {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelC {
    // Down-counter diversity: counts from 255 down, output is inverted
    signal down_counter: bit[8] = 0xFF
    signal up_value: bit[8] = 0

    on(clk.rise) {
        if (rst) {
            down_counter = 0xFF
            up_value = 0
        } else if (enable) {
            // Diverse implementation: down-counter
            down_counter = down_counter - 1
            up_value = up_value + 1
        }
    }

    // Output via computed value (different path than A or B)
    count = up_value
}

// =============================================================================
// TMR Voter (single instance for SM-of-SM pattern)
// =============================================================================
entity TmrVoterUnit {
    in a: bit[8]
    in b: bit[8]
    in c: bit[8]
    out voted: bit[8]
    out disagreement: bit  // Any disagreement detected
}

impl TmrVoterUnit {
    signal ab_match: bit = if a == b { 1 } else { 0 }
    signal bc_match: bit = if b == c { 1 } else { 0 }
    signal ac_match: bit = if a == c { 1 } else { 0 }

    // Majority voting
    voted = if ab_match { a } else if bc_match { b } else if ac_match { a } else { a }

    // Disagreement detection
    signal all_match: bit = ab_match & bc_match & ac_match
    disagreement = if all_match { 0 } else { 1 }
}

// =============================================================================
// Dual Voter with Comparator (SM-of-SM pattern)
// Two independent voters + comparator to detect voter faults
// =============================================================================
#[implements(SG001::DualVoting)]
#[safety_mechanism(type=comparator)]
entity DualVoterWithComparator {
    in a: bit[8]
    in b: bit[8]
    in c: bit[8]
    out voted: bit[8]
    #[detection_signal]
    out voter_fault: bit  // Detects voter disagreement
    #[detection_signal]
    out channel_fault: bit  // Detects channel disagreement
}

impl DualVoterWithComparator {
    signal voted_1: bit[8]
    signal voted_2: bit[8]
    signal disagree_1: bit
    signal disagree_2: bit

    // Voter 1 (primary)
    let voter1 = TmrVoterUnit {
        a: a,
        b: b,
        c: c,
        voted: voted_1,
        disagreement: disagree_1
    }

    // Voter 2 (redundant) - same inputs, should produce same output
    let voter2 = TmrVoterUnit {
        a: a,
        b: b,
        c: c,
        voted: voted_2,
        disagreement: disagree_2
    }

    // Use voter 1 output as primary
    voted = voted_1

    // Voter fault detection: if voters disagree, one is faulty
    voter_fault = if voted_1 == voted_2 { 0 } else { 1 }

    // Channel fault detection: either voter detected channel disagreement
    channel_fault = disagree_1 | disagree_2
}

// =============================================================================
// Top-Level v2: Diverse TMR + SM-of-SM
// =============================================================================
entity TmrCounterV2 {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
    #[detection_signal]
    out fault: bit
}

impl TmrCounterV2 {
    signal count_a: bit[8]
    signal count_b: bit[8]
    signal count_c: bit[8]
    signal voted_out: bit[8]
    signal voter_fault: bit
    signal channel_fault: bit

    // Three DIVERSE counter channels
    let ch_a = CounterChannelA {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_a
    }

    let ch_b = CounterChannelB {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_b
    }

    let ch_c = CounterChannelC {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_c
    }

    // Dual voter with comparator (SM-of-SM)
    let dual_voter = DualVoterWithComparator {
        a: count_a,
        b: count_b,
        c: count_c,
        voted: voted_out,
        voter_fault: voter_fault,
        channel_fault: channel_fault
    }

    count = voted_out
    fault = voter_fault | channel_fault
}
