// TMR Counter v5 - Parity Protected Output
// Strategy for ASIL-D:
// 1. TMR counters with diverse implementations
// 2. TMR voter with detection
// 3. Parity bit tracking through computation
// 4. Online parity check detects single-bit errors

// =============================================================================
// Counter Channel A: Standard binary up-counter
// =============================================================================
entity CounterChannelA {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelA {
    signal counter: bit[8] = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
        } else if (enable) {
            counter = counter + 1
        }
    }

    count = counter
}

// =============================================================================
// Counter Channel B: Inverted logic diversity
// =============================================================================
entity CounterChannelB {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelB {
    signal counter: bit[8] = 0
    signal inverted: bit[8] = 0xFF

    on(clk.rise) {
        if (rst) {
            counter = 0
            inverted = 0xFF
        } else if (enable) {
            inverted = inverted - 1
            counter = ~inverted
        }
    }

    count = counter
}

// =============================================================================
// Counter Channel C: Up-down diversity
// =============================================================================
entity CounterChannelC {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelC {
    signal down_cnt: bit[8] = 0xFF
    signal up_cnt: bit[8] = 0

    on(clk.rise) {
        if (rst) {
            down_cnt = 0xFF
            up_cnt = 0
        } else if (enable) {
            down_cnt = down_cnt - 1
            up_cnt = up_cnt + 1
        }
    }

    count = up_cnt
}

// =============================================================================
// TMR Voter with Detection
// =============================================================================
#[safety_mechanism(type=tmr)]
entity TmrVoter {
    in a: bit[8]
    in b: bit[8]
    in c: bit[8]
    out voted: bit[8]
    #[detection_signal]
    out channel_fault: bit
}

impl TmrVoter {
    signal ab_match: bit = if a == b { 1 } else { 0 }
    signal bc_match: bit = if b == c { 1 } else { 0 }
    signal ac_match: bit = if a == c { 1 } else { 0 }

    voted = if ab_match { a } else if bc_match { b } else if ac_match { a } else { a }

    signal all_match: bit = ab_match & bc_match & ac_match
    channel_fault = if all_match { 0 } else { 1 }
}

// =============================================================================
// Parity Generator: XOR all bits
// =============================================================================
entity ParityGen {
    in data: bit[8]
    out parity: bit
}

impl ParityGen {
    // XOR all bits for parity
    signal p01: bit = data[0] ^ data[1]
    signal p23: bit = data[2] ^ data[3]
    signal p45: bit = data[4] ^ data[5]
    signal p67: bit = data[6] ^ data[7]
    signal p0123: bit = p01 ^ p23
    signal p4567: bit = p45 ^ p67

    parity = p0123 ^ p4567
}

// =============================================================================
// Top-Level v5: TMR with Parity Protection
// =============================================================================
entity TmrCounterV5 {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
    out count_parity: bit
    #[detection_signal]
    out fault: bit
}

impl TmrCounterV5 {
    signal count_a: bit[8]
    signal count_b: bit[8]
    signal count_c: bit[8]
    signal voted: bit[8]
    signal voter_fault: bit
    signal gen_parity: bit

    let ch_a = CounterChannelA {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_a
    }

    let ch_b = CounterChannelB {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_b
    }

    let ch_c = CounterChannelC {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_c
    }

    let voter = TmrVoter {
        a: count_a,
        b: count_b,
        c: count_c,
        voted: voted,
        channel_fault: voter_fault
    }

    // Generate parity from voted output
    let parity_gen = ParityGen {
        data: voted,
        parity: gen_parity
    }

    // Outputs
    count = voted
    count_parity = gen_parity

    // Check parity matches between original and regenerated
    signal check_parity: bit
    let parity_check = ParityGen {
        data: count,
        parity: check_parity
    }

    // Parity error if generated != checked (detects output path errors)
    signal parity_error: bit = if gen_parity == check_parity { 0 } else { 1 }

    fault = voter_fault | parity_error
}
