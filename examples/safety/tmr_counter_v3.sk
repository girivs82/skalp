// TMR Counter v3 - Diverse Voters (fixes SM-of-SM detection)
// Strategy for ASIL-D:
// 1. Diverse counter implementations (different algorithms prevent CCF)
// 2. DIVERSE voters: Conditional logic vs Bitwise majority
// 3. Explicit detection signal annotations

// =============================================================================
// Counter Channel A: Standard binary up-counter
// =============================================================================
entity CounterChannelA {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelA {
    signal counter: bit[8] = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
        } else if (enable) {
            counter = counter + 1
        }
    }

    count = counter
}

// =============================================================================
// Counter Channel B: Inverted logic (diverse)
// =============================================================================
entity CounterChannelB {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelB {
    signal counter: bit[8] = 0
    signal inverted: bit[8] = 0xFF

    on(clk.rise) {
        if (rst) {
            counter = 0
            inverted = 0xFF
        } else if (enable) {
            inverted = inverted - 1
            counter = ~inverted
        }
    }

    count = counter
}

// =============================================================================
// Counter Channel C: Down-counter diversity
// =============================================================================
entity CounterChannelC {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
}

impl CounterChannelC {
    signal down_counter: bit[8] = 0xFF
    signal up_value: bit[8] = 0

    on(clk.rise) {
        if (rst) {
            down_counter = 0xFF
            up_value = 0
        } else if (enable) {
            down_counter = down_counter - 1
            up_value = up_value + 1
        }
    }

    count = up_value
}

// =============================================================================
// Voter A: Conditional Logic (if-else based)
// =============================================================================
#[safety_mechanism(type=tmr)]
entity VoterConditional {
    in a: bit[8]
    in b: bit[8]
    in c: bit[8]
    out voted: bit[8]
    #[detection_signal]
    out disagreement: bit
}

impl VoterConditional {
    signal ab_match: bit = if a == b { 1 } else { 0 }
    signal bc_match: bit = if b == c { 1 } else { 0 }
    signal ac_match: bit = if a == c { 1 } else { 0 }

    // Majority voting using conditional logic
    voted = if ab_match { a } else if bc_match { b } else if ac_match { a } else { a }

    // Disagreement detection
    signal all_match: bit = ab_match & bc_match & ac_match
    disagreement = if all_match { 0 } else { 1 }
}

// =============================================================================
// Voter B: Bitwise Majority (different algorithm)
// Each bit position voted independently using (a&b)|(b&c)|(a&c)
// =============================================================================
#[safety_mechanism(type=tmr)]
entity VoterBitwise {
    in a: bit[8]
    in b: bit[8]
    in c: bit[8]
    out voted: bit[8]
    #[detection_signal]
    out disagreement: bit
}

impl VoterBitwise {
    // Bitwise majority: out = (a&b) | (b&c) | (a&c)
    signal ab: bit[8] = a & b
    signal bc: bit[8] = b & c
    signal ac: bit[8] = a & c

    voted = ab | bc | ac

    // Disagreement: any bit differs
    signal ab_diff: bit[8] = a ^ b
    signal bc_diff: bit[8] = b ^ c
    signal ac_diff: bit[8] = a ^ c
    signal any_diff: bit[8] = ab_diff | bc_diff | ac_diff

    // If any bit of any_diff is set, there's disagreement
    disagreement = if any_diff == 0 { 0 } else { 1 }
}

// =============================================================================
// Dual Voter with DIVERSE Implementations
// =============================================================================
#[implements(SG001::DualVoting)]
#[safety_mechanism(type=comparator)]
entity DualVoterDiverse {
    in a: bit[8]
    in b: bit[8]
    in c: bit[8]
    out voted: bit[8]
    #[detection_signal]
    out voter_fault: bit
    #[detection_signal]
    out channel_fault: bit
}

impl DualVoterDiverse {
    signal voted_1: bit[8]
    signal voted_2: bit[8]
    signal disagree_1: bit
    signal disagree_2: bit

    // Voter 1: Conditional logic implementation
    let voter1 = VoterConditional {
        a: a,
        b: b,
        c: c,
        voted: voted_1,
        disagreement: disagree_1
    }

    // Voter 2: Bitwise majority implementation (DIVERSE!)
    let voter2 = VoterBitwise {
        a: a,
        b: b,
        c: c,
        voted: voted_2,
        disagreement: disagree_2
    }

    // Use voter 1 output as primary
    voted = voted_1

    // Voter fault detection: diverse voters should agree
    voter_fault = if voted_1 == voted_2 { 0 } else { 1 }

    // Channel fault detection
    channel_fault = disagree_1 | disagree_2
}

// =============================================================================
// Top-Level v3: Diverse TMR + Diverse SM-of-SM
// =============================================================================
entity TmrCounterV3 {
    in clk: clock
    in rst: bit
    in enable: bit
    out count: bit[8]
    #[detection_signal]
    out fault: bit
}

impl TmrCounterV3 {
    signal count_a: bit[8]
    signal count_b: bit[8]
    signal count_c: bit[8]
    signal voted_out: bit[8]
    signal voter_fault: bit
    signal channel_fault: bit

    // Three DIVERSE counter channels
    let ch_a = CounterChannelA {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_a
    }

    let ch_b = CounterChannelB {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_b
    }

    let ch_c = CounterChannelC {
        clk: clk,
        rst: rst,
        enable: enable,
        count: count_c
    }

    // Dual voter with DIVERSE implementations
    let dual_voter = DualVoterDiverse {
        a: count_a,
        b: count_b,
        c: count_c,
        voted: voted_out,
        voter_fault: voter_fault,
        channel_fault: channel_fault
    }

    count = voted_out
    fault = voter_fault | channel_fault
}
