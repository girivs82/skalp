// =============================================================================
// Motor Control Unit (MCU) - Safety-Critical Design
// =============================================================================
// Architecture:
//   MotorControlUnit (Top)
//   ├── CommandProcessor  - Validates incoming throttle commands
//   ├── PWMGenerator      - Generates motor drive signals
//   ├── CurrentMonitor    - Monitors for overcurrent conditions
//   ├── Watchdog          - System health monitoring
//   └── SafeStateController - Manages safe state transitions
//
// Safety Goals:
//   SG-001: Prevent unintended motor activation (ASIL-D)
//   SG-002: Ensure motor can be stopped on demand (ASIL-D)
//   SG-003: Detect and respond to overcurrent (ASIL-C)
// =============================================================================

// =============================================================================
// Command Processor - Validates and filters incoming throttle commands
// Safety Contribution: Input validation for SG-001
// =============================================================================
entity CommandProcessor {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]      // 0-255 throttle request
    in cmd_enable: bit           // Motor enable request
    out validated_throttle: bit[8]
    out validated_enable: bit
    out cmd_error: bit           // Command validation error
}

impl CommandProcessor {
    signal throttle_reg: bit[8] = 0
    signal enable_reg: bit = 0
    signal error_reg: bit = 0

    // Rate limiter: max change of 16 per cycle
    signal throttle_diff: bit[8] = if cmd_throttle > throttle_reg {
        cmd_throttle - throttle_reg
    } else {
        throttle_reg - cmd_throttle
    }

    signal rate_ok: bit = if throttle_diff > 16 { 0 } else { 1 }

    on(clk.rise) {
        if (rst) {
            throttle_reg = 0
            enable_reg = 0
            error_reg = 0
        } else if (cmd_valid) {
            if (rate_ok) {
                throttle_reg = cmd_throttle
                enable_reg = cmd_enable
                error_reg = 0
            } else {
                // Rate violation - flag error, don't update
                error_reg = 1
            }
        }
    }

    validated_throttle = throttle_reg
    validated_enable = enable_reg
    cmd_error = error_reg
}

// =============================================================================
// PWM Generator - Converts throttle to PWM duty cycle
// Safety Contribution: Controlled output for SG-001, SG-002
// =============================================================================
entity PWMGenerator {
    in clk: clock
    in rst: bit
    in throttle: bit[8]
    in enable: bit
    in force_off: bit            // Safety override
    out pwm_out: bit
    out pwm_active: bit          // Indicates PWM is generating pulses
}

impl PWMGenerator {
    signal counter: bit[8] = 0
    signal pwm_reg: bit = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
            pwm_reg = 0
        } else {
            counter = counter + 1

            if (force_off) {
                pwm_reg = 0
            } else if (enable) {
                pwm_reg = if counter < throttle { 1 } else { 0 }
            } else {
                pwm_reg = 0
            }
        }
    }

    pwm_out = pwm_reg
    pwm_active = enable & ~force_off
}

// =============================================================================
// Current Monitor - Monitors motor current for overcurrent
// Safety Contribution: Overcurrent detection for SG-003
// =============================================================================
entity CurrentMonitor {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]      // ADC reading (0-1023)
    in threshold: bit[10]         // Overcurrent threshold
    out overcurrent: bit
    out current_valid: bit
}

impl CurrentMonitor {
    signal oc_reg: bit = 0
    signal valid_reg: bit = 0
    signal filter_count: bit[4] = 0

    // Glitch filter: require 8 consecutive samples over threshold
    on(clk.rise) {
        if (rst) {
            oc_reg = 0
            valid_reg = 0
            filter_count = 0
        } else {
            valid_reg = 1

            if (current_adc > threshold) {
                if (filter_count < 8) {
                    filter_count = filter_count + 1
                }
                if (filter_count >= 8) {
                    oc_reg = 1
                }
            } else {
                filter_count = 0
                oc_reg = 0
            }
        }
    }

    overcurrent = oc_reg
    current_valid = valid_reg
}

// =============================================================================
// Watchdog - System health monitoring
// Safety Contribution: Fault detection for SG-001, SG-002
// =============================================================================
entity Watchdog {
    in clk: clock
    in rst: bit
    in kick: bit                  // Watchdog kick signal
    in timeout_limit: bit[8]      // Timeout in cycles
    out timeout: bit
    out healthy: bit
}

impl Watchdog {
    signal counter: bit[8] = 0
    signal timeout_reg: bit = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
            timeout_reg = 0
        } else if (kick) {
            counter = 0
            timeout_reg = 0
        } else {
            if (counter < timeout_limit) {
                counter = counter + 1
            } else {
                timeout_reg = 1
            }
        }
    }

    timeout = timeout_reg
    healthy = ~timeout_reg
}

// =============================================================================
// Safe State Controller - Manages transition to safe state
// Safety Contribution: Safe state management for SG-001, SG-002
// =============================================================================
entity SafeStateController {
    in clk: clock
    in rst: bit
    in fault_cmd: bit            // Fault from command processor
    in fault_overcurrent: bit    // Fault from current monitor
    in fault_watchdog: bit       // Fault from watchdog
    in fault_clear: bit          // Request to clear faults
    out safe_state: bit          // System in safe state
    out force_motor_off: bit     // Force motor to off
    out fault_latched: bit       // Any fault is latched
}

impl SafeStateController {
    signal fault_latch: bit = 0
    signal safe_state_reg: bit = 1  // Start in safe state

    // Any fault triggers safe state
    signal any_fault: bit = fault_cmd | fault_overcurrent | fault_watchdog

    on(clk.rise) {
        if (rst) {
            fault_latch = 0
            safe_state_reg = 1
        } else {
            // Latch any fault
            if (any_fault) {
                fault_latch = 1
                safe_state_reg = 1
            } else if (fault_clear & ~any_fault) {
                // Only clear if no active faults
                fault_latch = 0
                safe_state_reg = 0
            }
        }
    }

    safe_state = safe_state_reg
    force_motor_off = safe_state_reg | any_fault
    fault_latched = fault_latch
}

// =============================================================================
// Top-Level: Motor Control Unit
// Safety Goals:
//   SG-001: Prevent unintended motor activation (ASIL-D)
//   SG-002: Ensure motor can be stopped on demand (ASIL-D)
//   SG-003: Detect and respond to overcurrent (ASIL-C)
// =============================================================================
entity MotorControlUnit {
    // Clock and reset
    in clk: clock
    in rst: bit

    // Command interface
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit

    // Current sensing
    in current_adc: bit[10]

    // Configuration
    in overcurrent_threshold: bit[10]
    in watchdog_timeout: bit[8]

    // Watchdog interface
    in watchdog_kick: bit
    in fault_clear: bit

    // Motor output
    out motor_pwm: bit

    // Status outputs
    out motor_active: bit
    out system_healthy: bit
    out in_safe_state: bit
    out fault_status: bit
}

impl MotorControlUnit {
    // Internal signals
    signal val_throttle: bit[8]
    signal val_enable: bit
    signal cmd_err: bit

    signal pwm_signal: bit
    signal pwm_is_active: bit

    signal oc_detected: bit
    signal current_ok: bit

    signal wd_timeout: bit
    signal wd_healthy: bit

    signal safe_state: bit
    signal force_off: bit
    signal fault_latch: bit

    // Command Processor
    let cmd_proc = CommandProcessor {
        clk: clk,
        rst: rst,
        cmd_valid: cmd_valid,
        cmd_throttle: cmd_throttle,
        cmd_enable: cmd_enable,
        validated_throttle: val_throttle,
        validated_enable: val_enable,
        cmd_error: cmd_err
    }

    // PWM Generator
    let pwm_gen = PWMGenerator {
        clk: clk,
        rst: rst,
        throttle: val_throttle,
        enable: val_enable,
        force_off: force_off,
        pwm_out: pwm_signal,
        pwm_active: pwm_is_active
    }

    // Current Monitor
    let curr_mon = CurrentMonitor {
        clk: clk,
        rst: rst,
        current_adc: current_adc,
        threshold: overcurrent_threshold,
        overcurrent: oc_detected,
        current_valid: current_ok
    }

    // Watchdog
    let watchdog = Watchdog {
        clk: clk,
        rst: rst,
        kick: watchdog_kick,
        timeout_limit: watchdog_timeout,
        timeout: wd_timeout,
        healthy: wd_healthy
    }

    // Safe State Controller
    let safe_ctrl = SafeStateController {
        clk: clk,
        rst: rst,
        fault_cmd: cmd_err,
        fault_overcurrent: oc_detected,
        fault_watchdog: wd_timeout,
        fault_clear: fault_clear,
        safe_state: safe_state,
        force_motor_off: force_off,
        fault_latched: fault_latch
    }

    // Outputs
    motor_pwm = pwm_signal
    motor_active = pwm_is_active
    system_healthy = wd_healthy & current_ok & ~cmd_err
    in_safe_state = safe_state
    fault_status = fault_latch
}
