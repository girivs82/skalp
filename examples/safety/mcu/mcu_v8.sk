// =============================================================================
// Motor Control Unit (MCU) v8 - ASIL-D with BIST, SM-of-SM, and Extended Coverage
// =============================================================================
// Changes from v7:
//   - Added BIST Controller with boot-time detection for voters and logic
//   - Added Periodic Self-Test with periodic detection mode
//   - Enhanced SM-of-SM with cross-checking between safety mechanisms
//   - Extended coverage with output encoding and input validation
// =============================================================================

// =============================================================================
// BIST Controller - Boot-time Self-Test
// Tests: RAM, ROM, Voters, Comparators at boot
// =============================================================================
entity BistController {
    in clk: clock
    in rst: bit
    in start_bist: bit

    // Boot-time detection signals
    #[detection_signal(mode = "boot")]
    out bist_complete: bit
    #[detection_signal(mode = "boot")]
    out bist_pass: bit
    #[detection_signal(mode = "boot")]
    out ram_ok: bit
    #[detection_signal(mode = "boot")]
    out rom_ok: bit
    #[detection_signal(mode = "boot")]
    out voter_ok: bit
    #[detection_signal(mode = "boot")]
    out comparator_ok: bit
}

impl BistController {
    signal state: bit[4] = 0
    signal done: bit = 0
    signal pass: bit = 0
    signal ram_test: bit = 0
    signal rom_test: bit = 0
    signal voter_test: bit = 0
    signal comp_test: bit = 0

    // Test patterns for RAM
    signal ram_pattern: bit[8] = 0
    signal ram_readback: bit[8] = 0

    // CRC for ROM check
    signal rom_crc: bit[8] = 0
    signal rom_expected: bit[8] = 0xA5

    // Test vectors for voter
    signal test_a: bit = 0
    signal test_b: bit = 0
    signal test_c: bit = 0
    signal voter_result: bit = 0
    signal voter_expected: bit = 0

    // Test for comparator
    signal cmp_in_a: bit[8] = 0
    signal cmp_in_b: bit[8] = 0
    signal cmp_result: bit = 0
    signal cmp_expected: bit = 0

    on(clk.rise) {
        if (rst) {
            state = 0
            done = 0
            pass = 0
            ram_test = 0
            rom_test = 0
            voter_test = 0
            comp_test = 0
        } else {
            if (state == 0) {
                // Idle - wait for start
                if (start_bist) {
                    state = 1
                    ram_pattern = 0x55
                }
            } else if (state == 1) {
                // RAM test: write pattern
                ram_readback = ram_pattern  // Simulate write-read
                state = 2
            } else if (state == 2) {
                // RAM test: verify
                ram_test = if ram_readback == ram_pattern { 1 } else { 0 }
                ram_pattern = 0xAA
                state = 3
            } else if (state == 3) {
                // RAM test: second pattern
                ram_readback = ram_pattern
                state = 4
            } else if (state == 4) {
                // RAM test: verify second pattern
                ram_test = ram_test & (if ram_readback == ram_pattern { 1 } else { 0 })
                rom_crc = 0xA5  // Simulate ROM CRC calculation
                state = 5
            } else if (state == 5) {
                // ROM test: verify CRC
                rom_test = if rom_crc == rom_expected { 1 } else { 0 }
                test_a = 1
                test_b = 1
                test_c = 0
                voter_expected = 1  // Majority of (1,1,0) = 1
                state = 6
            } else if (state == 6) {
                // Voter test: majority vote
                voter_result = (test_a & test_b) | (test_b & test_c) | (test_a & test_c)
                voter_test = if voter_result == voter_expected { 1 } else { 0 }
                test_a = 0
                test_b = 0
                test_c = 1
                voter_expected = 0  // Majority of (0,0,1) = 0
                state = 7
            } else if (state == 7) {
                // Voter test: second pattern
                voter_result = (test_a & test_b) | (test_b & test_c) | (test_a & test_c)
                voter_test = voter_test & (if voter_result == voter_expected { 1 } else { 0 })
                cmp_in_a = 0x42
                cmp_in_b = 0x42
                cmp_expected = 1  // Equal
                state = 8
            } else if (state == 8) {
                // Comparator test: equal values
                cmp_result = if cmp_in_a == cmp_in_b { 1 } else { 0 }
                comp_test = if cmp_result == cmp_expected { 1 } else { 0 }
                cmp_in_a = 0x42
                cmp_in_b = 0x24
                cmp_expected = 0  // Not equal
                state = 9
            } else if (state == 9) {
                // Comparator test: unequal values
                cmp_result = if cmp_in_a == cmp_in_b { 1 } else { 0 }
                comp_test = comp_test & (if cmp_result == cmp_expected { 1 } else { 0 })
                state = 10
            } else if (state == 10) {
                // All tests complete
                done = 1
                pass = ram_test & rom_test & voter_test & comp_test
                state = 11
            }
        }
    }

    bist_complete = done
    bist_pass = pass
    ram_ok = ram_test
    rom_ok = rom_test
    voter_ok = voter_test
    comparator_ok = comp_test
}

// =============================================================================
// Periodic Self-Test - Runtime verification at periodic intervals
// =============================================================================
entity PeriodicSelfTest {
    in clk: clock
    in rst: bit
    in trigger: bit  // External trigger for periodic test

    // Test inputs from functional logic
    in voter_in_a: bit
    in voter_in_b: bit
    in voter_in_c: bit
    in voter_out: bit
    in comparator_in_a: bit[8]
    in comparator_in_b: bit[8]
    in comparator_out: bit

    // Periodic detection signals
    #[detection_signal(mode = "periodic")]
    out test_complete: bit
    #[detection_signal(mode = "periodic")]
    out voter_check_ok: bit
    #[detection_signal(mode = "periodic")]
    out comparator_check_ok: bit
}

impl PeriodicSelfTest {
    signal test_done: bit = 0
    signal voter_ok: bit = 0
    signal comp_ok: bit = 0
    signal state: bit[2] = 0

    // Recalculate expected voter output
    signal expected_vote: bit = (voter_in_a & voter_in_b) | (voter_in_b & voter_in_c) | (voter_in_a & voter_in_c)

    // Recalculate expected comparator output
    signal expected_cmp: bit = if comparator_in_a == comparator_in_b { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            state = 0
            test_done = 0
            voter_ok = 0
            comp_ok = 0
        } else {
            if (state == 0) {
                if (trigger) {
                    state = 1
                    test_done = 0
                }
            } else if (state == 1) {
                // Check voter
                voter_ok = if voter_out == expected_vote { 1 } else { 0 }
                state = 2
            } else if (state == 2) {
                // Check comparator
                comp_ok = if comparator_out == expected_cmp { 1 } else { 0 }
                state = 3
            } else if (state == 3) {
                test_done = 1
                state = 0
            }
        }
    }

    test_complete = test_done
    voter_check_ok = voter_ok
    comparator_check_ok = comp_ok
}

// =============================================================================
// Command Processor Channel A - Algorithm 1 (Rate-of-change limiting)
// =============================================================================
#[diversity(algorithm = "rate_limit")]
entity CommandChannelA {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    out validated_throttle: bit[8]
    out validated_enable: bit
    #[detection_signal]
    out cmd_error: bit
}

impl CommandChannelA {
    signal throttle_reg: bit[8] = 0
    signal enable_reg: bit = 0
    signal error_reg: bit = 0

    signal throttle_diff: bit[8] = if cmd_throttle > throttle_reg {
        cmd_throttle - throttle_reg
    } else {
        throttle_reg - cmd_throttle
    }
    signal rate_ok: bit = if throttle_diff > 16 { 0 } else { 1 }

    on(clk.rise) {
        if (rst) {
            throttle_reg = 0
            enable_reg = 0
            error_reg = 0
        } else if (cmd_valid) {
            if (rate_ok) {
                throttle_reg = cmd_throttle
                enable_reg = cmd_enable
                error_reg = 0
            } else {
                error_reg = 1
            }
        }
    }

    validated_throttle = throttle_reg
    validated_enable = enable_reg
    cmd_error = error_reg
}

// =============================================================================
// Command Processor Channel B - Algorithm 2 (Range + hysteresis)
// =============================================================================
#[diversity(algorithm = "range_hysteresis")]
entity CommandChannelB {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    out validated_throttle: bit[8]
    out validated_enable: bit
    #[detection_signal]
    out cmd_error: bit
}

impl CommandChannelB {
    signal throttle_reg: bit[8] = 0
    signal enable_reg: bit = 0
    signal error_reg: bit = 0
    signal prev_throttle: bit[8] = 0
    signal hysteresis_count: bit[4] = 0

    signal in_range: bit = if cmd_throttle > 240 { 0 } else { 1 }
    signal is_stable: bit = if cmd_throttle == prev_throttle {
        1
    } else {
        if hysteresis_count > 2 { 1 } else { 0 }
    }

    on(clk.rise) {
        if (rst) {
            throttle_reg = 0
            enable_reg = 0
            error_reg = 0
            prev_throttle = 0
            hysteresis_count = 0
        } else if (cmd_valid) {
            prev_throttle = cmd_throttle
            if (cmd_throttle != prev_throttle) {
                hysteresis_count = 0
            } else if (hysteresis_count < 15) {
                hysteresis_count = hysteresis_count + 1
            }

            if (in_range & is_stable) {
                throttle_reg = cmd_throttle
                enable_reg = cmd_enable
                error_reg = 0
            } else {
                error_reg = 1
            }
        }
    }

    validated_throttle = throttle_reg
    validated_enable = enable_reg
    cmd_error = error_reg
}

// =============================================================================
// Command Processor Channel C - Algorithm 3 (Moving average)
// =============================================================================
#[diversity(algorithm = "moving_average")]
entity CommandChannelC {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    out validated_throttle: bit[8]
    out validated_enable: bit
    #[detection_signal]
    out cmd_error: bit
}

impl CommandChannelC {
    signal throttle_reg: bit[8] = 0
    signal enable_reg: bit = 0
    signal error_reg: bit = 0
    signal avg_throttle: bit[8] = 0
    signal sample_count: bit[4] = 0

    // Simple moving average approximation
    signal new_avg: bit[8] = (avg_throttle + cmd_throttle) >> 1
    signal deviation: bit[8] = if cmd_throttle > new_avg {
        cmd_throttle - new_avg
    } else {
        new_avg - cmd_throttle
    }
    signal deviation_ok: bit = if deviation > 32 { 0 } else { 1 }

    on(clk.rise) {
        if (rst) {
            throttle_reg = 0
            enable_reg = 0
            error_reg = 0
            avg_throttle = 0
            sample_count = 0
        } else if (cmd_valid) {
            avg_throttle = new_avg
            if (sample_count < 15) {
                sample_count = sample_count + 1
            }

            if (deviation_ok | (sample_count < 4)) {
                throttle_reg = cmd_throttle
                enable_reg = cmd_enable
                error_reg = 0
            } else {
                error_reg = 1
            }
        }
    }

    validated_throttle = throttle_reg
    validated_enable = enable_reg
    cmd_error = error_reg
}

// =============================================================================
// Diverse TMR Command Processor with SM-of-SM
// =============================================================================
#[implements(SG001::CommandValidation)]
#[safety_mechanism(type = tmr)]
entity DiverseTmrCommandProcessor {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    out validated_throttle: bit[8]
    out validated_enable: bit
    #[detection_signal]
    out cmd_error: bit
    #[detection_signal]
    out tmr_fault: bit
    #[detection_signal]
    out sm_fault: bit

    // Expose internals for periodic test
    out voter_in_a: bit
    out voter_in_b: bit
    out voter_in_c: bit
}

impl DiverseTmrCommandProcessor {
    signal throttle_a: bit[8]
    signal throttle_b: bit[8]
    signal throttle_c: bit[8]
    signal enable_a: bit
    signal enable_b: bit
    signal enable_c: bit
    signal error_a: bit
    signal error_b: bit
    signal error_c: bit

    let ch_a = CommandChannelA {
        clk: clk, rst: rst,
        cmd_valid: cmd_valid, cmd_throttle: cmd_throttle, cmd_enable: cmd_enable,
        validated_throttle: throttle_a, validated_enable: enable_a, cmd_error: error_a
    }

    let ch_b = CommandChannelB {
        clk: clk, rst: rst,
        cmd_valid: cmd_valid, cmd_throttle: cmd_throttle, cmd_enable: cmd_enable,
        validated_throttle: throttle_b, validated_enable: enable_b, cmd_error: error_b
    }

    let ch_c = CommandChannelC {
        clk: clk, rst: rst,
        cmd_valid: cmd_valid, cmd_throttle: cmd_throttle, cmd_enable: cmd_enable,
        validated_throttle: throttle_c, validated_enable: enable_c, cmd_error: error_c
    }

    // VOTER A: AND-OR majority for throttle (bit-by-bit voting)
    signal thr_ab: bit[8] = throttle_a & throttle_b
    signal thr_bc: bit[8] = throttle_b & throttle_c
    signal thr_ac: bit[8] = throttle_a & throttle_c
    signal voted_throttle: bit[8] = thr_ab | thr_bc | thr_ac

    // VOTER B: MUX-based for enable
    signal voted_enable: bit = if enable_a == enable_b { enable_a } else { enable_c }

    // VOTER C: OR for error (any error triggers)
    signal voted_error: bit = error_a | error_b | error_c

    // TMR fault detection: channels disagree
    signal enable_all_same: bit = if enable_a == enable_b { if enable_b == enable_c { 1 } else { 0 } } else { 0 }
    signal error_all_same: bit = if error_a == error_b { if error_b == error_c { 1 } else { 0 } } else { 0 }

    // SM-of-SM: Cross-check using diverse methods
    // Method 1: XOR-based disagreement
    signal enable_xor_ab: bit = enable_a ^ enable_b
    signal enable_xor_bc: bit = enable_b ^ enable_c
    signal xor_fault: bit = enable_xor_ab | enable_xor_bc

    // Method 2: Count-based
    signal enable_count: bit[2] = (enable_a as bit[2]) + (enable_b as bit[2]) + (enable_c as bit[2])
    signal count_fault: bit = if enable_count == 1 { 1 } else { if enable_count == 2 { 1 } else { 0 } }

    // SM-of-SM: Both methods should agree on fault detection
    signal methods_agree: bit = if xor_fault == count_fault { 1 } else { 0 }

    validated_throttle = voted_throttle
    validated_enable = voted_enable
    cmd_error = voted_error
    tmr_fault = ~enable_all_same | ~error_all_same
    sm_fault = ~methods_agree

    // Expose for periodic test
    voter_in_a = enable_a
    voter_in_b = enable_b
    voter_in_c = enable_c
}

// =============================================================================
// PWM Channel A - Counter-based
// =============================================================================
#[diversity(algorithm = "counter")]
entity PWMChannelA {
    in clk: clock
    in rst: bit
    in throttle: bit[8]
    in enable: bit
    in force_off: bit
    out pwm_out: bit
    out pwm_active: bit
}

impl PWMChannelA {
    signal counter: bit[8] = 0
    signal pwm_reg: bit = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
            pwm_reg = 0
        } else {
            counter = counter + 1
            if (force_off) {
                pwm_reg = 0
            } else if (enable) {
                pwm_reg = if counter < throttle { 1 } else { 0 }
            } else {
                pwm_reg = 0
            }
        }
    }

    pwm_out = pwm_reg
    pwm_active = enable & ~force_off
}

// =============================================================================
// PWM Channel B - Dual counter
// =============================================================================
#[diversity(algorithm = "dual_counter")]
entity PWMChannelB {
    in clk: clock
    in rst: bit
    in throttle: bit[8]
    in enable: bit
    in force_off: bit
    out pwm_out: bit
    out pwm_active: bit
}

impl PWMChannelB {
    signal counter_up: bit[8] = 0
    signal counter_down: bit[8] = 255
    signal pwm_reg: bit = 0

    signal threshold_down: bit[8] = 255 - throttle
    signal cond_up: bit = if counter_up < throttle { 1 } else { 0 }
    signal cond_down: bit = if counter_down > threshold_down { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            counter_up = 0
            counter_down = 255
            pwm_reg = 0
        } else {
            counter_up = counter_up + 1
            counter_down = counter_down - 1

            if (force_off) {
                pwm_reg = 0
            } else if (enable) {
                pwm_reg = cond_up & cond_down
            } else {
                pwm_reg = 0
            }
        }
    }

    pwm_out = pwm_reg
    pwm_active = enable & ~force_off
}

// =============================================================================
// Diverse DMR PWM Generator with output encoding
// =============================================================================
#[safety_mechanism(type = dmr)]
entity DiversePWMGenerator {
    in clk: clock
    in rst: bit
    in throttle: bit[8]
    in enable: bit
    in force_off: bit
    out pwm_out: bit
    out pwm_active: bit
    #[detection_signal]
    out pwm_fault: bit
    #[detection_signal]
    out encoding_fault: bit
}

impl DiversePWMGenerator {
    signal pwm_a: bit
    signal pwm_b: bit
    signal active_a: bit
    signal active_b: bit

    let ch_a = PWMChannelA {
        clk: clk, rst: rst, throttle: throttle, enable: enable, force_off: force_off,
        pwm_out: pwm_a, pwm_active: active_a
    }

    let ch_b = PWMChannelB {
        clk: clk, rst: rst, throttle: throttle, enable: enable, force_off: force_off,
        pwm_out: pwm_b, pwm_active: active_b
    }

    // Output encoding: encode active state for E2E check
    signal encoded_active: bit[4] = if active_a & active_b { 0x5 }  // Both active: 0101
                                    else if ~active_a & ~active_b { 0xA }  // Both inactive: 1010
                                    else { 0x0 }  // Mismatch: invalid code

    signal encoding_valid: bit = if encoded_active == 0x5 { 1 }
                                  else if encoded_active == 0xA { 1 }
                                  else { 0 }

    pwm_out = pwm_a
    pwm_active = active_a

    // Fault detection
    signal active_xor: bit = active_a ^ active_b
    pwm_fault = active_xor
    encoding_fault = ~encoding_valid
}

// =============================================================================
// Current Channel A - Threshold
// =============================================================================
#[diversity(algorithm = "threshold")]
entity CurrentChannelA {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]
    in threshold: bit[10]
    out overcurrent: bit
    out current_valid: bit
}

impl CurrentChannelA {
    signal oc_reg: bit = 0
    signal valid_reg: bit = 0
    signal filter_count: bit[4] = 0

    on(clk.rise) {
        if (rst) {
            oc_reg = 0
            valid_reg = 0
            filter_count = 0
        } else {
            valid_reg = 1
            if (current_adc > threshold) {
                if (filter_count < 8) {
                    filter_count = filter_count + 1
                }
                if (filter_count >= 8) {
                    oc_reg = 1
                }
            } else {
                filter_count = 0
                oc_reg = 0
            }
        }
    }

    overcurrent = oc_reg
    current_valid = valid_reg
}

// =============================================================================
// Current Channel B - Derivative
// =============================================================================
#[diversity(algorithm = "derivative")]
entity CurrentChannelB {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]
    in threshold: bit[10]
    out overcurrent: bit
    out current_valid: bit
}

impl CurrentChannelB {
    signal oc_reg: bit = 0
    signal valid_reg: bit = 0
    signal prev_current: bit[10] = 0
    signal delta_count: bit[4] = 0

    signal delta: bit[10] = if current_adc > prev_current {
        current_adc - prev_current
    } else { 0 }
    signal rapid_rise: bit = if delta > 32 { 1 } else { 0 }
    signal over_thresh: bit = if current_adc > threshold { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            oc_reg = 0
            valid_reg = 0
            prev_current = 0
            delta_count = 0
        } else {
            prev_current = current_adc
            valid_reg = 1

            if (over_thresh | rapid_rise) {
                if (delta_count < 4) {
                    delta_count = delta_count + 1
                }
                if (delta_count >= 4) {
                    oc_reg = 1
                }
            } else {
                delta_count = 0
                oc_reg = 0
            }
        }
    }

    overcurrent = oc_reg
    current_valid = valid_reg
}

// =============================================================================
// Current Channel C - Count-based
// =============================================================================
#[diversity(algorithm = "count")]
entity CurrentChannelC {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]
    in threshold: bit[10]
    out overcurrent: bit
    out current_valid: bit
}

impl CurrentChannelC {
    signal oc_reg: bit = 0
    signal valid_reg: bit = 0
    signal sum_count: bit[4] = 0
    signal sample_count: bit[4] = 0

    signal sample_over: bit = if current_adc > threshold { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            oc_reg = 0
            valid_reg = 0
            sum_count = 0
            sample_count = 0
        } else {
            valid_reg = 1

            if (sample_over) {
                if (sum_count < 15) {
                    sum_count = sum_count + 1
                }
            } else {
                if (sum_count > 0) {
                    sum_count = sum_count - 1
                }
            }

            if (sample_count < 15) {
                sample_count = sample_count + 1
            }

            if (sample_count >= 8) {
                oc_reg = if sum_count > 6 { 1 } else { 0 }
            }
        }
    }

    overcurrent = oc_reg
    current_valid = valid_reg
}

// =============================================================================
// TMR Current Monitor with enhanced SM-of-SM
// =============================================================================
#[implements(SG003::OvercurrentDetection)]
#[safety_mechanism(type = tmr)]
entity DiverseTmrCurrentMonitor {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]
    in threshold: bit[10]
    #[detection_signal]
    out overcurrent: bit
    out current_valid: bit
    #[detection_signal]
    out tmr_fault: bit
    #[detection_signal]
    out sm_fault: bit

    // Expose for cross-checking
    out oc_ch_a: bit
    out oc_ch_b: bit
    out oc_ch_c: bit
}

impl DiverseTmrCurrentMonitor {
    signal oc_a: bit
    signal oc_b: bit
    signal oc_c: bit
    signal valid_a: bit
    signal valid_b: bit
    signal valid_c: bit

    let ch_a = CurrentChannelA { clk: clk, rst: rst, current_adc: current_adc, threshold: threshold, overcurrent: oc_a, current_valid: valid_a }
    let ch_b = CurrentChannelB { clk: clk, rst: rst, current_adc: current_adc, threshold: threshold, overcurrent: oc_b, current_valid: valid_b }
    let ch_c = CurrentChannelC { clk: clk, rst: rst, current_adc: current_adc, threshold: threshold, overcurrent: oc_c, current_valid: valid_c }

    // VOTER A: AND-OR majority
    signal oc_ab: bit = oc_a & oc_b
    signal oc_bc: bit = oc_b & oc_c
    signal oc_ac: bit = oc_a & oc_c
    signal voted_oc: bit = oc_ab | oc_bc | oc_ac

    // VOTER B: MUX-based
    signal voted_valid: bit = if valid_a == valid_b { valid_a } else { valid_c }

    // Fault detection method 1: equality
    signal oc_all_same: bit = if oc_a == oc_b { if oc_b == oc_c { 1 } else { 0 } } else { 0 }
    signal valid_all_same: bit = if valid_a == valid_b { if valid_b == valid_c { 1 } else { 0 } } else { 0 }

    // Fault detection method 2: XOR
    signal oc_xor_ab: bit = oc_a ^ oc_b
    signal oc_xor_bc: bit = oc_b ^ oc_c
    signal xor_fault: bit = oc_xor_ab | oc_xor_bc

    // SM-of-SM: Methods should agree
    signal methods_agree: bit = if xor_fault == (~oc_all_same) { 1 } else { 0 }

    overcurrent = voted_oc
    current_valid = voted_valid
    tmr_fault = ~oc_all_same | ~valid_all_same
    sm_fault = ~methods_agree

    oc_ch_a = oc_a
    oc_ch_b = oc_b
    oc_ch_c = oc_c
}

// =============================================================================
// Watchdog Channel A - Counter
// =============================================================================
#[diversity(algorithm = "counter")]
entity WatchdogChannelA {
    in clk: clock
    in rst: bit
    in kick: bit
    in timeout_limit: bit[8]
    out timeout: bit
    out healthy: bit
}

impl WatchdogChannelA {
    signal counter: bit[8] = 0
    signal timeout_reg: bit = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
            timeout_reg = 0
        } else if (kick) {
            counter = 0
            timeout_reg = 0
        } else {
            if (counter < timeout_limit) {
                counter = counter + 1
            } else {
                timeout_reg = 1
            }
        }
    }

    timeout = timeout_reg
    healthy = ~timeout_reg
}

// =============================================================================
// Watchdog Channel B - Window watchdog
// =============================================================================
#[diversity(algorithm = "window")]
entity WatchdogChannelB {
    in clk: clock
    in rst: bit
    in kick: bit
    in timeout_limit: bit[8]
    out timeout: bit
    out healthy: bit
}

impl WatchdogChannelB {
    signal counter: bit[8] = 0
    signal timeout_reg: bit = 0
    signal window_open: bit = 0

    signal window_start: bit = if counter > 64 { 1 } else { 0 }
    signal too_early: bit = if counter < 64 { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            counter = 0
            timeout_reg = 0
            window_open = 0
        } else if (kick) {
            if (window_open & ~too_early) {
                counter = 0
                timeout_reg = 0
            } else {
                timeout_reg = 1
            }
            window_open = 0
        } else {
            if (counter < timeout_limit) {
                counter = counter + 1
            } else {
                timeout_reg = 1
            }

            if (~too_early) {
                window_open = 1
            }
        }
    }

    timeout = timeout_reg
    healthy = ~timeout_reg
}

// =============================================================================
// Diverse Dual Watchdog
// =============================================================================
#[safety_mechanism(type = dmr)]
entity DiverseDualWatchdog {
    in clk: clock
    in rst: bit
    in kick: bit
    in timeout_limit: bit[8]
    #[detection_signal]
    out timeout: bit
    out healthy: bit
    #[detection_signal]
    out watchdog_fault: bit
}

impl DiverseDualWatchdog {
    signal timeout_a: bit
    signal timeout_b: bit
    signal healthy_a: bit
    signal healthy_b: bit

    let wd_a = WatchdogChannelA { clk: clk, rst: rst, kick: kick, timeout_limit: timeout_limit, timeout: timeout_a, healthy: healthy_a }
    let wd_b = WatchdogChannelB { clk: clk, rst: rst, kick: kick, timeout_limit: timeout_limit, timeout: timeout_b, healthy: healthy_b }

    timeout = timeout_a | timeout_b
    healthy = healthy_a & healthy_b
    signal timeout_xor: bit = timeout_a ^ timeout_b
    watchdog_fault = timeout_xor
}

// =============================================================================
// Safe State Channel A - FSM
// =============================================================================
#[diversity(algorithm = "fsm")]
entity SafeStateChannelA {
    in clk: clock
    in rst: bit
    in fault_cmd: bit
    in fault_overcurrent: bit
    in fault_watchdog: bit
    in fault_clear: bit
    out safe_state: bit
    out force_motor_off: bit
    out fault_latched: bit
}

impl SafeStateChannelA {
    signal fault_latch: bit = 0
    signal safe_state_reg: bit = 1
    signal any_fault: bit = fault_cmd | fault_overcurrent | fault_watchdog

    on(clk.rise) {
        if (rst) {
            fault_latch = 0
            safe_state_reg = 1
        } else {
            if (any_fault) {
                fault_latch = 1
                safe_state_reg = 1
            } else if (fault_clear & ~any_fault) {
                fault_latch = 0
                safe_state_reg = 0
            }
        }
    }

    safe_state = safe_state_reg
    force_motor_off = safe_state_reg | any_fault
    fault_latched = fault_latch
}

// =============================================================================
// Safe State Channel B - Priority
// =============================================================================
#[diversity(algorithm = "priority")]
entity SafeStateChannelB {
    in clk: clock
    in rst: bit
    in fault_cmd: bit
    in fault_overcurrent: bit
    in fault_watchdog: bit
    in fault_clear: bit
    out safe_state: bit
    out force_motor_off: bit
    out fault_latched: bit
}

impl SafeStateChannelB {
    signal fault_code: bit[3] = 0
    signal safe_state_reg: bit = 1

    signal priority_fault: bit[3] = if fault_overcurrent { 4 }
                                     else if fault_cmd { 2 }
                                     else if fault_watchdog { 1 }
                                     else { 0 }

    on(clk.rise) {
        if (rst) {
            fault_code = 0
            safe_state_reg = 1
        } else {
            if (priority_fault != 0) {
                fault_code = fault_code | priority_fault
                safe_state_reg = 1
            } else if (fault_clear & (fault_code != 0)) {
                fault_code = 0
                safe_state_reg = 0
            }
        }
    }

    safe_state = safe_state_reg
    force_motor_off = safe_state_reg | (priority_fault != 0)
    fault_latched = if fault_code != 0 { 1 } else { 0 }
}

// =============================================================================
// Safe State Channel C - Counter-based
// =============================================================================
#[diversity(algorithm = "counter")]
entity SafeStateChannelC {
    in clk: clock
    in rst: bit
    in fault_cmd: bit
    in fault_overcurrent: bit
    in fault_watchdog: bit
    in fault_clear: bit
    out safe_state: bit
    out force_motor_off: bit
    out fault_latched: bit
}

impl SafeStateChannelC {
    signal no_fault_counter: bit[8] = 0
    signal safe_state_reg: bit = 1
    signal fault_seen: bit = 0
    signal any_fault: bit = fault_cmd | fault_overcurrent | fault_watchdog

    on(clk.rise) {
        if (rst) {
            no_fault_counter = 0
            safe_state_reg = 1
            fault_seen = 0
        } else {
            if (any_fault) {
                no_fault_counter = 0
                safe_state_reg = 1
                fault_seen = 1
            } else {
                if (no_fault_counter < 255) {
                    no_fault_counter = no_fault_counter + 1
                }
                if (fault_clear & (no_fault_counter > 16)) {
                    safe_state_reg = 0
                    fault_seen = 0
                }
            }
        }
    }

    safe_state = safe_state_reg
    force_motor_off = safe_state_reg | any_fault
    fault_latched = fault_seen
}

// =============================================================================
// TMR Safe State Controller
// =============================================================================
#[implements(SG001::SafeStateManagement)]
#[implements(SG002::SafeStateManagement)]
#[safety_mechanism(type = tmr)]
entity DiverseTmrSafeStateController {
    in clk: clock
    in rst: bit
    in fault_cmd: bit
    in fault_overcurrent: bit
    in fault_watchdog: bit
    in fault_sm: bit
    in fault_clear: bit
    out safe_state: bit
    out force_motor_off: bit
    #[detection_signal]
    out fault_latched: bit
    #[detection_signal]
    out tmr_fault: bit
    #[detection_signal]
    out sm_fault: bit
}

impl DiverseTmrSafeStateController {
    signal ss_a: bit
    signal ss_b: bit
    signal ss_c: bit
    signal fmo_a: bit
    signal fmo_b: bit
    signal fmo_c: bit
    signal fl_a: bit
    signal fl_b: bit
    signal fl_c: bit

    signal combined_fault: bit = fault_cmd | fault_sm

    let ch_a = SafeStateChannelA { clk: clk, rst: rst, fault_cmd: combined_fault, fault_overcurrent: fault_overcurrent, fault_watchdog: fault_watchdog, fault_clear: fault_clear, safe_state: ss_a, force_motor_off: fmo_a, fault_latched: fl_a }
    let ch_b = SafeStateChannelB { clk: clk, rst: rst, fault_cmd: combined_fault, fault_overcurrent: fault_overcurrent, fault_watchdog: fault_watchdog, fault_clear: fault_clear, safe_state: ss_b, force_motor_off: fmo_b, fault_latched: fl_b }
    let ch_c = SafeStateChannelC { clk: clk, rst: rst, fault_cmd: combined_fault, fault_overcurrent: fault_overcurrent, fault_watchdog: fault_watchdog, fault_clear: fault_clear, safe_state: ss_c, force_motor_off: fmo_c, fault_latched: fl_c }

    // Voting
    signal voted_ss: bit = if ss_a == ss_b { ss_a } else { ss_c }
    signal voted_fmo: bit = fmo_a | fmo_b | fmo_c
    signal fl_count: bit[2] = (fl_a as bit[2]) + (fl_b as bit[2]) + (fl_c as bit[2])
    signal voted_fl: bit = if fl_count > 1 { 1 } else { 0 }

    // Fault detection
    signal ss_all_same: bit = if ss_a == ss_b { if ss_b == ss_c { 1 } else { 0 } } else { 0 }
    signal fmo_all_same: bit = if fmo_a == fmo_b { if fmo_b == fmo_c { 1 } else { 0 } } else { 0 }
    signal fl_all_same: bit = if fl_a == fl_b { if fl_b == fl_c { 1 } else { 0 } } else { 0 }

    // SM-of-SM: count-based fault check
    signal ss_count: bit[2] = (ss_a as bit[2]) + (ss_b as bit[2]) + (ss_c as bit[2])
    signal ss_count_fault: bit = if ss_count == 1 { 1 } else { if ss_count == 2 { 1 } else { 0 } }
    signal methods_agree: bit = if ss_count_fault == (~ss_all_same) { 1 } else { 0 }

    safe_state = voted_ss
    force_motor_off = voted_fmo
    fault_latched = voted_fl
    tmr_fault = ~ss_all_same | ~fmo_all_same | ~fl_all_same
    sm_fault = ~methods_agree
}

// =============================================================================
// Top-Level: Motor Control Unit v8 - ASIL-D Enhanced
// =============================================================================
entity MotorControlUnitV8 {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    in current_adc: bit[10]
    in overcurrent_threshold: bit[10]
    in watchdog_timeout: bit[8]
    in watchdog_kick: bit
    in fault_clear: bit
    in start_bist: bit
    in periodic_trigger: bit

    out motor_pwm: bit
    out motor_active: bit
    out system_healthy: bit
    out in_safe_state: bit

    // Boot-time detection (BIST)
    #[detection_signal(mode = "boot")]
    out det_bist_complete: bit
    #[detection_signal(mode = "boot")]
    out det_bist_pass: bit
    #[detection_signal(mode = "boot")]
    out det_bist_ram: bit
    #[detection_signal(mode = "boot")]
    out det_bist_rom: bit
    #[detection_signal(mode = "boot")]
    out det_bist_voter: bit
    #[detection_signal(mode = "boot")]
    out det_bist_cmp: bit

    // Periodic detection
    #[detection_signal(mode = "periodic")]
    out det_periodic_done: bit
    #[detection_signal(mode = "periodic")]
    out det_periodic_voter: bit
    #[detection_signal(mode = "periodic")]
    out det_periodic_cmp: bit

    // Continuous detection (runtime)
    #[detection_signal]
    out det_cmd_error: bit
    #[detection_signal]
    out det_cmd_tmr: bit
    #[detection_signal]
    out det_cmd_sm: bit
    #[detection_signal]
    out det_pwm_fault: bit
    #[detection_signal]
    out det_pwm_encoding: bit
    #[detection_signal]
    out det_overcurrent: bit
    #[detection_signal]
    out det_curr_tmr: bit
    #[detection_signal]
    out det_curr_sm: bit
    #[detection_signal]
    out det_timeout: bit
    #[detection_signal]
    out det_wd_fault: bit
    #[detection_signal]
    out det_fault_latched: bit
    #[detection_signal]
    out det_ss_tmr: bit
    #[detection_signal]
    out det_ss_sm: bit
}

impl MotorControlUnitV8 {
    // Internal signals
    signal val_throttle: bit[8]
    signal val_enable: bit
    signal cmd_err: bit
    signal cmd_tmr_fault: bit
    signal cmd_sm_fault: bit
    signal voter_in_a: bit
    signal voter_in_b: bit
    signal voter_in_c: bit

    signal pwm_signal: bit
    signal pwm_is_active: bit
    signal pwm_err: bit
    signal pwm_enc_err: bit

    signal oc_detected: bit
    signal current_ok: bit
    signal curr_tmr_err: bit
    signal curr_sm_fault: bit
    signal oc_a: bit
    signal oc_b: bit
    signal oc_c: bit

    signal wd_timeout: bit
    signal wd_healthy: bit
    signal wd_err: bit

    signal safe_state: bit
    signal force_off: bit
    signal fault_latch: bit
    signal ss_tmr_err: bit
    signal ss_sm_fault: bit

    // BIST signals
    signal bist_done: bit
    signal bist_ok: bit
    signal bist_ram: bit
    signal bist_rom: bit
    signal bist_voter: bit
    signal bist_cmp: bit

    // Periodic test signals
    signal periodic_done: bit
    signal periodic_voter: bit
    signal periodic_cmp: bit

    // BIST Controller
    let bist = BistController {
        clk: clk, rst: rst, start_bist: start_bist,
        bist_complete: bist_done, bist_pass: bist_ok,
        ram_ok: bist_ram, rom_ok: bist_rom,
        voter_ok: bist_voter, comparator_ok: bist_cmp
    }

    // Command Processor (TMR)
    let cmd_proc = DiverseTmrCommandProcessor {
        clk: clk, rst: rst,
        cmd_valid: cmd_valid, cmd_throttle: cmd_throttle, cmd_enable: cmd_enable,
        validated_throttle: val_throttle, validated_enable: val_enable,
        cmd_error: cmd_err, tmr_fault: cmd_tmr_fault, sm_fault: cmd_sm_fault,
        voter_in_a: voter_in_a, voter_in_b: voter_in_b, voter_in_c: voter_in_c
    }

    // PWM Generator (DMR with encoding)
    let pwm_gen = DiversePWMGenerator {
        clk: clk, rst: rst,
        throttle: val_throttle, enable: val_enable, force_off: force_off,
        pwm_out: pwm_signal, pwm_active: pwm_is_active,
        pwm_fault: pwm_err, encoding_fault: pwm_enc_err
    }

    // Current Monitor (TMR)
    let curr_mon = DiverseTmrCurrentMonitor {
        clk: clk, rst: rst,
        current_adc: current_adc, threshold: overcurrent_threshold,
        overcurrent: oc_detected, current_valid: current_ok,
        tmr_fault: curr_tmr_err, sm_fault: curr_sm_fault,
        oc_ch_a: oc_a, oc_ch_b: oc_b, oc_ch_c: oc_c
    }

    // Watchdog (DMR)
    let watchdog = DiverseDualWatchdog {
        clk: clk, rst: rst,
        kick: watchdog_kick, timeout_limit: watchdog_timeout,
        timeout: wd_timeout, healthy: wd_healthy, watchdog_fault: wd_err
    }

    // Periodic Self-Test
    signal voted_oc: bit = (oc_a & oc_b) | (oc_b & oc_c) | (oc_a & oc_c)
    signal cmp_in_a: bit[8] = val_throttle
    signal cmp_in_b: bit[8] = val_throttle  // Should match
    signal cmp_out: bit = if cmp_in_a == cmp_in_b { 1 } else { 0 }

    let periodic = PeriodicSelfTest {
        clk: clk, rst: rst, trigger: periodic_trigger,
        voter_in_a: oc_a, voter_in_b: oc_b, voter_in_c: oc_c, voter_out: voted_oc,
        comparator_in_a: cmp_in_a, comparator_in_b: cmp_in_b, comparator_out: cmp_out,
        test_complete: periodic_done, voter_check_ok: periodic_voter, comparator_check_ok: periodic_cmp
    }

    // Fault aggregation
    signal agg_fault: bit = cmd_tmr_fault | pwm_err | curr_tmr_err | wd_err | cmd_sm_fault | curr_sm_fault | ss_sm_fault | pwm_enc_err

    // Safe State Controller
    let safe_ctrl = DiverseTmrSafeStateController {
        clk: clk, rst: rst,
        fault_cmd: cmd_err, fault_overcurrent: oc_detected, fault_watchdog: wd_timeout,
        fault_sm: agg_fault, fault_clear: fault_clear,
        safe_state: safe_state, force_motor_off: force_off,
        fault_latched: fault_latch, tmr_fault: ss_tmr_err, sm_fault: ss_sm_fault
    }

    // Outputs
    motor_pwm = pwm_signal
    motor_active = pwm_is_active
    system_healthy = wd_healthy & current_ok & ~cmd_err & ~agg_fault & bist_ok
    in_safe_state = safe_state

    // Boot-time detection outputs
    det_bist_complete = bist_done
    det_bist_pass = bist_ok
    det_bist_ram = bist_ram
    det_bist_rom = bist_rom
    det_bist_voter = bist_voter
    det_bist_cmp = bist_cmp

    // Periodic detection outputs
    det_periodic_done = periodic_done
    det_periodic_voter = periodic_voter
    det_periodic_cmp = periodic_cmp

    // Continuous detection outputs
    det_cmd_error = cmd_err
    det_cmd_tmr = cmd_tmr_fault
    det_cmd_sm = cmd_sm_fault
    det_pwm_fault = pwm_err
    det_pwm_encoding = pwm_enc_err
    det_overcurrent = oc_detected
    det_curr_tmr = curr_tmr_err
    det_curr_sm = curr_sm_fault
    det_timeout = wd_timeout
    det_wd_fault = wd_err
    det_fault_latched = fault_latch
    det_ss_tmr = ss_tmr_err
    det_ss_sm = ss_sm_fault
}
