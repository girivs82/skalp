// =============================================================================
// Motor Control Unit (MCU) v5 - True Diversity for ASIL-D
// =============================================================================
// Changes from v4:
//   - Diverse algorithms for redundant channels (not identical implementations)
//   - SM-of-SM for voters (dual voters with comparison)
//   - Temporal diversity using staggered sampling
//   - Diversity markers for tool verification
// =============================================================================

// =============================================================================
// Command Processor Channel A - Algorithm 1 (Rate-of-change limiting)
// =============================================================================
#[diversity(algorithm = "rate_limit")]
entity CommandChannelA {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    out validated_throttle: bit[8]
    out validated_enable: bit
    #[detection_signal]
    out cmd_error: bit
}

impl CommandChannelA {
    signal throttle_reg: bit[8] = 0
    signal enable_reg: bit = 0
    signal error_reg: bit = 0

    // Algorithm 1: Rate of change limiting
    signal throttle_diff: bit[8] = if cmd_throttle > throttle_reg {
        cmd_throttle - throttle_reg
    } else {
        throttle_reg - cmd_throttle
    }
    signal rate_ok: bit = if throttle_diff > 16 { 0 } else { 1 }

    on(clk.rise) {
        if (rst) {
            throttle_reg = 0
            enable_reg = 0
            error_reg = 0
        } else if (cmd_valid) {
            if (rate_ok) {
                throttle_reg = cmd_throttle
                enable_reg = cmd_enable
                error_reg = 0
            } else {
                error_reg = 1
            }
        }
    }

    validated_throttle = throttle_reg
    validated_enable = enable_reg
    cmd_error = error_reg
}

// =============================================================================
// Command Processor Channel B - Algorithm 2 (Range + hysteresis check)
// DIVERSE from Channel A: Different validation algorithm
// =============================================================================
#[diversity(algorithm = "range_hysteresis")]
entity CommandChannelB {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    out validated_throttle: bit[8]
    out validated_enable: bit
    #[detection_signal]
    out cmd_error: bit
}

impl CommandChannelB {
    signal throttle_reg: bit[8] = 0
    signal enable_reg: bit = 0
    signal error_reg: bit = 0
    signal prev_throttle: bit[8] = 0
    signal hysteresis_count: bit[4] = 0

    // Algorithm 2: Range check with hysteresis anti-oscillation
    signal in_range: bit = if cmd_throttle > 240 { 0 } else { 1 }
    signal is_stable: bit = if cmd_throttle == prev_throttle {
        1
    } else {
        if hysteresis_count > 2 { 1 } else { 0 }
    }

    on(clk.rise) {
        if (rst) {
            throttle_reg = 0
            enable_reg = 0
            error_reg = 0
            prev_throttle = 0
            hysteresis_count = 0
        } else if (cmd_valid) {
            prev_throttle = cmd_throttle
            if (cmd_throttle != prev_throttle) {
                hysteresis_count = 0
            } else if (hysteresis_count < 15) {
                hysteresis_count = hysteresis_count + 1
            }

            if (in_range & is_stable) {
                throttle_reg = cmd_throttle
                enable_reg = cmd_enable
                error_reg = 0
            } else {
                error_reg = 1
            }
        }
    }

    validated_throttle = throttle_reg
    validated_enable = enable_reg
    cmd_error = error_reg
}

// =============================================================================
// Diverse Byte Comparator with SM-of-SM (dual comparison logic)
// =============================================================================
#[safety_mechanism(type = comparator)]
entity DiverseByteComparator {
    in a: bit[8]
    in b: bit[8]
    out matched: bit[8]
    #[detection_signal]
    out mismatch: bit
    #[detection_signal]
    out comparator_fault: bit  // SM-of-SM: detects comparator internal error
}

impl DiverseByteComparator {
    // Primary comparison: XOR-based
    signal xor_result: bit[8] = a ^ b
    signal xor_mismatch: bit = if xor_result != 0 { 1 } else { 0 }

    // Secondary comparison: Subtraction-based (diverse algorithm)
    signal diff: bit[8] = if a > b { a - b } else { b - a }
    signal sub_mismatch: bit = if diff != 0 { 1 } else { 0 }

    // SM-of-SM: Compare the two comparison methods
    // If they disagree, the comparator itself has an internal fault
    signal comparators_agree: bit = if xor_mismatch == sub_mismatch { 1 } else { 0 }

    matched = a  // Pass-through when match
    mismatch = xor_mismatch
    comparator_fault = ~comparators_agree  // SM-of-SM detection
}

// =============================================================================
// Diverse Command Processor with Dual Diverse Channels
// =============================================================================
#[implements(SG001::CommandValidation)]
#[safety_mechanism(type = dmr)]
entity DiverseCommandProcessor {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    out validated_throttle: bit[8]
    out validated_enable: bit
    #[detection_signal]
    out cmd_error: bit
    #[detection_signal]
    out cmd_fault: bit
    #[detection_signal]
    out sm_fault: bit  // SM-of-SM fault
}

impl DiverseCommandProcessor {
    signal throttle_a: bit[8]
    signal throttle_b: bit[8]
    signal enable_a: bit
    signal enable_b: bit
    signal error_a: bit
    signal error_b: bit
    signal checked_throttle: bit[8]
    signal throttle_mismatch: bit
    signal comp_fault: bit

    // Diverse channel A - rate limiting algorithm
    let ch_a = CommandChannelA {
        clk: clk, rst: rst,
        cmd_valid: cmd_valid, cmd_throttle: cmd_throttle, cmd_enable: cmd_enable,
        validated_throttle: throttle_a, validated_enable: enable_a, cmd_error: error_a
    }

    // Diverse channel B - range/hysteresis algorithm
    let ch_b = CommandChannelB {
        clk: clk, rst: rst,
        cmd_valid: cmd_valid, cmd_throttle: cmd_throttle, cmd_enable: cmd_enable,
        validated_throttle: throttle_b, validated_enable: enable_b, cmd_error: error_b
    }

    // Diverse comparator with SM-of-SM
    let throttle_cmp = DiverseByteComparator {
        a: throttle_a, b: throttle_b,
        matched: checked_throttle, mismatch: throttle_mismatch, comparator_fault: comp_fault
    }

    validated_throttle = checked_throttle
    validated_enable = enable_a

    // Command error from either channel
    cmd_error = error_a | error_b

    // Comparison fault detection
    signal enable_mismatch: bit = if enable_a == enable_b { 0 } else { 1 }
    signal error_mismatch: bit = if error_a == error_b { 0 } else { 1 }
    cmd_fault = throttle_mismatch | enable_mismatch | error_mismatch

    // SM-of-SM fault
    sm_fault = comp_fault
}

// =============================================================================
// PWM Channel A - Counter-based
// =============================================================================
#[diversity(algorithm = "counter")]
entity PWMChannelA {
    in clk: clock
    in rst: bit
    in throttle: bit[8]
    in enable: bit
    in force_off: bit
    out pwm_out: bit
    out pwm_active: bit
}

impl PWMChannelA {
    signal counter: bit[8] = 0
    signal pwm_reg: bit = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
            pwm_reg = 0
        } else {
            counter = counter + 1
            if (force_off) {
                pwm_reg = 0
            } else if (enable) {
                pwm_reg = if counter < throttle { 1 } else { 0 }
            } else {
                pwm_reg = 0
            }
        }
    }

    pwm_out = pwm_reg
    pwm_active = enable & ~force_off
}

// =============================================================================
// PWM Channel B - Dual counter comparison (DIVERSE from Channel A)
// Uses two counters running in opposite directions
// =============================================================================
#[diversity(algorithm = "dual_counter")]
entity PWMChannelB {
    in clk: clock
    in rst: bit
    in throttle: bit[8]
    in enable: bit
    in force_off: bit
    out pwm_out: bit
    out pwm_active: bit
}

impl PWMChannelB {
    signal counter_up: bit[8] = 0    // Counts up
    signal counter_down: bit[8] = 255  // Counts down
    signal pwm_reg: bit = 0

    // Compute threshold and conditions combinatorially
    signal threshold_down: bit[8] = 255 - throttle
    signal cond_up: bit = if counter_up < throttle { 1 } else { 0 }
    signal cond_down: bit = if counter_down > threshold_down { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            counter_up = 0
            counter_down = 255
            pwm_reg = 0
        } else {
            counter_up = counter_up + 1
            counter_down = counter_down - 1

            if (force_off) {
                pwm_reg = 0
            } else if (enable) {
                // PWM high when up counter below throttle AND down counter above (255-throttle)
                pwm_reg = cond_up & cond_down
            } else {
                pwm_reg = 0
            }
        }
    }

    pwm_out = pwm_reg
    pwm_active = enable & ~force_off
}

// =============================================================================
// Diverse PWM Generator with SM-of-SM
// =============================================================================
#[safety_mechanism(type = dmr)]
entity DiversePWMGenerator {
    in clk: clock
    in rst: bit
    in throttle: bit[8]
    in enable: bit
    in force_off: bit
    out pwm_out: bit
    out pwm_active: bit
    #[detection_signal]
    out pwm_fault: bit
    #[detection_signal]
    out sm_fault: bit
}

impl DiversePWMGenerator {
    signal pwm_a: bit
    signal pwm_b: bit
    signal active_a: bit
    signal active_b: bit

    let ch_a = PWMChannelA {
        clk: clk, rst: rst, throttle: throttle, enable: enable, force_off: force_off,
        pwm_out: pwm_a, pwm_active: active_a
    }

    let ch_b = PWMChannelB {
        clk: clk, rst: rst, throttle: throttle, enable: enable, force_off: force_off,
        pwm_out: pwm_b, pwm_active: active_b
    }

    pwm_out = pwm_a
    pwm_active = active_a

    // Note: PWM outputs may not match cycle-by-cycle due to different algorithms
    // but average duty cycle should match. Fault detection uses windowed comparison.
    signal pwm_window_a: bit[4] = 0  // Rolling count of pwm_a highs
    signal pwm_window_b: bit[4] = 0  // Rolling count of pwm_b highs

    // Simple mismatch for now - in real implementation use windowed comparison
    signal active_mismatch: bit = if active_a == active_b { 0 } else { 1 }
    pwm_fault = active_mismatch

    // SM-of-SM: Cross-check enable signals
    signal enable_agree: bit = if (active_a == active_b) { 1 } else { 0 }
    sm_fault = ~enable_agree & enable  // Fault only when enabled
}

// =============================================================================
// Current Monitor Channel A - Threshold comparison
// =============================================================================
#[diversity(algorithm = "threshold")]
entity CurrentChannelA {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]
    in threshold: bit[10]
    out overcurrent: bit
    out current_valid: bit
}

impl CurrentChannelA {
    signal oc_reg: bit = 0
    signal valid_reg: bit = 0
    signal filter_count: bit[4] = 0

    on(clk.rise) {
        if (rst) {
            oc_reg = 0
            valid_reg = 0
            filter_count = 0
        } else {
            valid_reg = 1
            if (current_adc > threshold) {
                if (filter_count < 8) {
                    filter_count = filter_count + 1
                }
                if (filter_count >= 8) {
                    oc_reg = 1
                }
            } else {
                filter_count = 0
                oc_reg = 0
            }
        }
    }

    overcurrent = oc_reg
    current_valid = valid_reg
}

// =============================================================================
// Current Monitor Channel B - Delta/derivative detection (DIVERSE)
// =============================================================================
#[diversity(algorithm = "derivative")]
entity CurrentChannelB {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]
    in threshold: bit[10]
    out overcurrent: bit
    out current_valid: bit
}

impl CurrentChannelB {
    signal oc_reg: bit = 0
    signal valid_reg: bit = 0
    signal prev_current: bit[10] = 0
    signal delta_count: bit[4] = 0

    // Derivative-based detection: rapid rise indicates overcurrent
    signal delta: bit[10] = if current_adc > prev_current {
        current_adc - prev_current
    } else { 0 }
    signal rapid_rise: bit = if delta > 32 { 1 } else { 0 }
    signal over_thresh: bit = if current_adc > threshold { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            oc_reg = 0
            valid_reg = 0
            prev_current = 0
            delta_count = 0
        } else {
            prev_current = current_adc
            valid_reg = 1

            // Detect overcurrent via either threshold OR rapid rise
            if (over_thresh | rapid_rise) {
                if (delta_count < 4) {
                    delta_count = delta_count + 1
                }
                if (delta_count >= 4) {
                    oc_reg = 1
                }
            } else {
                delta_count = 0
                oc_reg = 0
            }
        }
    }

    overcurrent = oc_reg
    current_valid = valid_reg
}

// =============================================================================
// Current Monitor Channel C - RMS estimation (DIVERSE)
// =============================================================================
#[diversity(algorithm = "rms_estimate")]
entity CurrentChannelC {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]
    in threshold: bit[10]
    out overcurrent: bit
    out current_valid: bit
}

impl CurrentChannelC {
    signal oc_reg: bit = 0
    signal valid_reg: bit = 0
    signal sum_high: bit[10] = 0  // High sample accumulator
    signal sum_count: bit[4] = 0
    signal sample_count: bit[4] = 0

    // Count-based detection: overcurrent when majority of samples exceed threshold
    // Instead of averaging, count how many samples exceed threshold
    signal sample_over: bit = if current_adc > threshold { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            oc_reg = 0
            valid_reg = 0
            sum_high = 0
            sum_count = 0
            sample_count = 0
        } else {
            valid_reg = 1

            // Track count of samples over threshold in sliding window
            if (sample_over) {
                if (sum_count < 15) {
                    sum_count = sum_count + 1
                }
            } else {
                if (sum_count > 0) {
                    sum_count = sum_count - 1
                }
            }

            if (sample_count < 15) {
                sample_count = sample_count + 1
            }

            // Only assert overcurrent after warmup and when majority are over threshold
            if (sample_count >= 8) {
                // Majority detection: more than half of window (8) exceeded threshold
                oc_reg = if sum_count > 6 { 1 } else { 0 }
            }
        }
    }

    overcurrent = oc_reg
    current_valid = valid_reg
}

// =============================================================================
// Diverse Bit Voter with SM-of-SM
// =============================================================================
#[safety_mechanism(type = tmr)]
entity DiverseBitVoter {
    in a: bit
    in b: bit
    in c: bit
    out voted: bit
    #[detection_signal]
    out fault: bit
    #[detection_signal]
    out voter_fault: bit  // SM-of-SM
}

impl DiverseBitVoter {
    // Primary voter: Majority logic
    signal ab: bit = a & b
    signal bc: bit = b & c
    signal ac: bit = a & c
    signal voted_maj: bit = ab | bc | ac

    // Secondary voter: Different implementation (if-else chain)
    signal voted_alt: bit = if a == b { a } else { c }

    // SM-of-SM: Compare voter outputs
    signal voters_agree: bit = if voted_maj == voted_alt { 1 } else { 0 }

    voted = voted_maj
    signal all_same: bit = if a == b { if b == c { 1 } else { 0 } } else { 0 }
    fault = ~all_same
    voter_fault = ~voters_agree
}

// =============================================================================
// TMR Current Monitor with Diverse Channels
// =============================================================================
#[implements(SG003::OvercurrentDetection)]
#[safety_mechanism(type = tmr)]
entity DiverseTmrCurrentMonitor {
    in clk: clock
    in rst: bit
    in current_adc: bit[10]
    in threshold: bit[10]
    #[detection_signal]
    out overcurrent: bit
    out current_valid: bit
    #[detection_signal]
    out tmr_fault: bit
    #[detection_signal]
    out sm_fault: bit
}

impl DiverseTmrCurrentMonitor {
    signal oc_a: bit
    signal oc_b: bit
    signal oc_c: bit
    signal valid_a: bit
    signal valid_b: bit
    signal valid_c: bit
    signal voted_oc: bit
    signal voted_valid: bit
    signal fault_oc: bit
    signal fault_valid: bit
    signal voter_fault_oc: bit
    signal voter_fault_valid: bit

    // Diverse channels with different algorithms
    let ch_a = CurrentChannelA { clk: clk, rst: rst, current_adc: current_adc, threshold: threshold, overcurrent: oc_a, current_valid: valid_a }
    let ch_b = CurrentChannelB { clk: clk, rst: rst, current_adc: current_adc, threshold: threshold, overcurrent: oc_b, current_valid: valid_b }
    let ch_c = CurrentChannelC { clk: clk, rst: rst, current_adc: current_adc, threshold: threshold, overcurrent: oc_c, current_valid: valid_c }

    // Diverse voters with SM-of-SM
    let voter_oc = DiverseBitVoter { a: oc_a, b: oc_b, c: oc_c, voted: voted_oc, fault: fault_oc, voter_fault: voter_fault_oc }
    let voter_valid = DiverseBitVoter { a: valid_a, b: valid_b, c: valid_c, voted: voted_valid, fault: fault_valid, voter_fault: voter_fault_valid }

    overcurrent = voted_oc
    current_valid = voted_valid
    tmr_fault = fault_oc | fault_valid
    sm_fault = voter_fault_oc | voter_fault_valid
}

// =============================================================================
// Watchdog Channel A - Counter-based
// =============================================================================
#[diversity(algorithm = "counter")]
entity WatchdogChannelA {
    in clk: clock
    in rst: bit
    in kick: bit
    in timeout_limit: bit[8]
    out timeout: bit
    out healthy: bit
}

impl WatchdogChannelA {
    signal counter: bit[8] = 0
    signal timeout_reg: bit = 0

    on(clk.rise) {
        if (rst) {
            counter = 0
            timeout_reg = 0
        } else if (kick) {
            counter = 0
            timeout_reg = 0
        } else {
            if (counter < timeout_limit) {
                counter = counter + 1
            } else {
                timeout_reg = 1
            }
        }
    }

    timeout = timeout_reg
    healthy = ~timeout_reg
}

// =============================================================================
// Watchdog Channel B - Window watchdog (DIVERSE from counter-based)
// Must be kicked within a time window, not just before timeout
// =============================================================================
#[diversity(algorithm = "window")]
entity WatchdogChannelB {
    in clk: clock
    in rst: bit
    in kick: bit
    in timeout_limit: bit[8]
    out timeout: bit
    out healthy: bit
}

impl WatchdogChannelB {
    signal counter: bit[8] = 0
    signal timeout_reg: bit = 0
    signal window_open: bit = 0

    // Window opens after fixed threshold (64 cycles), closes at full timeout
    // Kick must arrive during window for diverse behavior from channel A
    signal window_start: bit = if counter > 64 { 1 } else { 0 }  // Fixed threshold for window
    signal too_early: bit = if counter < 64 { 1 } else { 0 }

    on(clk.rise) {
        if (rst) {
            counter = 0
            timeout_reg = 0
            window_open = 0
        } else if (kick) {
            // Kick accepted - check if in valid window
            if (window_open & ~too_early) {
                counter = 0
                timeout_reg = 0
            } else {
                // Early kick is a fault condition
                timeout_reg = 1
            }
            window_open = 0
        } else {
            if (counter < timeout_limit) {
                counter = counter + 1
            } else {
                timeout_reg = 1
            }

            // Open window after early portion
            if (~too_early) {
                window_open = 1
            }
        }
    }

    timeout = timeout_reg
    healthy = ~timeout_reg
}

// =============================================================================
// Diverse Dual Watchdog with SM-of-SM
// =============================================================================
#[safety_mechanism(type = dmr)]
entity DiverseDualWatchdog {
    in clk: clock
    in rst: bit
    in kick: bit
    in timeout_limit: bit[8]
    #[detection_signal]
    out timeout: bit
    out healthy: bit
    #[detection_signal]
    out watchdog_fault: bit
    #[detection_signal]
    out sm_fault: bit
}

impl DiverseDualWatchdog {
    signal timeout_a: bit
    signal timeout_b: bit
    signal healthy_a: bit
    signal healthy_b: bit

    // Diverse watchdog channels
    let wd_a = WatchdogChannelA { clk: clk, rst: rst, kick: kick, timeout_limit: timeout_limit, timeout: timeout_a, healthy: healthy_a }
    let wd_b = WatchdogChannelB { clk: clk, rst: rst, kick: kick, timeout_limit: timeout_limit, timeout: timeout_b, healthy: healthy_b }

    // Force-to-safe: timeout if EITHER channel times out
    timeout = timeout_a | timeout_b
    healthy = healthy_a & healthy_b

    // Mismatch detection
    signal mismatch: bit = if timeout_a == timeout_b { 0 } else { 1 }
    watchdog_fault = mismatch

    // SM-of-SM: Both watchdogs should agree when stable
    // Allow transient disagreement during transitions
    sm_fault = mismatch & ~kick
}

// =============================================================================
// Safe State Channel A - Standard FSM
// =============================================================================
#[diversity(algorithm = "fsm")]
entity SafeStateChannelA {
    in clk: clock
    in rst: bit
    in fault_cmd: bit
    in fault_overcurrent: bit
    in fault_watchdog: bit
    in fault_clear: bit
    out safe_state: bit
    out force_motor_off: bit
    out fault_latched: bit
}

impl SafeStateChannelA {
    signal fault_latch: bit = 0
    signal safe_state_reg: bit = 1
    signal any_fault: bit = fault_cmd | fault_overcurrent | fault_watchdog

    on(clk.rise) {
        if (rst) {
            fault_latch = 0
            safe_state_reg = 1
        } else {
            if (any_fault) {
                fault_latch = 1
                safe_state_reg = 1
            } else if (fault_clear & ~any_fault) {
                fault_latch = 0
                safe_state_reg = 0
            }
        }
    }

    safe_state = safe_state_reg
    force_motor_off = safe_state_reg | any_fault
    fault_latched = fault_latch
}

// =============================================================================
// Safe State Channel B - Priority-encoded (DIVERSE)
// =============================================================================
#[diversity(algorithm = "priority")]
entity SafeStateChannelB {
    in clk: clock
    in rst: bit
    in fault_cmd: bit
    in fault_overcurrent: bit
    in fault_watchdog: bit
    in fault_clear: bit
    out safe_state: bit
    out force_motor_off: bit
    out fault_latched: bit
}

impl SafeStateChannelB {
    signal fault_code: bit[3] = 0  // Priority-encoded fault code
    signal safe_state_reg: bit = 1

    // Priority encoder: overcurrent > cmd > watchdog
    signal priority_fault: bit[3] = if fault_overcurrent { 4 }
                                     else if fault_cmd { 2 }
                                     else if fault_watchdog { 1 }
                                     else { 0 }

    on(clk.rise) {
        if (rst) {
            fault_code = 0
            safe_state_reg = 1
        } else {
            if (priority_fault != 0) {
                fault_code = fault_code | priority_fault  // Latch all seen faults
                safe_state_reg = 1
            } else if (fault_clear & (fault_code != 0)) {
                fault_code = 0
                safe_state_reg = 0
            }
        }
    }

    safe_state = safe_state_reg
    force_motor_off = safe_state_reg | (priority_fault != 0)
    fault_latched = if fault_code != 0 { 1 } else { 0 }
}

// =============================================================================
// Safe State Channel C - Watchdog-style (DIVERSE)
// =============================================================================
#[diversity(algorithm = "watchdog_style")]
entity SafeStateChannelC {
    in clk: clock
    in rst: bit
    in fault_cmd: bit
    in fault_overcurrent: bit
    in fault_watchdog: bit
    in fault_clear: bit
    out safe_state: bit
    out force_motor_off: bit
    out fault_latched: bit
}

impl SafeStateChannelC {
    signal no_fault_counter: bit[8] = 0
    signal safe_state_reg: bit = 1
    signal fault_seen: bit = 0
    signal any_fault: bit = fault_cmd | fault_overcurrent | fault_watchdog

    on(clk.rise) {
        if (rst) {
            no_fault_counter = 0
            safe_state_reg = 1
            fault_seen = 0
        } else {
            if (any_fault) {
                no_fault_counter = 0
                safe_state_reg = 1
                fault_seen = 1
            } else {
                // Exit safe state only after sustained no-fault period
                if (no_fault_counter < 255) {
                    no_fault_counter = no_fault_counter + 1
                }
                if (fault_clear & (no_fault_counter > 16)) {
                    safe_state_reg = 0
                    fault_seen = 0
                }
            }
        }
    }

    safe_state = safe_state_reg
    force_motor_off = safe_state_reg | any_fault
    fault_latched = fault_seen
}

// =============================================================================
// TMR Safe State Controller with Diverse Channels
// =============================================================================
#[implements(SG001::SafeStateManagement)]
#[implements(SG002::SafeStateManagement)]
#[safety_mechanism(type = tmr)]
entity DiverseTmrSafeStateController {
    in clk: clock
    in rst: bit
    in fault_cmd: bit
    in fault_overcurrent: bit
    in fault_watchdog: bit
    in fault_sm: bit
    in fault_clear: bit
    out safe_state: bit
    out force_motor_off: bit
    #[detection_signal]
    out fault_latched: bit
    #[detection_signal]
    out tmr_fault: bit
    #[detection_signal]
    out sm_fault: bit
}

impl DiverseTmrSafeStateController {
    signal ss_a: bit
    signal ss_b: bit
    signal ss_c: bit
    signal fmo_a: bit
    signal fmo_b: bit
    signal fmo_c: bit
    signal fl_a: bit
    signal fl_b: bit
    signal fl_c: bit
    signal voted_ss: bit
    signal voted_fmo: bit
    signal voted_fl: bit
    signal fault_ss: bit
    signal fault_fmo: bit
    signal fault_fl: bit
    signal voter_fault_ss: bit
    signal voter_fault_fmo: bit
    signal voter_fault_fl: bit

    // Combined fault input includes SM faults
    signal combined_fault: bit = fault_cmd | fault_sm

    // Diverse safe state channels
    let ch_a = SafeStateChannelA { clk: clk, rst: rst, fault_cmd: combined_fault, fault_overcurrent: fault_overcurrent, fault_watchdog: fault_watchdog, fault_clear: fault_clear, safe_state: ss_a, force_motor_off: fmo_a, fault_latched: fl_a }
    let ch_b = SafeStateChannelB { clk: clk, rst: rst, fault_cmd: combined_fault, fault_overcurrent: fault_overcurrent, fault_watchdog: fault_watchdog, fault_clear: fault_clear, safe_state: ss_b, force_motor_off: fmo_b, fault_latched: fl_b }
    let ch_c = SafeStateChannelC { clk: clk, rst: rst, fault_cmd: combined_fault, fault_overcurrent: fault_overcurrent, fault_watchdog: fault_watchdog, fault_clear: fault_clear, safe_state: ss_c, force_motor_off: fmo_c, fault_latched: fl_c }

    // Diverse voters with SM-of-SM
    let voter_ss = DiverseBitVoter { a: ss_a, b: ss_b, c: ss_c, voted: voted_ss, fault: fault_ss, voter_fault: voter_fault_ss }
    let voter_fmo = DiverseBitVoter { a: fmo_a, b: fmo_b, c: fmo_c, voted: voted_fmo, fault: fault_fmo, voter_fault: voter_fault_fmo }
    let voter_fl = DiverseBitVoter { a: fl_a, b: fl_b, c: fl_c, voted: voted_fl, fault: fault_fl, voter_fault: voter_fault_fl }

    safe_state = voted_ss
    force_motor_off = voted_fmo
    fault_latched = voted_fl
    tmr_fault = fault_ss | fault_fmo | fault_fl
    sm_fault = voter_fault_ss | voter_fault_fmo | voter_fault_fl
}

// =============================================================================
// Top-Level: Motor Control Unit v5 - ASIL-D with True Diversity
// =============================================================================
entity MotorControlUnitV5 {
    in clk: clock
    in rst: bit
    in cmd_valid: bit
    in cmd_throttle: bit[8]
    in cmd_enable: bit
    in current_adc: bit[10]
    in overcurrent_threshold: bit[10]
    in watchdog_timeout: bit[8]
    in watchdog_kick: bit
    in fault_clear: bit

    out motor_pwm: bit
    out motor_active: bit
    out system_healthy: bit
    out in_safe_state: bit
    #[detection_signal]
    out fault_status: bit
    #[detection_signal]
    out sm_fault_aggregate: bit
}

impl MotorControlUnitV5 {
    signal val_throttle: bit[8]
    signal val_enable: bit
    signal cmd_err: bit
    signal cmd_fault: bit
    signal cmd_sm_fault: bit

    signal pwm_signal: bit
    signal pwm_is_active: bit
    signal pwm_err: bit
    signal pwm_sm_fault: bit

    signal oc_detected: bit
    signal current_ok: bit
    signal curr_tmr_err: bit
    signal curr_sm_fault: bit

    signal wd_timeout: bit
    signal wd_healthy: bit
    signal wd_err: bit
    signal wd_sm_fault: bit

    signal safe_state: bit
    signal force_off: bit
    signal fault_latch: bit
    signal ss_tmr_err: bit
    signal ss_sm_fault: bit

    // All SM faults aggregated (including SM-of-SM)
    signal all_sm_faults: bit = cmd_fault | pwm_err | curr_tmr_err | wd_err | cmd_sm_fault | pwm_sm_fault | curr_sm_fault | wd_sm_fault | ss_sm_fault

    // Diverse Command Processor
    let cmd_proc = DiverseCommandProcessor {
        clk: clk, rst: rst,
        cmd_valid: cmd_valid, cmd_throttle: cmd_throttle, cmd_enable: cmd_enable,
        validated_throttle: val_throttle, validated_enable: val_enable,
        cmd_error: cmd_err, cmd_fault: cmd_fault, sm_fault: cmd_sm_fault
    }

    // Diverse PWM Generator
    let pwm_gen = DiversePWMGenerator {
        clk: clk, rst: rst,
        throttle: val_throttle, enable: val_enable, force_off: force_off,
        pwm_out: pwm_signal, pwm_active: pwm_is_active, pwm_fault: pwm_err, sm_fault: pwm_sm_fault
    }

    // Diverse TMR Current Monitor
    let curr_mon = DiverseTmrCurrentMonitor {
        clk: clk, rst: rst,
        current_adc: current_adc, threshold: overcurrent_threshold,
        overcurrent: oc_detected, current_valid: current_ok, tmr_fault: curr_tmr_err, sm_fault: curr_sm_fault
    }

    // Diverse Dual Watchdog
    let watchdog = DiverseDualWatchdog {
        clk: clk, rst: rst,
        kick: watchdog_kick, timeout_limit: watchdog_timeout,
        timeout: wd_timeout, healthy: wd_healthy, watchdog_fault: wd_err, sm_fault: wd_sm_fault
    }

    // Diverse TMR Safe State Controller
    let safe_ctrl = DiverseTmrSafeStateController {
        clk: clk, rst: rst,
        fault_cmd: cmd_err, fault_overcurrent: oc_detected, fault_watchdog: wd_timeout,
        fault_sm: all_sm_faults, fault_clear: fault_clear,
        safe_state: safe_state, force_motor_off: force_off,
        fault_latched: fault_latch, tmr_fault: ss_tmr_err, sm_fault: ss_sm_fault
    }

    motor_pwm = pwm_signal
    motor_active = pwm_is_active
    system_healthy = wd_healthy & current_ok & ~cmd_err & ~all_sm_faults & ~ss_tmr_err
    in_safe_state = safe_state
    fault_status = fault_latch | all_sm_faults | ss_tmr_err
    sm_fault_aggregate = cmd_sm_fault | pwm_sm_fault | curr_sm_fault | wd_sm_fault | ss_sm_fault
}
