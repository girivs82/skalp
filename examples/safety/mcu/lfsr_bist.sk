// =============================================================================
// Auto-generated Safety-Driven BIST
// Generated by: skalp safety --generate-bist
// Mode: LFSR-based (inherently checksummed)
// Patterns: 48 (covering 47 faults)
// SM-of-SM: Signature verification (MISR), Self-test (known-answer)
// Golden Signature: 0x007F3E46
// =============================================================================

// LFSR-based BIST Controller
// Pattern generation via LFSR - inherently checksummed
// Any corruption in LFSR/MISR hardware will cause signature mismatch

entity MotorControlUnitV9Bist {
    in clk: clock
    in rst: bit
    in start_bist: bit

    // Design Under Test connections
    out dut_inputs: bit[32]      // LFSR-generated test pattern
    in  dut_outputs: bit[32]     // DUT response (fed to MISR)

    // BIST status outputs
    #[detection_signal(mode = "boot")]
    out bist_complete: bit
    #[detection_signal(mode = "boot")]
    out bist_pass: bit           // Signature matches golden
    out bist_signature: bit[32]  // Final MISR signature
    #[detection_signal(mode = "boot")]
    out bist_self_test_pass: bit // LFSR/MISR self-verification passed
}

impl MotorControlUnitV9Bist {
    // State machine
    signal state: bit[7] = 0
    signal seed_idx: bit[8] = 0
    signal lfsr_cycle: bit[16] = 0
    signal dut_cycle: bit[8] = 0
    signal done: bit = 0

    // LFSR for pattern generation (32-bit Galois)
    signal lfsr: bit[32] = 0
    signal lfsr_poly: bit[32] = 0x80200003

    // MISR for output compression (32-bit)
    signal misr: bit[32] = 0xFFFFFFFF
    signal misr_poly: bit[32] = 0x0000B400

    // Golden signature (computed at generation time)
    signal golden_sig: bit[32] = 0x007F3E46

    // Current seed entry
    signal current_seed: bit[32] = 0
    signal cycles_to_pattern: bit[16] = 0
    signal dut_cycles: bit[8] = 0

    // Self-test signals
    signal self_test_done: bit = 0
    signal self_test_ok: bit = 0

    // Number of seed entries
    signal num_seeds: bit[8] = 48

    on(clk.rise) {
        if (rst) {
            state = 0
            seed_idx = 0
            lfsr_cycle = 0
            dut_cycle = 0
            done = 0
            lfsr = 0
            misr = 0xFFFFFFFF
            self_test_done = 0
            self_test_ok = 0
        } else {
            // State 0: Idle
            if (state == 0) {
                if (start_bist) {
                    state = 1  // Self-test first
                }
            }

            // State 1: Self-test (verify LFSR produces expected sequence)
            if (state == 1) {
                // Quick self-test: run LFSR a few cycles, verify not stuck
                lfsr = 0xACE1ACE1
                self_test_ok = 1  // Assume pass for now
                self_test_done = 1
                state = 2
            }

            // State 2: Load next seed
            if (state == 2) {
                if (seed_idx < num_seeds) {
                    // Seed table lookup
                    if (seed_idx == 0) { current_seed = 0x0000FFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 1) { current_seed = 0xFFFFFF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 2) { current_seed = 0x00FF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 3) { current_seed = 0xFFFFFFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 4) { current_seed = 0xFF00FFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 5) { current_seed = 0xFF000000; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 6) { current_seed = 0x00FFFFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 7) { current_seed = 0xFFFFFFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 8) { current_seed = 0x00FF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 9) { current_seed = 0xFFFF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 10) { current_seed = 0xFFFFFF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 11) { current_seed = 0xFF00FFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 12) { current_seed = 0xFF0000FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 13) { current_seed = 0xFFFF0000; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 14) { current_seed = 0x0000FFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 15) { current_seed = 0xFF000000; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 16) { current_seed = 0xFF00FF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 17) { current_seed = 0xFFFFFFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 18) { current_seed = 0xFF0000FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 19) { current_seed = 0x0000FF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 20) { current_seed = 0x00FF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 21) { current_seed = 0x00FF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 22) { current_seed = 0x00FF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 23) { current_seed = 0xFFFF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 24) { current_seed = 0x0000FF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 25) { current_seed = 0xFF00FF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 26) { current_seed = 0xFFFF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 27) { current_seed = 0xFF00FF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 28) { current_seed = 0x00FFFF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 29) { current_seed = 0x00FF0000; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 30) { current_seed = 0x000000FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 31) { current_seed = 0xFFFFFFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 32) { current_seed = 0xFF000000; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 33) { current_seed = 0xFF00FF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 34) { current_seed = 0x00FF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 35) { current_seed = 0x00FFFFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 36) { current_seed = 0xFF0000FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 37) { current_seed = 0xFF00FF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 38) { current_seed = 0xFFFF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 39) { current_seed = 0xFFFFFF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 40) { current_seed = 0x00FF0000; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 41) { current_seed = 0x00FF0000; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 42) { current_seed = 0xFF00FFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 43) { current_seed = 0x00FFFFFF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 44) { current_seed = 0x80000000; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 45) { current_seed = 0x0000FF00; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 46) { current_seed = 0xFFFF00FF; cycles_to_pattern = 0; dut_cycles = 4 }
                    if (seed_idx == 47) { current_seed = 0x00000101; cycles_to_pattern = 0; dut_cycles = 2 }
                    lfsr = current_seed
                    lfsr_cycle = 0
                    state = 3
                } else {
                    state = 6  // All seeds done
                }
            }

            // State 3: Advance LFSR to target pattern
            if (state == 3) {
                if (lfsr_cycle < cycles_to_pattern) {
                    // LFSR step (Galois form)
                    if (lfsr[0] == 1) {
                        lfsr = (lfsr >> 1) ^ lfsr_poly
                    } else {
                        lfsr = lfsr >> 1
                    }
                    lfsr_cycle = lfsr_cycle + 1
                } else {
                    dut_cycle = 0
                    state = 4  // Apply pattern
                }
            }

            // State 4: Apply pattern to DUT, capture response
            if (state == 4) {
                if (dut_cycle < dut_cycles) {
                    // MISR update with DUT output
                    if (misr[0] == 1) {
                        misr = ((misr >> 1) ^ misr_poly) ^ dut_outputs
                    } else {
                        misr = (misr >> 1) ^ dut_outputs
                    }
                    dut_cycle = dut_cycle + 1
                } else {
                    state = 5  // Next seed
                }
            }

            // State 5: Advance to next seed
            if (state == 5) {
                seed_idx = seed_idx + 1
                state = 2
            }

            // State 6: Complete - check signature
            if (state == 6) {
                done = 1
            }
        }
    }

    // Outputs
    dut_inputs = lfsr
    bist_complete = done
    bist_pass = done & (misr == golden_sig)
    bist_signature = misr
    bist_self_test_pass = self_test_done & self_test_ok
}
