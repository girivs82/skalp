// Common Type Definitions for Graphics Pipeline
//
// This module demonstrates SKALP's parametric type system:
// - Parametric vectors: vec<T, N>
// - Parametric matrices: [[T; R]; C]
// - Parametric integers: int<W, S>, u8, u16, u32
// - Parametric floating-point: fp<F>, fp32, fp16
// - Fixed-point: fixed<W, F, S>
//
// Instead of manual bit[N] types, we use semantic types that express intent.

// Import SKALP standard library types
// (In a real implementation, these would be imported from skalp::numeric)
// use skalp::numeric::fp::{fp32, fp16};
// use skalp::numeric::vec::{vec2, vec3, vec4};
// use skalp::numeric::int::{u8, u16, u32, i32};
// use skalp::numeric::fixed::{fixed};

// ============================================================================
// Parametric Vector Type Aliases
// ============================================================================

/// 2D vector using 32-bit floating-point (for texture coordinates)
///
/// Benefits over manual struct:
/// - Type safety: Can't accidentally mix vec2 and vec3
/// - Generic algorithms: Works with any T: Numeric
/// - Stdlib operations: Built-in add, dot, normalize, etc.
pub type Vec2 = vec2<fp32>;

/// 3D vector using 32-bit floating-point (for positions, normals, colors)
///
/// Example usage:
///   let pos: Vec3 = Vec3 { x: 1.0, y: 2.0, z: 3.0 };
///   let len = pos.length();  // Built-in method
pub type Vec3 = vec3<fp32>;

/// 4D vector using 32-bit floating-point (for homogeneous coordinates)
///
/// Used for:
/// - Homogeneous positions after MVP transform
/// - Quaternions (w, x, y, z)
pub type Vec4 = vec4<fp32>;

// Alternative precisions for specific use cases:

/// Half-precision 3D vector (for bandwidth-critical applications)
pub type Vec3Half = vec3<fp16>;

/// Fixed-point 3D vector (for area-optimized implementations)
/// Q16.16 format: 16 integer bits, 16 fractional bits
pub type Vec3Fixed = vec3<fixed<32, 16, true>>;

// ============================================================================
// Parametric Matrix Type Aliases
// ============================================================================

/// 4x4 transformation matrix using 32-bit floating-point
///
/// Parametric type: [[fp32; 4]; 4]
/// - Array of 4 rows, each row is array of 4 fp32 values
/// - Can be used with generic matrix operations
/// - Type-safe: Can't accidentally use 3x3 matrix
pub type Matrix4x4 = [[fp32; 4]; 4];

/// 3x3 matrix for rotation/scale only (no translation)
pub type Matrix3x3 = [[fp32; 3]; 3];

/// Half-precision matrix (saves bandwidth and area)
pub type Matrix4x4Half = [[fp16; 4]; 4];

// ============================================================================
// Integer Type Aliases (Semantic Names)
// ============================================================================

/// Vertex index into vertex buffer
/// Using u32 instead of bit[32] expresses intent: unsigned integer
pub type VertexIndex = u32;

/// Triangle index
pub type TriangleIndex = u32;

/// Pixel coordinate (unsigned 16-bit)
pub type PixelCoord = u16;

/// Screen coordinate using fixed-point (Q8.8 format)
/// 8 integer bits, 8 fractional bits: range [-128, 127.996]
pub type ScreenCoord = fixed<16, 8, true>;

/// Z-buffer depth value (Q16.16 format for high precision)
pub type DepthValue = fixed<32, 16, false>;  // Unsigned: [0, 65535.9999]

// ============================================================================
// Color Types
// ============================================================================

/// RGBA color (8-bit per channel)
///
/// Note: Color channels are u8 (unsigned 8-bit integer)
/// Total size: 32 bits
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8
}

/// HDR color using floating-point (high dynamic range)
pub type ColorHDR = vec4<fp32>;  // RGBA with FP32

/// Half-precision color (bandwidth optimization)
pub type ColorHalf = vec4<fp16>;

// ============================================================================
// Vertex Data Structures
// ============================================================================

/// Input vertex attributes
///
/// Generic over numeric type T for flexibility:
/// - T = fp32: Standard precision
/// - T = fp16: Half precision for mobile/low-power
/// - T = fixed<W,F,S>: Fixed-point for ASIC
pub struct Vertex<T: Numeric> {
    pub position: vec3<T>,
    pub normal: vec3<T>,
    pub color: vec4<T>  // RGBA color in [0,1] range
}

// Convenient type aliases for common configurations:

/// Standard vertex with fp32
pub type VertexFP32 = Vertex<fp32>;

/// Half-precision vertex
pub type VertexFP16 = Vertex<fp16>;

/// Fixed-point vertex (Q16.16)
pub type VertexFixed = Vertex<fixed<32, 16, true>>;

/// Transformed vertex (after geometry processing)
///
/// Position is vec4 (homogeneous coordinates with w component)
/// Normal remains vec3 (direction vector)
pub struct TransformedVertex<T: Numeric> {
    pub position: vec4<T>,   // Homogeneous position (x, y, z, w)
    pub normal: vec3<T>,     // Surface normal
    pub color: vec4<T>,      // RGBA color
    pub tex_coord: vec2<T>   // Texture coordinates (optional)
}

pub type TransformedVertexFP32 = TransformedVertex<fp32>;

/// Screen-space vertex (after viewport transform)
///
/// Uses screen coordinates (pixels) and depth
pub struct ScreenVertex {
    pub x: ScreenCoord,      // Screen X in pixels (fixed-point)
    pub y: ScreenCoord,      // Screen Y in pixels
    pub depth: DepthValue,   // Z-buffer depth
    pub color: Color         // Final pixel color (8-bit)
}

// ============================================================================
// Command Types (for AXI register interface)
// ============================================================================

/// Command opcodes for graphics operations
///
/// Represents commands sent from CPU via AXI interface
pub enum CommandOpcode {
    Nop = 0,           // No operation
    DrawTriangle = 1,  // Draw single triangle
    SetTransform = 2,  // Update transformation matrix
    SetViewport = 3,   // Set viewport parameters
    ClearBuffer = 4,   // Clear framebuffer/z-buffer
    SetLighting = 5,   // Update lighting parameters
    Flush = 6          // Flush pipeline and sync
}

/// Graphics command with opcode and data
///
/// Command format:
/// - opcode: 4 bits (0-15)
/// - vertex_addr: 28 bits (256M vertex buffer)
pub struct Command {
    pub opcode: CommandOpcode,
    pub vertex_addr: u32  // Address in vertex buffer
}

// ============================================================================
// State Machine States
// ============================================================================

/// Geometry processor pipeline state
pub enum GeometryState {
    Idle,           // Waiting for command
    LoadVertex,     // Fetching vertex data
    Transform,      // Model-View-Projection transform
    Lighting,       // Lighting calculation (Phong)
    Viewport,       // Viewport transform
    WriteOutput     // Writing to output FIFO
}

/// Rasterizer pipeline state
pub enum RasterizerState {
    Idle,           // Waiting for triangles
    LoadTriangle,   // Loading 3 vertices
    ComputeEdges,   // Edge equation setup
    ScanLine,       // Scanline rasterization
    Interpolate,    // Attribute interpolation
    WritePixels     // Writing to framebuffer
}

// ============================================================================
// Configuration Structures
// ============================================================================

/// Viewport configuration
///
/// Defines screen region and depth range
pub struct ViewportConfig {
    pub x: u16,         // Top-left X
    pub y: u16,         // Top-left Y
    pub width: u16,     // Width in pixels
    pub height: u16,    // Height in pixels
    pub min_depth: DepthValue,  // Near plane
    pub max_depth: DepthValue   // Far plane
}

/// Lighting configuration
///
/// Simple Phong lighting model
pub struct LightingConfig<T: Numeric> {
    pub light_dir: vec3<T>,      // Directional light (normalized)
    pub light_color: vec3<T>,    // Light RGB intensity
    pub ambient: vec3<T>,        // Ambient light RGB
    pub specular_exp: T          // Specular exponent (shininess)
}

pub type LightingConfigFP32 = LightingConfig<fp32>;

// ============================================================================
// Utility Functions (Generic)
// ============================================================================

/// Create identity matrix
///
/// Generic over numeric type T
pub fn identity_matrix<T: Numeric>() -> [[T; 4]; 4] {
    return [
        [T::ONE, T::ZERO, T::ZERO, T::ZERO],
        [T::ZERO, T::ONE, T::ZERO, T::ZERO],
        [T::ZERO, T::ZERO, T::ONE, T::ZERO],
        [T::ZERO, T::ZERO, T::ZERO, T::ONE]
    ]
}

/// Create zero vector
pub fn zero_vec3<T: Numeric>() -> vec3<T> {
    return vec3 { x: T::ZERO, y: T::ZERO, z: T::ZERO }
}

/// Create zero vector (vec4)
pub fn zero_vec4<T: Numeric>() -> vec4<T> {
    return vec4 { x: T::ZERO, y: T::ZERO, z: T::ZERO, w: T::ZERO }
}

// ============================================================================
// Type Safety Examples
// ============================================================================

// BEFORE (raw bits - no type safety):
//   signal pos: bit[96];  // What is this? Vec3? Color? Matrix row?
//   pos = some_data;      // Could be wrong type, no checking!

// AFTER (parametric types - full type safety):
//   signal pos: Vec3;     // Clearly a 3D position
//   signal color: Color;  // Clearly a color
//   pos = color;          // ❌ Compile error: type mismatch!

// Generic functions work with any numeric type:
//   fn process<T: Numeric>(v: vec3<T>) -> vec3<T> { ... }
//
//   let v1: vec3<fp32> = ...;
//   let v2: vec3<fp16> = ...;
//   let v3: vec3<fixed<32,16,true>> = ...;
//
//   process(v1);  // ✅ Works with fp32
//   process(v2);  // ✅ Works with fp16
//   process(v3);  // ✅ Works with fixed-point

// ============================================================================
// Module Documentation
// ============================================================================

// This types.sk file demonstrates:
//
// 1. **Parametric Types**: Using vec<T,N>, [[T;R];C], int<W,S>, fp<F>
//    - Better than raw bit[N]: Semantic meaning, type safety, reusability
//
// 2. **Type Aliases**: Creating domain-specific names (Vec3, Matrix4x4)
//    - Makes code self-documenting
//    - Easy to change precision globally
//
// 3. **Generic Structs**: Vertex<T: Numeric> works with any numeric type
//    - Single definition, multiple instantiations
//    - Monomorphization creates specialized versions
//
// 4. **Fixed-Point**: ScreenCoord, DepthValue use fixed<W,F,S>
//    - Hardware-friendly alternative to floating-point
//    - Explicit precision control
//
// 5. **Numeric Trait**: T: Numeric enables generic algorithms
//    - identity_matrix<T>() works with fp32, fp16, fixed, etc.
//    - Reusable across different numeric types
