// Geometry Processor - Vertex Transformation Pipeline (Simplified)
//
// This is a simplified version that uses currently supported SKALP features.
// Uses basic types (bit[N]) instead of advanced parametric types.
//
// Future enhancements:
// - Generic numeric types (fp32, fp16, fixed-point)
// - Intent-driven architecture selection
// - Reusable numeric library functions

/// Simple 4-stage geometry processor
///
/// Fixed configuration for now:
/// - 4 pipeline stages
/// - 32-bit data paths
/// - Basic transformation pipeline
pub entity GeometryProcessor4 {
    // Clock and reset
    in clk: clock
    in rst: reset(active_high)

    // Input vertex stream (valid-ready handshake)
    in vertex_valid: bit
    in vertex: Vertex
    out vertex_ready: bit

    // Transformation matrices
    in model_matrix: Matrix4x4
    in view_matrix: Matrix4x4
    in proj_matrix: Matrix4x4

    // Lighting parameters (directional light model)
    in light_dir: Vec3       // Direction to light
    in light_color: Vec3     // Light RGB intensity
    in ambient: Vec3         // Ambient RGB intensity

    // Output transformed vertex stream
    out output_valid: bit
    out output: TransformedVertex
    in output_ready: bit

    // Status
    out busy: bit
    out vertices_processed: bit[32]
}

impl GeometryProcessor4 {
    // State tracking
    signal state: bit[3]  // Simple state encoding
    signal vertex_count: bit[32]

    // Pipeline stages
    signal stage0_valid: bit
    signal stage1_valid: bit
    signal stage2_valid: bit
    signal stage3_valid: bit

    // Intermediate data (simplified - just pass through for now)
    signal in_position: Vec3
    signal in_normal: Vec3
    signal in_color: Vec4

    signal world_position: Vec4
    signal world_normal: Vec3

    signal view_position: Vec4
    signal view_normal: Vec3

    signal clip_position: Vec4
    signal lit_color: Vec4

    // State machine (simplified)
    // 0 = Idle, 1 = Load, 2 = Process, 3 = Output
    on(clk.rise) {
        if rst {
            state <= 0
            vertex_count <= 0
            stage0_valid <= 0
            stage1_valid <= 0
            stage2_valid <= 0
            stage3_valid <= 0
        } else {
            if state == 0 {
                // Idle - wait for input
                if vertex_valid && vertex_ready {
                    in_position <= vertex.position
                    in_normal <= vertex.normal
                    in_color <= vertex.color
                    stage0_valid <= 1
                    state <= 1
                    vertex_count <= vertex_count + 1
                }
            } else if state == 1 {
                // Process stage 0
                // Simple passthrough for now (real transform would go here)
                world_position <= Vec4 {
                    x: in_position.x,
                    y: in_position.y,
                    z: in_position.z,
                    w: 0x3F800000  // 1.0 in fp32
                }
                world_normal <= in_normal
                stage1_valid <= 1
                state <= 2
            } else if state == 2 {
                // Process stage 1
                view_position <= world_position
                view_normal <= world_normal
                stage2_valid <= 1
                state <= 3
            } else if state == 3 {
                // Process stage 2
                clip_position <= view_position
                lit_color <= in_color
                stage3_valid <= 1
                state <= 4
            } else if state == 4 {
                // Output stage
                if output_ready {
                    stage3_valid <= 0
                    state <= 0
                }
            }
        }
    }

    // Output assignments
    output_valid = stage3_valid
    vertex_ready = (state == 0)
    busy = (state != 0)
    vertices_processed = vertex_count

    // Output vertex
    output = TransformedVertex {
        position: clip_position,
        normal: view_normal,
        color: lit_color,
        tex_coord: Vec2 { x: 0, y: 0 }
    }
}

// ============================================================================
// Documentation
// ============================================================================

// This simplified geometry processor demonstrates:
//
// 1. **Multi-stage Pipeline**: 4 stages for vertex processing
//    - Stage 0: Load vertex data
//    - Stage 1: Model transform (passthrough for now)
//    - Stage 2: View transform (passthrough for now)
//    - Stage 3: Projection and lighting (passthrough for now)
//
// 2. **Valid-Ready Handshake**: Backpressure support
//    - vertex_valid/vertex_ready for input
//    - output_valid/output_ready for output
//    - Prevents data loss and overflow
//
// 3. **State Machine**: Simple FSM for control
//    - Idle, Load, Process, Output states
//    - Tracks progress through pipeline
//
// ## Future Enhancements
//
// When advanced features are available, this will become:
//
// ```skalp
// entity GeometryProcessor<T: Numeric, const STAGES: nat, const INTENT: OptimizationIntent> {
//     // Generic over numeric type and configuration
// }
//
// impl GeometryProcessor<T, STAGES, INTENT> {
//     // Matrix multiply using library functions
//     world_pos <= matrix_vector_multiply(model_matrix, position);
//
//     // Lighting using generic functions
//     diffuse <= compute_diffuse_lighting(normal, light_dir);
// }
// ```
//
// This will enable:
// - Different numeric precisions (fp32, fp16, fixed-point)
// - Configurable pipeline depth
// - Intent-driven architecture (optimize for speed vs area)
// - Reusable library functions for math operations
