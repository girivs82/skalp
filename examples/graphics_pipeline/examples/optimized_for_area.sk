// Example: Area-Optimized Graphics Pipeline
//
// This configuration prioritizes minimal resource usage:
// - Lower clock frequencies (50-75 MHz)
// - Minimal pipelining
// - Resource sharing and sequential processing
// - Small FIFOs
// - Lower throughput acceptable
//
// Use case:
// - Low-end/mid-range FPGA (iCE40, Artix-7)
// - Embedded graphics applications
// - Cost-sensitive designs
// - Battery-powered devices
// - When silicon area is critical

use crate::types::*;
use crate::src::geometry::processor::{GeometryProcessorSmall, OptimizationIntent};
use crate::lib::fifo::async_fifo::AsyncFifo;

// ============================================================================
// Configuration Parameters
// ============================================================================

/// Area-efficient configuration
const GEOM_PIPELINE_STAGES: nat = 2;     // Minimal pipelining: 2 stages
const RAST_PIPELINE_STAGES: nat = 1;     // Rasterizer mostly sequential
const FIFO_DEPTH: nat = 8;               // Shallow FIFOs (save block RAM)
const NUMERIC_TYPE: type = fp16;         // Half-precision (smaller multipliers)

/// Clock frequencies (in MHz)
const GEOM_CLK_FREQ: nat = 50;           // 50 MHz geometry processor
const RAST_CLK_FREQ: nat = 50;           // 50 MHz rasterizer (same clock)
const VIDEO_CLK_FREQ: nat = 25;          // 25 MHz for 640x480@60Hz VGA

/// Resolution
const SCREEN_WIDTH: nat = 640;           // VGA width
const SCREEN_HEIGHT: nat = 480;          // VGA height

// ============================================================================
// Top-Level Entity
// ============================================================================

/// Low-resource graphics pipeline
///
/// Target: Lattice iCE40-HX4K or Xilinx Artix-7 XC7A35T
///
/// Resource estimates:
/// - Logic cells: ~3,000-5,000
/// - DSP blocks: ~8-16
/// - Block RAM: ~20-30 blocks
/// - Power: ~0.5-1W @ 50 MHz
///
/// Performance:
/// - Vertex throughput: ~1-2M vertices/sec
/// - Pixel throughput: ~10-20M pixels/sec
/// - Frame rate: 30-60 fps @ 640x480
entity SmallGraphicsPipeline {
    // ========================================================================
    // Clock and Reset
    // ========================================================================

    input clk: clock,                  // Single 50 MHz clock (no PLL)
    input rst: reset(active_high),

    // ========================================================================
    // Simple Control Interface (not AXI - too complex for small design)
    // ========================================================================

    // Vertex input stream
    input vertex_valid: bit,
    output vertex_ready: bit,
    input vertex_position_x: fp16,
    input vertex_position_y: fp16,
    input vertex_position_z: fp16,
    input vertex_normal_x: fp16,
    input vertex_normal_y: fp16,
    input vertex_normal_z: fp16,
    input vertex_color: u32,  // RGBA packed

    // Configuration (simple registers, not full AXI)
    input matrix_update: bit,
    input matrix_data: fp16,
    input matrix_addr: u8,

    // ========================================================================
    // Video Output (VGA 640x480)
    // ========================================================================

    output video_hsync: bit,
    output video_vsync: bit,
    output video_r: bit[4],   // 4-bit color (16 levels)
    output video_g: bit[4],
    output video_b: bit[4],

    // ========================================================================
    // Status
    // ========================================================================

    output busy: bit,
    output error: bit
}

impl SmallGraphicsPipeline {
    // ========================================================================
    // Clock Generation
    // ========================================================================

    // Use single clock domain to avoid CDC complexity
    signal video_clk: clock;

    // Generate 25 MHz video clock from 50 MHz input
    // Simple divide-by-2 (no PLL needed)
    signal clk_div: bit;

    on(clk.rise) {
        clk_div <= !clk_div
    }

    assign video_clk = clk_div;  // 25 MHz video clock

    // ========================================================================
    // Geometry Processor (Area-Optimized)
    // ========================================================================

    // Use fp16 for half-precision (saves ~50% multiplier area)
    // Use 2 pipeline stages (minimal)
    // Use OptimizeArea intent for resource sharing
    let geometry_proc = GeometryProcessor<fp16, 2, OptimizeArea> {
        clk: clk,
        rst: rst,

        // Input vertex stream (simplified format)
        vertex_valid: vertex_valid,
        vertex: vertex_in,
        vertex_ready: vertex_ready,

        // Transformation matrices (stored in small register file)
        model_matrix: model_matrix_reg,
        view_matrix: view_matrix_reg,
        proj_matrix: proj_matrix_reg,

        // Simple lighting (single directional light)
        light_dir: light_dir_reg,
        light_color: light_color_white,  // Fixed white light
        ambient_color: ambient_color_gray,  // Fixed 20% ambient
        specular_exp: specular_exp_zero,  // No specular (save resources)

        // Output to rasterizer
        output_valid: geom_out_valid,
        output_vertex: geom_out_vertex,
        output_ready: geom_out_ready
    };

    // Pack input vertex from individual signals
    assign vertex_in = Vertex<fp16> {
        position: vec3<fp16> {
            x: vertex_position_x,
            y: vertex_position_y,
            z: vertex_position_z
        },
        normal: vec3<fp16> {
            x: vertex_normal_x,
            y: vertex_normal_y,
            z: vertex_normal_z
        },
        color: unpack_rgba(vertex_color)  // Convert u32 to vec4<fp16>
    };

    // Fixed lighting parameters (save configuration registers)
    assign light_dir_reg = vec3<fp16> {
        x: fp16::from_const(0.577),   // Normalized (1,1,1)
        y: fp16::from_const(0.577),
        z: fp16::from_const(0.577)
    };
    assign light_color_white = vec3<fp16> {
        x: fp16::ONE,
        y: fp16::ONE,
        z: fp16::ONE
    };
    assign ambient_color_gray = vec3<fp16> {
        x: fp16::from_const(0.2),
        y: fp16::from_const(0.2),
        z: fp16::from_const(0.2)
    };
    assign specular_exp_zero = fp16::ZERO;

    // ========================================================================
    // Small FIFO (Synchronous - Same Clock Domain)
    // ========================================================================

    // Use synchronous FIFO (simpler than async)
    // Depth = 8 (very small, minimal BRAM usage)
    let geom_to_rast_fifo = SyncFifo<TransformedVertex<fp16>, 8> {
        clk: clk,
        rst: rst,

        wr_en: geom_out_valid && !fifo_full,
        wr_data: geom_out_vertex,
        wr_full: fifo_full,

        rd_en: rast_in_ready && !fifo_empty,
        rd_data: rast_in_vertex,
        rd_empty: fifo_empty,
        rd_valid: rast_in_valid
    };

    assign geom_out_ready = !fifo_full;

    // ========================================================================
    // Rasterizer (Area-Optimized)
    // ========================================================================

    // Single-stage rasterizer (mostly sequential)
    // Process one pixel at a time (no parallelism)
    // Simple scanline algorithm (no fancy optimizations)
    let rasterizer = RasterizerSmall<fp16, 1> {
        clk: clk,
        rst: rst,

        // Input from FIFO
        vertex_valid: rast_in_valid,
        vertex: rast_in_vertex,
        vertex_ready: rast_in_ready,

        // Output pixels
        pixel_valid: pixel_out_valid,
        pixel_x: pixel_out_x,
        pixel_y: pixel_out_y,
        pixel_color: pixel_out_color,
        pixel_ready: 1'b1  // Always ready (no back-pressure)
    };

    // ========================================================================
    // Frame Buffer (Small - Single Buffered)
    // ========================================================================

    // Use small frame buffer: 640x480 @ 12-bit color = ~4.5 Mbit
    // Single-buffered (not double-buffered to save memory)
    // Store in block RAM
    let frame_buffer = FrameBuffer<SCREEN_WIDTH, SCREEN_HEIGHT, 12> {
        clk: clk,
        rst: rst,

        // Write port (from rasterizer)
        wr_en: pixel_out_valid,
        wr_x: pixel_out_x,
        wr_y: pixel_out_y,
        wr_color: pixel_out_color,

        // Read port (for video output)
        rd_x: video_x,
        rd_y: video_y,
        rd_color: video_color
    };

    // ========================================================================
    // Video Output Controller (VGA 640x480@60Hz)
    // ========================================================================

    let video_ctrl = VGAController<SCREEN_WIDTH, SCREEN_HEIGHT> {
        clk: video_clk,  // 25 MHz pixel clock
        rst: rst,

        // Sync outputs
        hsync: video_hsync,
        vsync: video_vsync,

        // Current pixel position
        x: video_x,
        y: video_y,
        active: video_active
    };

    // Extract RGB from frame buffer (12-bit to 4+4+4)
    assign video_r = if video_active { video_color[11:8] } else { 4'b0000 };
    assign video_g = if video_active { video_color[7:4] } else { 4'b0000 };
    assign video_b = if video_active { video_color[3:0] } else { 4'b0000 };

    // ========================================================================
    // Matrix Configuration Interface
    // ========================================================================

    // Simple serial loading of matrix elements
    // Much simpler than full AXI interface
    signal matrix_reg_file: [[fp16; 4]; 4];
    signal current_matrix: u8;  // 0=model, 1=view, 2=proj

    on(clk.rise) {
        if rst {
            // Initialize to identity matrices
            for i in 0..4 {
                for j in 0..4 {
                    matrix_reg_file[i][j] = if i == j {
                        fp16::ONE
                    } else {
                        fp16::ZERO
                    }
                }
            }
            current_matrix = 0u8
        } else if matrix_update {
            // Load matrix element
            let row = matrix_addr[5:4];
            let col = matrix_addr[3:2];
            matrix_reg_file[row][col] = matrix_data;

            // Cycle through matrices
            if matrix_addr == 8'd15 {
                current_matrix = current_matrix + 1u8
            }
        }
    }

    // Route matrices to geometry processor
    assign model_matrix_reg = if current_matrix == 0u8 { matrix_reg_file } else { model_matrix_reg };
    assign view_matrix_reg = if current_matrix == 1u8 { matrix_reg_file } else { view_matrix_reg };
    assign proj_matrix_reg = if current_matrix == 2u8 { matrix_reg_file } else { proj_matrix_reg };

    // ========================================================================
    // Status Outputs
    // ========================================================================

    assign busy = geom_out_valid || pixel_out_valid;
    assign error = fifo_full && geom_out_valid;  // Overflow error
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Unpack 32-bit RGBA to vec4<fp16>
fn unpack_rgba(rgba: u32) -> vec4<fp16> {
    return vec4<fp16> {
        x: fp16::from_u8(rgba[31:24]),  // R
        y: fp16::from_u8(rgba[23:16]),  // G
        z: fp16::from_u8(rgba[15:8]),   // B
        w: fp16::from_u8(rgba[7:0])     // A
    }
}

// ============================================================================
// Performance Characteristics
// ============================================================================

// Maximum performance:
// - Geometry: 50 MHz / ~32 cycles/vertex = ~1.5M vertices/sec
// - Rasterizer: 50 MHz / 2 cycles/pixel = ~25M pixels/sec
// - Frame rate at 640x480: 25M / (640*480) â‰ˆ 80 fps (max)
//
// Typical performance (realistic scenes):
// - 500K-1M vertices/sec
// - 10M pixels/sec (fill rate)
// - 30-60 fps @ 640x480
//
// Resource usage (iCE40-HX4K or Artix-7 XC7A35T):
// - Logic cells: ~4,000 / 4K-30K (13-100%)
// - Multipliers: ~12 / 20-90 (13-60%)
// - Block RAM: ~25 / 20-50 (50-125%)
// - Power: ~0.5W typical
//
// Size comparison vs. speed-optimized:
// - Logic: ~10% (10x smaller)
// - DSP: ~6% (17x fewer multipliers)
// - RAM: ~17% (6x less memory)
// - Power: ~8% (12x lower power)
//
// Trade-offs:
// - 40x lower vertex throughput
// - 24x lower pixel throughput
// - Lower precision (fp16 vs fp32)
// - Smaller resolution (640x480 vs 1920x1080)
// - Simpler features (no specular, single buffer)

// ============================================================================
// Usage Notes
// ============================================================================

// Building:
//   skalp build examples/optimized_for_area.sk -o build/small_pipeline.sv
//
// Synthesis (Lattice iCE40):
//   yosys -p "synth_ice40 -top SmallGraphicsPipeline -json small.json" small_pipeline.sv
//   nextpnr-ice40 --hx4k --json small.json --asc small.asc
//   icepack small.asc small.bin
//
// Synthesis (Xilinx Artix-7):
//   vivado -mode batch -source scripts/synth_small.tcl
//
// Expected results:
//   - Fits in iCE40-HX4K with ~60-80% utilization
//   - Fits in Artix-7 XC7A35T with ~15-20% utilization
//   - Max frequency: 60-80 MHz (50 MHz target easily met)
//   - Power: <1W on iCE40, ~0.5W on Artix-7
//
// Tuning:
//   - Reduce resolution further if BRAM constrained (320x240)
//   - Use fixed-point instead of fp16 to eliminate multipliers
//   - Share more resources if logic constrained
//   - Use simpler rasterization algorithm (wireframe only)
//
// Use cases:
//   - Embedded HMI (Human-Machine Interface)
//   - Simple 3D visualization
//   - Game console on FPGA
//   - Educational graphics processor
//   - IoT devices with display
