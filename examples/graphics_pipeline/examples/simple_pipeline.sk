// Example: Simple Graphics Pipeline
//
// This configuration prioritizes simplicity and understandability:
// - Straightforward architecture
// - Moderate performance
// - Clear data flow
// - Well-commented
// - Good starting point for learning
//
// Use case:
// - Learning and education
// - Prototyping
// - Reference implementation
// - Understanding graphics pipeline concepts
// - Base for customization

use crate::types::*;
use crate::src::geometry::processor::GeometryProcessor;
use crate::lib::fifo::async_fifo::AsyncFifo;
use crate::lib::numeric::vector::{vec_dot, vec_normalize};
use crate::lib::numeric::matrix::matrix_vector_multiply;

// ============================================================================
// Configuration Parameters
// ============================================================================

/// Balanced configuration
const PIPELINE_DEPTH: nat = 3;           // 3-stage pipeline (reasonable)
const FIFO_DEPTH: nat = 16;              // 16-entry FIFOs (moderate buffering)

/// Clock frequency: 100 MHz (easy to achieve on most FPGAs)
const CLK_FREQ: nat = 100;

/// Resolution: 800x600 @ 60Hz (SVGA - common standard)
const SCREEN_WIDTH: nat = 800;
const SCREEN_HEIGHT: nat = 600;

/// Use fp32 for precision (fp16 for area-constrained designs)
const FLOAT_TYPE: type = fp32;

// ============================================================================
// Top-Level Entity: Simple Graphics Pipeline
// ============================================================================

/// Educational graphics pipeline
///
/// This design demonstrates:
/// 1. Vertex transformation (Model-View-Projection)
/// 2. Lighting calculation (Phong model)
/// 3. Rasterization (triangle to pixels)
/// 4. Frame buffer and video output
///
/// Target: Any mid-range FPGA with ~10K logic cells, 50 DSPs, 50 BRAMs
entity SimpleGraphicsPipeline {
    // ========================================================================
    // Clocks and Reset
    // ========================================================================

    input clk: clock,                  // 100 MHz system clock
    input rst: reset(active_high),     // Synchronous reset

    // ========================================================================
    // Vertex Input Interface
    // ========================================================================

    // Simple ready-valid handshake protocol
    input vertex_valid: bit,           // Input vertex available
    output vertex_ready: bit,          // Ready to accept vertex
    input vertex_data: Vertex<fp32>,   // Input vertex data

    // ========================================================================
    // Configuration Inputs
    // ========================================================================

    // Transformation matrices (updated infrequently)
    input model_matrix: [[fp32; 4]; 4],   // Object → World space
    input view_matrix: [[fp32; 4]; 4],    // World → Camera space
    input proj_matrix: [[fp32; 4]; 4],    // Camera → Clip space

    // Lighting parameters
    input light_direction: vec3<fp32>,    // Direction to light (normalized)
    input light_color: vec3<fp32>,        // Light RGB intensity [0,1]
    input ambient_color: vec3<fp32>,      // Ambient RGB intensity [0,1]

    // ========================================================================
    // Video Output
    // ========================================================================

    output video_hsync: bit,              // Horizontal sync
    output video_vsync: bit,              // Vertical sync
    output video_de: bit,                 // Data enable (visible area)
    output video_r: u8,                   // Red channel [0,255]
    output video_g: u8,                   // Green channel [0,255]
    output video_b: u8,                   // Blue channel [0,255]

    // ========================================================================
    // Status Outputs
    // ========================================================================

    output busy: bit,                     // Pipeline processing
    output frame_number: u32              // Current frame count
}

impl SimpleGraphicsPipeline {
    // ========================================================================
    // STEP 1: Geometry Processing
    // ========================================================================

    /// The geometry processor transforms vertices from object space to
    /// clip space and performs lighting calculations.

    let geometry_processor = GeometryProcessor<fp32, 3, OptimizeBalanced> {
        clk: clk,
        rst: rst,

        // Input: Vertices in object space
        vertex_valid: vertex_valid,
        vertex: vertex_data,
        vertex_ready: vertex_ready,

        // Configuration: Transformation matrices
        model_matrix: model_matrix,
        view_matrix: view_matrix,
        proj_matrix: proj_matrix,

        // Configuration: Lighting
        light_dir: light_direction,
        light_color: light_color,
        ambient_color: ambient_color,
        specular_exp: fp32::from_const(16.0),  // Moderate shininess

        // Output: Transformed and lit vertices
        output_valid: geom_output_valid,
        output_vertex: geom_output_vertex,
        output_ready: geom_output_ready
    };

    // ========================================================================
    // STEP 2: Buffering (FIFO)
    // ========================================================================

    /// The FIFO buffers vertices between geometry and rasterization stages.
    /// This allows the two stages to operate independently and absorbs
    /// temporary throughput mismatches.

    let vertex_fifo = AsyncFifo<TransformedVertex<fp32>, FIFO_DEPTH> {
        // Write side (geometry processor)
        wr_clk: clk,
        wr_rst: rst,
        wr_data: geom_output_vertex,
        wr_en: geom_output_valid && !fifo_full,
        wr_full: fifo_full,

        // Read side (rasterizer)
        rd_clk: clk,  // Same clock in this simple design
        rd_rst: rst,
        rd_en: rast_input_ready && !fifo_empty,
        rd_data: rast_input_vertex,
        rd_empty: fifo_empty,
        rd_valid: rast_input_valid
    };

    // Connect ready signals
    assign geom_output_ready = !fifo_full;

    // ========================================================================
    // STEP 3: Rasterization
    // ========================================================================

    /// The rasterizer converts triangles (3 vertices) into pixels.
    /// It performs:
    /// 1. Triangle setup (compute edge equations)
    /// 2. Scanline traversal (find pixels inside triangle)
    /// 3. Attribute interpolation (smooth shading)

    let rasterizer = SimpleRasterizer<fp32> {
        clk: clk,
        rst: rst,

        // Input: Transformed vertices from FIFO
        vertex_valid: rast_input_valid,
        vertex: rast_input_vertex,
        vertex_ready: rast_input_ready,

        // Output: Pixels with color and position
        pixel_valid: pixel_output_valid,
        pixel_x: pixel_x,
        pixel_y: pixel_y,
        pixel_color: pixel_color,
        pixel_ready: pixel_output_ready
    };

    // ========================================================================
    // STEP 4: Frame Buffer
    // ========================================================================

    /// The frame buffer stores the rendered image.
    /// - Write pixels as they are generated by the rasterizer
    /// - Read pixels synchronously for video output

    let frame_buffer = SimpleFrameBuffer<SCREEN_WIDTH, SCREEN_HEIGHT> {
        clk: clk,
        rst: rst,

        // Write port (from rasterizer)
        wr_enable: pixel_output_valid,
        wr_x: pixel_x,
        wr_y: pixel_y,
        wr_color: pixel_color,

        // Read port (for video output)
        rd_x: video_read_x,
        rd_y: video_read_y,
        rd_color: video_read_color
    };

    assign pixel_output_ready = 1'b1;  // Always ready (frame buffer can accept)

    // ========================================================================
    // STEP 5: Video Timing Generator
    // ========================================================================

    /// Generates video timing signals for SVGA 800x600 @ 60Hz
    ///
    /// Timing parameters (from VESA standard):
    /// - Pixel clock: 40 MHz
    /// - Total horizontal: 1056 pixels
    /// - Total vertical: 628 lines
    /// - Visible area: 800x600

    let video_timing = VideoTimingGenerator<SCREEN_WIDTH, SCREEN_HEIGHT> {
        clk: video_clk,  // 40 MHz pixel clock
        rst: rst,

        // Timing outputs
        hsync: video_hsync,
        vsync: video_vsync,
        de: video_de,

        // Current position
        x: video_read_x,
        y: video_read_y,

        // Frame pulse
        frame: frame_pulse
    };

    // ========================================================================
    // Clock Generation
    // ========================================================================

    // Generate 40 MHz video clock from 100 MHz system clock
    // Using PLL: multiply by 2, divide by 5
    let clock_gen = SimplePLL {
        clk_in: clk,
        rst: rst,

        clk_out: video_clk,
        multiply: 2,
        divide: 5
    };

    // ========================================================================
    // Video Output Multiplexer
    // ========================================================================

    // During visible area, output pixel from frame buffer
    // During blanking, output black
    assign video_r = if video_de { color_to_8bit(video_read_color.x) } else { 8'h00 };
    assign video_g = if video_de { color_to_8bit(video_read_color.y) } else { 8'h00 };
    assign video_b = if video_de { color_to_8bit(video_read_color.z) } else { 8'h00 };

    // ========================================================================
    // Status and Monitoring
    // ========================================================================

    // Busy when any stage is actively processing
    assign busy = geom_output_valid || pixel_output_valid;

    // Frame counter
    signal frame_counter: u32;

    on(video_clk.rise) {
        if rst {
            frame_counter <= 0u32
        } else if frame_pulse {
            frame_counter <= frame_counter + 1u32
        }
    }

    assign frame_number = frame_counter;
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Convert floating-point color [0.0, 1.0] to 8-bit integer [0, 255]
fn color_to_8bit(value: fp32) -> u8 {
    // Clamp to [0, 1] range
    let clamped = if value.lt(fp32::ZERO) {
        fp32::ZERO
    } else if value.gt(fp32::ONE) {
        fp32::ONE
    } else {
        value
    };

    // Scale to [0, 255]
    let scaled = clamped.mul(fp32::from_const(255.0));

    // Convert to integer
    return u8::from_fp32(scaled)
}

// ============================================================================
// Supporting Entities
// ============================================================================

/// Simple rasterizer: Converts triangles to pixels
entity SimpleRasterizer<T: Numeric> {
    input clk: clock,
    input rst: reset(active_high),

    // Vertex input (3 vertices form a triangle)
    input vertex_valid: bit,
    input vertex: TransformedVertex<T>,
    output vertex_ready: bit,

    // Pixel output
    output pixel_valid: bit,
    output pixel_x: u16,
    output pixel_y: u16,
    output pixel_color: vec4<T>,
    input pixel_ready: bit
}

impl SimpleRasterizer<T: Numeric> {
    // Simplified rasterizer implementation
    // In a real design, this would include:
    // - Triangle assembly (collect 3 vertices)
    // - Edge equation computation
    // - Bounding box calculation
    // - Scanline traversal
    // - Barycentric coordinate interpolation
    //
    // For this example, assume the logic is implemented
}

/// Simple frame buffer: Stores rendered image
entity SimpleFrameBuffer<const WIDTH: nat, const HEIGHT: nat> {
    input clk: clock,
    input rst: reset(active_high),

    // Write port
    input wr_enable: bit,
    input wr_x: u16,
    input wr_y: u16,
    input wr_color: vec4<fp32>,

    // Read port
    input rd_x: u16,
    input rd_y: u16,
    output rd_color: vec4<fp32>
}

impl SimpleFrameBuffer<const WIDTH: nat, const HEIGHT: nat> {
    // Frame buffer memory: WIDTH * HEIGHT pixels
    // Each pixel: 32-bit RGBA (or use 16-bit for half memory)
    signal memory: [[vec4<fp32>; WIDTH]; HEIGHT];

    // Write logic
    on(clk.rise) {
        if wr_enable && (wr_x < WIDTH) && (wr_y < HEIGHT) {
            memory[wr_y][wr_x] <= wr_color
        }
    }

    // Read logic (combinatorial)
    assign rd_color = if (rd_x < WIDTH) && (rd_y < HEIGHT) {
        memory[rd_y][rd_x]
    } else {
        vec4<fp32>::ZERO  // Black outside visible area
    }
}

/// Video timing generator for SVGA 800x600 @ 60Hz
entity VideoTimingGenerator<const WIDTH: nat, const HEIGHT: nat> {
    input clk: clock,    // 40 MHz pixel clock
    input rst: reset(active_high),

    output hsync: bit,
    output vsync: bit,
    output de: bit,      // Data enable (visible area)

    output x: u16,       // Current X position
    output y: u16,       // Current Y position

    output frame: bit    // Pulse at start of frame
}

impl VideoTimingGenerator<const WIDTH: nat, const HEIGHT: nat> {
    // SVGA 800x600 @ 60Hz timing (VESA standard)
    const H_VISIBLE: nat = 800;
    const H_FRONT_PORCH: nat = 40;
    const H_SYNC_PULSE: nat = 128;
    const H_BACK_PORCH: nat = 88;
    const H_TOTAL: nat = 1056;

    const V_VISIBLE: nat = 600;
    const V_FRONT_PORCH: nat = 1;
    const V_SYNC_PULSE: nat = 4;
    const V_BACK_PORCH: nat = 23;
    const V_TOTAL: nat = 628;

    signal h_count: u16;
    signal v_count: u16;

    // Horizontal counter
    on(clk.rise) {
        if rst {
            h_count <= 0u16
        } else if h_count == (H_TOTAL - 1) {
            h_count <= 0u16
        } else {
            h_count <= h_count + 1u16
        }
    }

    // Vertical counter
    on(clk.rise) {
        if rst {
            v_count <= 0u16
        } else if h_count == (H_TOTAL - 1) {
            if v_count == (V_TOTAL - 1) {
                v_count <= 0u16
            } else {
                v_count <= v_count + 1u16
            }
        }
    }

    // Generate sync signals
    assign hsync = !(h_count >= (H_VISIBLE + H_FRONT_PORCH) &&
                     h_count < (H_VISIBLE + H_FRONT_PORCH + H_SYNC_PULSE));

    assign vsync = !(v_count >= (V_VISIBLE + V_FRONT_PORCH) &&
                     v_count < (V_VISIBLE + V_FRONT_PORCH + V_SYNC_PULSE));

    // Data enable: active during visible area
    assign de = (h_count < H_VISIBLE) && (v_count < V_VISIBLE);

    // Position outputs
    assign x = h_count;
    assign y = v_count;

    // Frame pulse: at start of each frame
    assign frame = (h_count == 0) && (v_count == 0);
}

// ============================================================================
// Usage Example
// ============================================================================

// To instantiate and use this pipeline:
//
// 1. Connect clocks and reset
// 2. Load transformation matrices (CPU/software)
// 3. Stream vertices to vertex_data port
// 4. Connect video outputs to DAC or HDMI transmitter
// 5. Monitor busy and frame_number for status
//
// Example vertex format:
//   let vertex = Vertex<fp32> {
//       position: vec3<fp32> { x: 1.0, y: 2.0, z: 3.0 },
//       normal: vec3<fp32> { x: 0.0, y: 0.0, z: 1.0 },
//       color: vec4<fp32> { x: 1.0, y: 0.0, z: 0.0, w: 1.0 }
//   };
//
// Example transformation matrices (identity):
//   let identity = [
//       [1.0, 0.0, 0.0, 0.0],
//       [0.0, 1.0, 0.0, 0.0],
//       [0.0, 0.0, 1.0, 0.0],
//       [0.0, 0.0, 0.0, 1.0]
//   ];

// ============================================================================
// Performance Characteristics
// ============================================================================

// Expected performance:
// - Geometry: ~30M vertices/sec (100 MHz / 3 cycles)
// - Rasterizer: ~50M pixels/sec
// - Frame rate: ~100 fps @ 800x600 (max)
//
// Resource usage (typical mid-range FPGA):
// - Logic cells: ~8,000-12,000
// - DSP blocks: ~30-50
// - Block RAM: ~40-60
// - Power: ~1-2W @ 100 MHz
//
// This design strikes a balance between:
// - Performance (better than area-optimized)
// - Resource usage (less than speed-optimized)
// - Simplicity (easier to understand)
// - Flexibility (good base for customization)

// ============================================================================
// Learning Path
// ============================================================================

// Suggested order for understanding this pipeline:
//
// 1. Study video timing generator (simplest module)
// 2. Understand frame buffer (memory organization)
// 3. Learn geometry processor (transformations and lighting)
// 4. Explore rasterizer (triangle-to-pixel conversion)
// 5. Understand FIFO buffering (clock domain crossing)
// 6. Integrate everything (top-level connections)
//
// For more information:
// - See docs/ARCHITECTURE.md for system overview
// - See lib/numeric/ for math operations
// - See verif/ for testbenches and verification
