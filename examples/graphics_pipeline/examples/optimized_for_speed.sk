// Example: Speed-Optimized Graphics Pipeline
//
// This configuration prioritizes performance:
// - High clock frequencies (200 MHz geometry, 150 MHz raster)
// - Fully pipelined architecture
// - Parallel processing
// - Maximum throughput
// - Higher resource usage acceptable
//
// Use case:
// - High-end FPGA (Xilinx Kintex-7, Virtex-7)
// - Real-time 3D rendering at high frame rates
// - Desktop/workstation applications
// - When area is not constrained

use crate::types::*;
use crate::src::geometry::processor::{GeometryProcessorFast, OptimizationIntent};
use crate::lib::fifo::async_fifo::AsyncFifo;

// ============================================================================
// Configuration Parameters
// ============================================================================

/// Fast configuration
const GEOM_PIPELINE_STAGES: nat = 5;     // Fully pipelined: 5 stages
const RAST_PIPELINE_STAGES: nat = 4;     // Rasterizer also fully pipelined
const FIFO_DEPTH: nat = 64;              // Deep FIFOs for buffering
const NUMERIC_TYPE: type = fp32;         // Full precision floating-point

/// Clock frequencies (in MHz)
const GEOM_CLK_FREQ: nat = 200;          // 200 MHz geometry processor
const RAST_CLK_FREQ: nat = 150;          // 150 MHz rasterizer
const VIDEO_CLK_FREQ: nat = 148;         // 148.5 MHz for 1080p

/// Resolution
const SCREEN_WIDTH: nat = 1920;          // 1080p width
const SCREEN_HEIGHT: nat = 1080;         // 1080p height

// ============================================================================
// Top-Level Entity
// ============================================================================

/// High-performance graphics pipeline
///
/// Target: Xilinx Kintex-7 XC7K325T or higher
///
/// Resource estimates:
/// - Logic cells: ~50,000 (15% of XC7K325T)
/// - DSP48E1: ~200 (50% of 840 available)
/// - Block RAM: ~150 (30% of 445 available)
/// - Power: ~5-8W @ 200 MHz
///
/// Performance:
/// - Vertex throughput: 200M vertices/sec (max)
/// - Pixel throughput: 600M pixels/sec (max)
/// - Frame rate: 60 fps @ 1080p (typical load)
entity FastGraphicsPipeline {
    // ========================================================================
    // Clock and Reset
    // ========================================================================

    input clk_sys: clock,              // 100 MHz system clock (for PLL)
    input rst: reset(active_high),

    // ========================================================================
    // AXI4-Lite Control Interface
    // ========================================================================

    // Write address channel
    input axi_awvalid: bit,
    output axi_awready: bit,
    input axi_awaddr: u32,

    // Write data channel
    input axi_wvalid: bit,
    output axi_wready: bit,
    input axi_wdata: u32,

    // Write response channel
    output axi_bvalid: bit,
    input axi_bready: bit,
    output axi_bresp: bit[2],

    // Read address channel
    input axi_arvalid: bit,
    output axi_arready: bit,
    input axi_araddr: u32,

    // Read data channel
    output axi_rvalid: bit,
    input axi_rready: bit,
    output axi_rdata: u32,
    output axi_rresp: bit[2],

    // ========================================================================
    // Video Output (1080p60)
    // ========================================================================

    output video_hsync: bit,
    output video_vsync: bit,
    output video_de: bit,
    output video_r: u8,
    output video_g: u8,
    output video_b: u8,

    // ========================================================================
    // Status
    // ========================================================================

    output busy: bit,
    output frame_count: u32,
    output vertex_count: u32,
    output pixel_count: u32
}

impl FastGraphicsPipeline {
    // ========================================================================
    // Clock Generation (PLL)
    // ========================================================================

    signal geom_clk: clock;      // 200 MHz for geometry processor
    signal rast_clk: clock;      // 150 MHz for rasterizer
    signal video_clk: clock;     // 148.5 MHz for video output

    let pll = ClockGenerator {
        clk_in: clk_sys,
        rst: rst,

        // Generate 200 MHz: multiply by 10, divide by 5
        clk_out1: geom_clk,
        clk_out1_mult: 10,
        clk_out1_div: 5,

        // Generate 150 MHz: multiply by 3, divide by 2
        clk_out2: rast_clk,
        clk_out2_mult: 3,
        clk_out2_div: 2,

        // Generate 148.5 MHz: multiply by 37, divide by 25
        clk_out3: video_clk,
        clk_out3_mult: 37,
        clk_out3_div: 25
    };

    // ========================================================================
    // Geometry Processor (Speed-Optimized)
    // ========================================================================

    // Use fp32 for maximum precision
    // Use 5 pipeline stages for maximum throughput
    // Use OptimizeLatency intent for fully parallel architecture
    let geometry_proc = GeometryProcessor<fp32, 5, OptimizeLatency> {
        clk: geom_clk,
        rst: rst,

        // Input from AXI controller (vertex stream)
        vertex_valid: vertex_in_valid,
        vertex: vertex_in_data,
        vertex_ready: vertex_in_ready,

        // Transformation matrices (from AXI registers)
        model_matrix: model_matrix_reg,
        view_matrix: view_matrix_reg,
        proj_matrix: proj_matrix_reg,

        // Lighting parameters (from AXI registers)
        light_dir: light_dir_reg,
        light_color: light_color_reg,
        ambient_color: ambient_color_reg,
        specular_exp: specular_exp_reg,

        // Output to rasterizer (via FIFO)
        output_valid: geom_out_valid,
        output_vertex: geom_out_vertex,
        output_ready: geom_out_ready
    };

    // ========================================================================
    // Geometry-to-Rasterizer FIFO (Deep Buffer)
    // ========================================================================

    // Use deep FIFO (64 entries) to absorb burst traffic
    // This allows geometry and rasterizer to run independently
    let geom_to_rast_fifo = AsyncFifo<TransformedVertex<fp32>, 64> {
        wr_clk: geom_clk,
        wr_rst: rst,
        wr_data: geom_out_vertex,
        wr_en: geom_out_valid && !geom_fifo_full,
        wr_full: geom_fifo_full,

        rd_clk: rast_clk,
        rd_rst: rst,
        rd_en: rast_in_ready && !geom_fifo_empty,
        rd_data: rast_in_vertex,
        rd_empty: geom_fifo_empty,
        rd_valid: rast_in_valid
    };

    assign geom_out_ready = !geom_fifo_full;

    // ========================================================================
    // Rasterizer (Speed-Optimized)
    // ========================================================================

    // Use fully pipelined rasterizer with 4 stages
    // Parallel scanline processing for maximum pixel throughput
    let rasterizer = RasterizerFast<fp32, 4> {
        clk: rast_clk,
        rst: rst,

        // Input from geometry FIFO
        vertex_valid: rast_in_valid,
        vertex: rast_in_vertex,
        vertex_ready: rast_in_ready,

        // Output to video FIFO
        pixel_valid: rast_out_valid,
        pixel: rast_out_pixel,
        pixel_ready: rast_out_ready
    };

    // ========================================================================
    // Rasterizer-to-Video FIFO (Line Buffer)
    // ========================================================================

    // Line buffer FIFO: Holds 1-2 scanlines worth of pixels
    // 1920 pixels/line * 2 lines = 3840 entries, round to 4096
    let rast_to_video_fifo = AsyncFifo<Pixel, 4096> {
        wr_clk: rast_clk,
        wr_rst: rst,
        wr_data: rast_out_pixel,
        wr_en: rast_out_valid && !video_fifo_full,
        wr_full: video_fifo_full,

        rd_clk: video_clk,
        rd_rst: rst,
        rd_en: video_timing_active && !video_fifo_empty,
        rd_data: video_pixel_data,
        rd_empty: video_fifo_empty,
        rd_valid: video_pixel_valid
    };

    assign rast_out_ready = !video_fifo_full;

    // ========================================================================
    // Video Output Controller (1080p60)
    // ========================================================================

    let video_ctrl = VideoController<SCREEN_WIDTH, SCREEN_HEIGHT> {
        clk: video_clk,
        rst: rst,

        // Pixel data from FIFO
        pixel_valid: video_pixel_valid,
        pixel_data: video_pixel_data,

        // Video outputs
        hsync: video_hsync,
        vsync: video_vsync,
        de: video_de,
        r: video_r,
        g: video_g,
        b: video_b,

        // Timing active (within visible area)
        active: video_timing_active
    };

    // ========================================================================
    // AXI Control Interface
    // ========================================================================

    // Manages configuration registers:
    // - Transformation matrices (model, view, projection)
    // - Lighting parameters
    // - Viewport configuration
    // - Status/statistics readback
    let axi_ctrl = AXIController {
        clk: clk_sys,  // Use system clock for AXI
        rst: rst,

        // AXI interface (all ports connected to entity inputs/outputs)
        // ... (AXI signals)

        // Configuration outputs (synchronized to other clock domains)
        model_matrix: model_matrix_reg,
        view_matrix: view_matrix_reg,
        proj_matrix: proj_matrix_reg,
        light_dir: light_dir_reg,
        light_color: light_color_reg,
        ambient_color: ambient_color_reg,
        specular_exp: specular_exp_reg
    };

    // ========================================================================
    // Statistics Counters
    // ========================================================================

    signal vertex_count_internal: u32;
    signal pixel_count_internal: u32;
    signal frame_count_internal: u32;

    on(geom_clk.rise) {
        if rst {
            vertex_count_internal <= 0u32
        } else if geom_out_valid && geom_out_ready {
            vertex_count_internal <= vertex_count_internal + 1u32
        }
    }

    on(rast_clk.rise) {
        if rst {
            pixel_count_internal <= 0u32
        } else if rast_out_valid && rast_out_ready {
            pixel_count_internal <= pixel_count_internal + 1u32
        }
    }

    on(video_clk.rise) {
        if rst {
            frame_count_internal <= 0u32
        } else if video_vsync {  // Count frames on vsync
            frame_count_internal <= frame_count_internal + 1u32
        }
    }

    // Outputs
    assign busy = geom_out_valid || rast_out_valid;
    assign vertex_count = vertex_count_internal;
    assign pixel_count = pixel_count_internal;
    assign frame_count = frame_count_internal;
}

// ============================================================================
// Performance Characteristics
// ============================================================================

// Theoretical maximum performance:
// - Geometry: 200 MHz / 5 stages = 40M vertices/sec
// - Rasterizer: 150 MHz * 4 pixels/cycle = 600M pixels/sec
// - Frame rate at 1080p: 600M / (1920*1080) ≈ 290 fps (pixel-limited)
//
// Typical performance (with realistic scene complexity):
// - 10M triangles/sec (3 vertices each = 30M vertices/sec)
// - 100M pixels/sec (fill rate)
// - 60 fps @ 1080p with complex scenes
//
// Resource usage (Xilinx Kintex-7 XC7K325T):
// - Slice LUTs: ~45,000 / 203,800 (22%)
// - Slice Registers: ~60,000 / 407,600 (15%)
// - DSP48E1: ~200 / 840 (24%)
// - Block RAM: ~150 / 445 (34%)
// - Power: ~6W typical
//
// Bottlenecks:
// - Geometry processor: Matrix multiply latency
// - Rasterizer: Complex pixel shading
// - Memory bandwidth: Frame buffer access
// - FIFO depth: Burst handling

// ============================================================================
// Usage Notes
// ============================================================================

// Building:
//   skalp build examples/optimized_for_speed.sk -o build/fast_pipeline.sv
//
// Synthesis (Xilinx Vivado):
//   vivado -mode batch -source scripts/synth_fast.tcl
//
// Expected results:
//   - WNS (setup): +0.5ns to +1.0ns margin
//   - WHS (hold): +0.2ns margin
//   - Max frequency: 200 MHz achieved
//   - Resource: 20-25% of XC7K325T
//
// Tuning:
//   - Increase pipeline stages if timing fails
//   - Decrease clock frequency if targeting smaller FPGA
//   - Reduce FIFO depth if BRAM constrained
//   - Use fp16 instead of fp32 to save resources
