// Simple AXI4-Lite Slave with 4 Registers
//
// Implements a basic AXI4-Lite slave interface with 4 32-bit registers
// Demonstrates complex FSM and proper AXI4-Lite protocol handling
//
// Features:
// - AXI4-Lite protocol compliance  
// - Read/write to 4 registers (addresses 0, 4, 8, 12)
// - Proper handshaking (VALID/READY)
// - Address decoding
// - 6-state FSM for protocol handling

entity Axi4LiteSlave {
    in clk: clock
    in rst: reset

    // Write Address Channel
    in awvalid: bit
    out awready: bit
    in awaddr: nat[4]

    // Write Data Channel
    in wvalid: bit
    out wready: bit
    in wdata: nat[32]
    in wstrb: nat[4]

    // Write Response Channel
    out bvalid: bit
    in bready: bit
    out bresp: nat[2]

    // Read Address Channel
    in arvalid: bit
    out arready: bit
    in araddr: nat[4]

    // Read Data Channel
    out rvalid: bit
    in rready: bit
    out rdata: nat[32]
    out rresp: nat[2]
}

impl Axi4LiteSlave {
    // Internal registers (4 x 32-bit)
    signal reg0: nat[32] = 0
    signal reg1: nat[32] = 0
    signal reg2: nat[32] = 0
    signal reg3: nat[32] = 0

    // FSM state (IDLE=0, WRITE_ADDR=1, WRITE_DATA=2, WRITE_RESP=3, READ_ADDR=4, READ_DATA=5)
    signal state: nat[3] = 0

    // Latched address for write/read
    signal addr_latch: nat[4] = 0

    // Response signals
    signal resp_valid: bit = 0
    signal read_valid: bit = 0
    signal read_data_reg: nat[32] = 0

    on(clk.rise) {
        if (rst) {
            state <= 0
            resp_valid <= 0
            read_valid <= 0
            addr_latch <= 0
            reg0 <= 0
            reg1 <= 0
            reg2 <= 0
            reg3 <= 0
        } else {
            // IDLE state
            if (state == 0) {
                if (awvalid == 1) {
                    state <= 1
                    addr_latch <= awaddr
                } else {
                    if (arvalid == 1) {
                        state <= 4
                        addr_latch <= araddr
                    }
                }
            } else {
                if (state == 1) {
                    // WRITE_ADDR: wait for write data
                    if (wvalid == 1) {
                        state <= 2
                        // Perform write based on address
                        if (addr_latch == 0) {
                            reg0 <= wdata
                        } else {
                            if (addr_latch == 4) {
                                reg1 <= wdata
                            } else {
                                if (addr_latch == 8) {
                                    reg2 <= wdata
                                } else {
                                    if (addr_latch == 12) {
                                        reg3 <= wdata
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (state == 2) {
                        // WRITE_DATA: send response
                        state <= 3
                        resp_valid <= 1
                    } else {
                        if (state == 3) {
                            // WRITE_RESP: wait for response handshake
                            if (bready == 1) {
                                state <= 0
                                resp_valid <= 0
                            }
                        } else {
                            if (state == 4) {
                                // READ_ADDR: perform read
                                state <= 5
                                read_valid <= 1
                                if (addr_latch == 0) {
                                    read_data_reg <= reg0
                                } else {
                                    if (addr_latch == 4) {
                                        read_data_reg <= reg1
                                    } else {
                                        if (addr_latch == 8) {
                                            read_data_reg <= reg2
                                        } else {
                                            if (addr_latch == 12) {
                                                read_data_reg <= reg3
                                            } else {
                                                read_data_reg <= 0
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (state == 5) {
                                    // READ_DATA: wait for read handshake
                                    if (rready == 1) {
                                        state <= 0
                                        read_valid <= 0
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Output assignments
    awready = (state == 0) as bit
    wready = (state == 1) as bit
    bvalid = resp_valid
    bresp = 0

    arready = (state == 0) as bit
    rvalid = read_valid
    rdata = read_data_reg
    rresp = 0
}
