// I2C Master Controller
// Implements a simple I2C master with 7-bit addressing
// Clock: 50MHz, I2C Speed: 100kHz (standard mode)
//
// Features:
// - Multi-state FSM (8 states)
// - Byte transmission with ACK/NACK
// - START and STOP condition generation
// - Clock stretching support (in read path)
//
// Limitations:
// - Simplified without full tristate (uses separate SDA in/out)
// - Single byte transactions only
// - No repeated START

entity I2cMaster {
    // System
    in clk: clock          // 50MHz system clock
    in rst: reset

    // Control
    in start: bit          // Start transaction
    in rw: bit            // 0=write, 1=read
    in addr: nat[7]       // 7-bit I2C address
    in write_data: nat[8] // Data to write
    out read_data: nat[8] // Data read
    out busy: bit         // Transaction in progress
    out ack_received: bit // ACK from slave

    // I2C Bus (simplified - not true bidirectional)
    out scl: bit          // I2C clock
    out sda_out: bit      // SDA output
    in sda_in: bit        // SDA input
    out sda_oe: bit       // SDA output enable
}

impl I2cMaster {
    // FSM States
    // 0 = IDLE
    // 1 = START
    // 2 = ADDR
    // 3 = ACK_ADDR
    // 4 = DATA
    // 5 = ACK_DATA
    // 6 = STOP
    // 7 = WAIT
    signal state: nat[3] = 0

    // Clock divider for 100kHz I2C clock (50MHz / 500 = 100kHz)
    signal clk_div: nat[9] = 0
    signal scl_tick: bit = 0     // Pulse at 4x I2C clock (400kHz)
    signal scl_phase: nat[2] = 0 // 0-3 for SCL phases

    // Shift register and bit counter
    signal shift_reg: nat[8] = 0
    signal bit_count: nat[3] = 0

    // Internal signals
    signal scl_reg: bit = 1
    signal sda_out_reg: bit = 1
    signal sda_oe_reg: bit = 0
    signal ack_reg: bit = 0
    signal read_data_reg: nat[8] = 0

    // Output assignments
    scl = scl_reg
    sda_out = sda_out_reg
    sda_oe = sda_oe_reg
    busy = (state != 0)
    ack_received = ack_reg
    read_data = read_data_reg

    on(clk.rise) {
        if (rst) {
            state <= 0
            clk_div <= 0
            scl_tick <= 0
            scl_phase <= 0
            scl_reg <= 1
            sda_out_reg <= 1
            sda_oe_reg <= 0
            bit_count <= 0
            ack_reg <= 0
        } else {
            // Clock divider: 50MHz / 125 = 400kHz tick (4x I2C clock)
            if (clk_div == 124) {
                clk_div <= 0
                scl_tick <= 1
                scl_phase <= (scl_phase + 1) % 4
            } else {
                clk_div <= clk_div + 1
                scl_tick <= 0
            }

            // FSM
            if (state == 0) {
                // IDLE
                scl_reg <= 1
                sda_out_reg <= 1
                sda_oe_reg <= 0
                ack_reg <= 0

                if (start) {
                    state <= 1
                    // Prepare address + R/W bit
                    shift_reg <= (addr * 2) + rw
                    bit_count <= 0
                    scl_phase <= 0
                }
            } else if (state == 1) {
                // START condition: SDA falls while SCL high
                sda_oe_reg <= 1
                if (scl_tick && (scl_phase == 0)) {
                    sda_out_reg <= 0
                    state <= 2
                    bit_count <= 0
                }
            } else if (state == 2) {
                // ADDR: Send address + R/W (8 bits)
                sda_oe_reg <= 1

                if (scl_tick) {
                    if (scl_phase == 0) {
                        // Setup phase: set SDA
                        if (bit_count < 8) {
                            sda_out_reg <= (shift_reg / 128) % 2
                        }
                        scl_reg <= 0
                    } else if (scl_phase == 1) {
                        // SCL rising
                        scl_reg <= 1
                    } else if (scl_phase == 2) {
                        // SCL high - data stable
                        scl_reg <= 1
                    } else if (scl_phase == 3) {
                        // SCL falling
                        scl_reg <= 0
                        shift_reg <= (shift_reg * 2) % 256
                        bit_count <= bit_count + 1

                        if (bit_count == 7) {
                            state <= 3
                        }
                    }
                }
            } else if (state == 3) {
                // ACK_ADDR: Release SDA and sample ACK
                if (scl_tick) {
                    if (scl_phase == 0) {
                        sda_oe_reg <= 0  // Release SDA
                        scl_reg <= 0
                    } else if (scl_phase == 1) {
                        scl_reg <= 1
                    } else if (scl_phase == 2) {
                        // Sample ACK
                        ack_reg <= (sda_in == 0)
                        scl_reg <= 1
                    } else if (scl_phase == 3) {
                        scl_reg <= 0
                        if (rw == 0) {
                            // Write mode: send data byte
                            state <= 4
                            shift_reg <= write_data
                            bit_count <= 0
                        } else {
                            // Read mode: receive data byte
                            state <= 4
                            bit_count <= 0
                        }
                    }
                }
            } else if (state == 4) {
                // DATA: Send/receive data byte
                if (rw == 0) {
                    // Write mode
                    sda_oe_reg <= 1
                    if (scl_tick) {
                        if (scl_phase == 0) {
                            if (bit_count < 8) {
                                sda_out_reg <= (shift_reg / 128) % 2
                            }
                            scl_reg <= 0
                        } else if (scl_phase == 1) {
                            scl_reg <= 1
                        } else if (scl_phase == 2) {
                            scl_reg <= 1
                        } else if (scl_phase == 3) {
                            scl_reg <= 0
                            shift_reg <= (shift_reg * 2) % 256
                            bit_count <= bit_count + 1
                            if (bit_count == 7) {
                                state <= 5
                            }
                        }
                    }
                } else {
                    // Read mode
                    sda_oe_reg <= 0  // Release SDA
                    if (scl_tick) {
                        if (scl_phase == 0) {
                            scl_reg <= 0
                        } else if (scl_phase == 1) {
                            scl_reg <= 1
                        } else if (scl_phase == 2) {
                            // Sample SDA
                            shift_reg <= (shift_reg * 2) + sda_in
                            scl_reg <= 1
                        } else if (scl_phase == 3) {
                            scl_reg <= 0
                            bit_count <= bit_count + 1
                            if (bit_count == 7) {
                                read_data_reg <= shift_reg
                                state <= 5
                            }
                        }
                    }
                }
            } else if (state == 5) {
                // ACK_DATA: Master ACK for read, sample ACK for write
                if (rw == 0) {
                    // Write: sample slave ACK
                    if (scl_tick) {
                        if (scl_phase == 0) {
                            sda_oe_reg <= 0
                            scl_reg <= 0
                        } else if (scl_phase == 1) {
                            scl_reg <= 1
                        } else if (scl_phase == 2) {
                            ack_reg <= (sda_in == 0)
                            scl_reg <= 1
                        } else if (scl_phase == 3) {
                            scl_reg <= 0
                            state <= 6
                        }
                    }
                } else {
                    // Read: master sends NACK (end of transaction)
                    if (scl_tick) {
                        if (scl_phase == 0) {
                            sda_oe_reg <= 1
                            sda_out_reg <= 1  // NACK
                            scl_reg <= 0
                        } else if (scl_phase == 1) {
                            scl_reg <= 1
                        } else if (scl_phase == 2) {
                            scl_reg <= 1
                        } else if (scl_phase == 3) {
                            scl_reg <= 0
                            state <= 6
                        }
                    }
                }
            } else if (state == 6) {
                // STOP: SDA rises while SCL high
                sda_oe_reg <= 1
                if (scl_tick) {
                    if (scl_phase == 0) {
                        sda_out_reg <= 0
                        scl_reg <= 0
                    } else if (scl_phase == 1) {
                        scl_reg <= 1
                    } else if (scl_phase == 2) {
                        sda_out_reg <= 1  // STOP condition
                        scl_reg <= 1
                    } else if (scl_phase == 3) {
                        state <= 7
                    }
                }
            } else if (state == 7) {
                // WAIT: Hold for one more cycle
                if (scl_tick && (scl_phase == 0)) {
                    state <= 0
                }
            }
        }
    }
}
