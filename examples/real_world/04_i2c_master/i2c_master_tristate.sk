// I2C Master Controller with True Tristate I/O
// Tests SKALP support for bidirectional ports
//
// This version uses `inout` for SDA to represent true bidirectional signaling
// instead of separate in/out/oe signals.

entity I2cMasterTristate {
    // System
    in clk: clock
    in rst: reset

    // Control
    in start: bit
    in rw: bit            // 0=write, 1=read
    in addr: nat[7]       // 7-bit address
    in write_data: nat[8]
    out read_data: nat[8]
    out busy: bit
    out ack_received: bit

    // I2C Bus with bidirectional SDA
    out scl: bit
    inout sda: bit        // Bidirectional SDA line
}

impl I2cMasterTristate {
    // FSM states
    signal state: nat[3] = 0

    // Clock divider
    signal clk_div: nat[9] = 0
    signal scl_tick: bit = 0
    signal scl_phase: nat[2] = 0

    // Data handling
    signal shift_reg: nat[8] = 0
    signal bit_count: nat[3] = 0

    // Internal registers
    signal scl_reg: bit = 1
    signal sda_drive: bit = 0      // When 1, drive SDA low
    signal ack_reg: bit = 0
    signal read_data_reg: nat[8] = 0

    // Outputs
    scl = scl_reg
    busy = (state != 0)
    ack_received = ack_reg
    read_data = read_data_reg

    // SDA tristate logic:
    // - When sda_drive=1, drive SDA to 0
    // - When sda_drive=0, release SDA (pulled high by external resistor)
    // Reading: when released, sample sda input
    sda = sda_drive ? 0 : 1  // This may need special syntax for tristate

    on(clk.rise) {
        if (rst) {
            state <= 0
            clk_div <= 0
            scl_tick <= 0
            scl_phase <= 0
            scl_reg <= 1
            sda_drive <= 0
            bit_count <= 0
            ack_reg <= 0
        } else {
            // Clock divider
            if (clk_div == 124) {
                clk_div <= 0
                scl_tick <= 1
                scl_phase <= (scl_phase + 1) % 4
            } else {
                clk_div <= clk_div + 1
                scl_tick <= 0
            }

            // FSM (simplified for testing)
            if (state == 0) {
                // IDLE
                scl_reg <= 1
                sda_drive <= 0

                if (start) {
                    state <= 1
                    shift_reg <= (addr * 2) + rw
                    bit_count <= 0
                    scl_phase <= 0
                }
            } else if (state == 1) {
                // START condition
                if (scl_tick && (scl_phase == 0)) {
                    sda_drive <= 1  // Pull SDA low
                    state <= 2
                }
            } else if (state == 2) {
                // Send address byte
                if (scl_tick) {
                    if (scl_phase == 0) {
                        // Setup data bit
                        if ((shift_reg / 128) % 2 == 1) {
                            sda_drive <= 0  // Release for '1'
                        } else {
                            sda_drive <= 1  // Pull low for '0'
                        }
                        scl_reg <= 0
                    } else if (scl_phase == 3) {
                        scl_reg <= 0
                        shift_reg <= (shift_reg * 2) % 256
                        bit_count <= bit_count + 1
                        if (bit_count == 7) {
                            state <= 3
                        }
                    }
                }
            } else if (state == 3) {
                // ACK: Release SDA and read
                if (scl_tick) {
                    if (scl_phase == 0) {
                        sda_drive <= 0  // Release
                        scl_reg <= 0
                    } else if (scl_phase == 2) {
                        // Sample ACK (would need to read sda input here)
                        ack_reg <= 1  // Placeholder
                    } else if (scl_phase == 3) {
                        scl_reg <= 0
                        state <= 6  // Skip to STOP for this test
                    }
                }
            } else if (state == 6) {
                // STOP condition
                if (scl_tick) {
                    if (scl_phase == 0) {
                        sda_drive <= 1
                        scl_reg <= 0
                    } else if (scl_phase == 2) {
                        sda_drive <= 0  // Release SDA while SCL high
                        scl_reg <= 1
                    } else if (scl_phase == 3) {
                        state <= 0
                    }
                }
            }
        }
    }
}
