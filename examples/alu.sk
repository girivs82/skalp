// Arithmetic Logic Unit for testing complex combinational logic
entity ALU {
    in a: bit[32]
    in b: bit[32]
    in op: bit[3]
    in clk: clock
    out result: bit[32]
    out zero: bit[1]
    out overflow: bit[1]
}

impl ALU {
    signal result_comb: bit[32]
    signal zero_comb: bit[1]
    signal overflow_comb: bit[1]

    // Combinational logic for ALU operations
    result_comb = match op {
        0b000 => a + b,           // ADD
        0b001 => a - b,           // SUB
        0b010 => a & b,           // AND
        0b011 => a | b,           // OR
        0b100 => a ^ b,           // XOR
        0b101 => a << b[4:0],     // SHL
        0b110 => a >> b[4:0],     // SHR
        0b111 => if a < b { 1 } else { 0 }, // SLT
        _ => 0
    };

    zero_comb = if result_comb == 0 { 1 } else { 0 };

    // Overflow detection for ADD/SUB
    overflow_comb = if op == 0b000 {
        (~a[31] & ~b[31] & result_comb[31]) | (a[31] & b[31] & ~result_comb[31])
    } else if op == 0b001 {
        (~a[31] & b[31] & result_comb[31]) | (a[31] & ~b[31] & ~result_comb[31])
    } else {
        0
    };

    // Register outputs
    on(clk.rise) {
        result <= result_comb
        zero <= zero_comb
        overflow <= overflow_comb
    }
}