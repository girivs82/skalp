// Test all Phase 2 features
// This comprehensive example demonstrates:
// - Match/case statements for state machine
// - Array support
// - Function calls
// - Complex event blocks
// - All types (bit, nat, logic, clock, reset)

entity StateMachine {
    in clk: clock
    in rst: reset
    in data_in: nat[8]
    in enable: bit[1]
    out data_out: nat[8]
    out state_out: nat[2]
    out valid: bit[1]
}

impl StateMachine {
    // Signal declarations with different types
    signal state: nat[2] = 0
    signal buffer: nat[8] = 0
    signal counter: nat[4] = 0
    signal memory: bit[8][4] = 0  // Array of 4 8-bit values

    // Function call example (would be a system function)
    signal checksum: nat[8] = compute_checksum(data_in)

    on(clk.rise) {
        if (rst) {
            state <= 0
            counter <= 0
            buffer <= 0
            valid <= 0
        } else {
            match state {
                0 => {
                    if (enable) {
                        buffer <= data_in
                        state <= 1
                        counter <= counter + 1
                    }
                }
                1 => {
                    // Store in memory array
                    memory[counter[1:0]] <= buffer[7:0]
                    data_out <= buffer + checksum
                    valid <= 1
                    state <= 2
                }
                2 => {
                    // Read from memory array and output
                    data_out <= memory[0] | memory[1]
                    valid <= 0
                    if (counter >= 3) {
                        state <= 0
                        counter <= 0
                    } else {
                        state <= 0
                    }
                }
                _ => {
                    state <= 0
                    valid <= 0
                }
            }
        }
    }

    // Continuous assignment
    state_out = state
}